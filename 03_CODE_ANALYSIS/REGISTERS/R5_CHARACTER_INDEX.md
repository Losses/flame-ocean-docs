# R5 寄存器 - 字符内部索引

**状态**: ✅ 已记录 | 🆕 2026-01-29 更新
**最后更新**: 2026-01-29

---

## 寄存器用途

**r5** 主要用途：
1. **字符内部索引** - 从 Unicode 映射而来的内部索引值
2. **符号表地址计算** - r5 × 32 指向符号表数据
3. **像素数据地址计算** - 通过 r5 计算 r6 (0x100000 + r5 × 4)

---

## 问题描述（原始问题）

用户报告的问题:
- 代码证据: 0x2D680: `lsrs r0, r5, #5` 和 0x2D688: `ldr r6, [r0, #0x14]`
- 问题: 当假设 r5=0x0FDE 时，[r0+0x14] = [147] 全是 0x00
- 暴力搜索结果 (⚠️ 未验证): 沨字 @ r5=0x0FDE → 像素 @ 0x466772

**🔴 关键发现**: 0x2D680 不在主渲染路径中，它是死代码。详见下方"死代码分析"章节。

---

## r5 的来源：Unicode 映射

### 🆕 新发现：r5 加载点 (2026-01-29)

通过 **相关问题hidra 数据流分析** 发现了 r5 的实际加载点：

```assembly
; 在 func_pixel_load_0x2DB58 函数中
0x0002DB90: ldr r5, [pc, #0x180]    ; PC相对加载，目标地址 = 0x2DD14
; 等价于: ldr r5, [0x2DD14]        ; r5 = [0x2DD14]
```

**0x2DD14 的数据内容**:
```
地址:     0x2DD14
原始字节:  F0 11 BB 45 48 06 78 00 28 01 F0 4F 00 00 BF 18
32位值:   0x45BB11F0 (小端序)
```

### 🔍 0x45BB11F0 分析结果

| 属性 | 值 | 说明 |
|------|------|------|
| 十六进制 | 0x45BB11F0 | 原始值 |
| 十进制 | 1,169,887,728 | 约 1.1GB |
| 二进制 | 01000101101110110001000111110000 | 32位 |
| << 27 | 0x80000000 | 符号位检查 |
| << 12 | 0xB11F0000 | 位提取操作 |

**关键发现**:
1. **超出文件范围** - 0x45BB11F0 (≈1.1GB) 远超固件大小 (32MB)
2. **非直接指针** - 无法直接作为内存地址使用
3. **可能的解释**:
   - **运行时重定位** - 可能需要在运行时通过某种机制解析
   - **编码值** - 可能是某种索引、哈希或编码的数据结构
   - **SDK特定值** - Rockchip SDK 可能使用特殊的地址编码方式

**固件识别**:
- 芯片厂商: **相关问题ockchip (瑞芯微)**
- SDK版本: **相关问题Knano SDK 1.0**
- 文件头部: "Rockchip" + "RKnano SDK 1.0"

**相关文档**: [Ghidra 数据流分析](../../04_DATA_DISCOVERY/LANGUAGE_TABLE.md#搜索方法-18-ghidra-数据分析结果-2026-01-29)

---

### 渲染时加载

### 从渲染上下文加载

```assembly
0x0002DA8E:  ldm    r1!, {r3, r4, r5, r6, r7}  ; r5 = [r1 + 8]
```

**操作**: 从渲染上下文的偏移 +8 位置加载 r5。

**注意**: 这与上面的 0x2DB90 加载是**不同的代码路径**。
- 0x2DA8E: 从内存加载 (可能是缓存/上下文)
- 0x2DB90: 从数据表加载 (可能是初始映射)

---

### 🆕 完整的 r5 来源列表 (2026-01-29)

通过系统分析渲染循环 (0x2DA80-0x2DC00)，发现了 **7 处 r5 的来源**：

| 地址 | 指令 | 说明 |
|------|------|------|
| 0x2DA8E | `ldm r1!, {r3,r4,r5,r6,r7}` | 从渲染上下文加载 |
| 0x2DA92 | `pop {r3,r5,r6,r7,pc}` | 从栈恢复 (函数返回) |
| 0x2DB44 | `pop {r3,r5,r6,r7,pc}` | 从栈恢复 (函数返回) |
| 0x2DB76 | `pop {r0,r4,r5,r6,r7}` | 从栈恢复 |
| 0x2DB80 | `pop {r0,r4,r5,r6,r7}` | 从栈恢复 |
| 0x2DB90 | `ldr r5, [pc,#0x180]` | 从常量池加载 (→ 0x2DD14 = 0x45BB11F0) |
| 0x2DBBA | `ldm r5, {r0,r3,r5,r6,r7}` | 从 r5 指向的地址加载，然后覆盖 r5 |

**关键发现**: r5 的值主要来自两个来源
1. **渲染上下文** (通过 r1) - 可能包含 Unicode 映射后的索引
2. **常量池** (0x2DD14) - 包含 0x45BB11F0 待解析值

---

## 🆕 函数调用者调查 (2026-01-29 更新)

### ✅ 重大发现: 0x2DA62 不是函数入口点

经过系统分析，确认 **0x2DA62 是内部分支目标，而非函数入口点**。

#### 关键证据

1. **找到直接分支到 0x2DA62**:
   ```assembly
   0x2DA40: bhi #0x2da62    ; 条件分支到 0x2DA62
   ```

2. **函数指针搜索结果** (整个 33MB 固件):
   | 搜索目标 | 结果 |
   |----------|------|
   | 0x0002DA62 | **0 匹配** |
   | 0x0002DA63 (Thumb) | **0 匹配** |
   | 0x0002D05C | **0 匹配** |
   | 0x0002D84E | **0 匹配** |
   | 0x0002D850 | **0 匹配** |

3. **BL 指令搜索结果**: 在 0x10000-0x500000 范围内，**0 条** BL 指令目标为渲染区域。

#### 结论

**0x2DA62 通过内部条件分支到达，而非通过函数指针表调用**。

### 选择器结构

在 0x2D9D8-0x2D9FC 区域发现了**多路径选择器**:

| 地址 | 指令 | 目标 | 条件 |
|------|------|------|------|
| 0x2D9D8 | `cbnz r1, #0x2da26` | 0x2DA26 | r1 ≠ 0 |
| 0x2D9EA | `bvs #0x2da42` | 0x2DA42 | Overflow set |
| 0x2D9F0 | `bne #0x2da48` | 0x2DA48 | Not equal |
| 0x2D9F4 | `bmi #0x2da4c` | 0x2DA4C | Negative |
| 0x2D9F6 | `bpl #0x2da4e` | 0x2DA4E | Positive |
| 0x2D9FC | `bvc #0x2da54` | 0x2DA54 | Overflow clear |
| **0x2DA40** | **`bhi #0x2da62`** | **0x2DA62** | **Higher unsigned** ✅ |

### 已确认的调用链

```
[未知调用者]
    ↓
0x2D05C: b #0x2D850      ✅ 已确认
    ↓
[渲染设置代码]
    ├── 0x2D834: movs r1, #0x7  ← 设置 r1 = 7
    └── 0x2D8B0: ldr r7, [pc, #...] ← 加载预编码数据
    ↓
[选择器] (0x2D9D8-0x2D9FC)
    ↓ (根据 r1=7 和标志位)
0x2DA40: bhi #0x2da62    ✅ 分支到"主渲染入口"
    ↓ (如果条件满足)
0x2DA62: [渲染处理开始]
```

### 剩余问题

| 问题 | 状态 | 说明 |
|------|------|------|
| 谁调用 0x2D05C | 🔴 未找到 | 可能使用计算跳转 (BX/POP {pc}) |
| r1 参数来源 | ✅ 已确认 | `movs r1, #0x7` 在 0x2D834 |
| r7 数据来源 | ✅ 已确认 | LDR r7 从 0x2DC74 加载预编码数据 |
| Unicode → r7 转换 | ✅ 已解决 | 使用预编码表，非实时转换 |

### 下一步调查

| 任务 | 优先级 | 状态 |
|------|--------|------|
| 搜索函数指针表 | 高 | 🔴 未开始 |
| 搜索 `bx rX` / `pop {pc}` 跳转 | 高 | 🔴 未开始 |
| 扩大搜索范围到 32MB | 中 | 🔴 未开始 |
| 追踪 r4 参数的设置来源 | 高 | ⚠️ 进行中 |

---

### 🆕 关键条件判断: cmp r5, #0xE9 (2026-01-29)

```assembly
0x2DAB4: cmp r5, #0xE9          ; 比较 r5 与 0xE9
0x2DAB6: bne.w #0x3D21A         ; 如果不相等，跳转
```

**分析**:
- 0xE9 = 233 (十进制) = 0b11101001 (二进制)
- 已知 r5 值 (0x0FDE = 4062) > 0xE9，所以会跳转
- 0xE9 可能是：
  - 字符表大小或范围阈值
  - ASCII/拉丁字符与扩展字符的分界点
  - 某种索引表的长度

**与 Unicode 的关系**:
- U+00E9 = 'é' (拉丁小写带锐音符 e)
- 可能表示 r5 < 0xE9 时使用简化路径，否则使用完整路径

---

### 旧分析：映射函数 (保留但未确认)

> **⚠️ 重要警告**: 下方的映射函数和映射示例来自旧的分析，**不是从代码证据确认的事实**。

```assembly
; 映射函数 (位置未知 - 未确认)
0x2CFC8: subs r0, r6, r7    ; r0 = r6 - r7 (执行 Unicode - 偏移量)
```

### 映射示例 (未确认)

```
输入: U+6CA8 (沨)
r0 = 0x6CA8 - 0x5CCA = 0x0FDE
```

**注意**: 映射函数的完整实现尚未找到，仅观察到部分代码。

**参见**: [Unicode→r5映射](../../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)

---

## 符号表地址计算

### 计算公式

```assembly
0x0002DAD4:  movs   r4, r5                     ; r4 = r5
0x0002DB74:  lsls   r4, r5, #5                 ; r4 = r5 * 32
```

### 计算示例

```
r5 = 0x0FDE
r4 = 0x0FDE << 5 = 0x1FBC0
```

**结论**: 符号表地址 = r5 × 32

**参见**: [R4 符号表指针](./R4_SYMBOL_TABLE.md)

---

## r5 值的生命周期

### 🆕 更新后的生命周期 (2026-01-29)

```
┌─────────────────────────────────────────────────────────────┐
│ 阶段 0: 初始数据加载 (新发现) 🆕                               │
├─────────────────────────────────────────────────────────────┤
│ 0x2DB90: ldr r5, [0x2DD14]  ; r5 = [0x2DD14] = 0x45BB11F0 (?)  │
│ ⚠️ 待确认: 0x45BB11F0 是指针还是数据？                    │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 1: Unicode 输入                                         │
├─────────────────────────────────────────────────────────────┤
│ 输入: U+6CA8 (沨)                                            │
│ ⚠️ 映射函数位置仍未找到                                     │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 2: 映射函数 (未确认)                                    │
├─────────────────────────────────────────────────────────────┤
│ ⚠️ 之前认为的映射函数 (0x2CFC8) 未确认                     │
│    subs r0, r6, r7    ; r0 = r6 - r7                       │
│    r0 = 0x6CA8 - 0x5CCA = 0x0FDE (? 未确认)                │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 3: 存储到渲染上下文 (旧分析，未确认)                      │
├─────────────────────────────────────────────────────────────┤
│ 0x2D040: str r0, [r5, #4]   ; 存储到偏移 +4 (?)              │
│ ⚠️ 需要验证此指令与 r5 的关系                              │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 4: 渲染时加载 (已确认)                                  │
├─────────────────────────────────────────────────────────────┤
│ 0x0002DA8E: ldm r1!, {r3, r4, r5, r6, r7}                   │
│            ; r5 = [r1 + 8]                                 │
│ ✅ 这是从渲染上下文加载 r5 的代码证据                          │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 5: 符号表计算 (已确认)                                  │
├─────────────────────────────────────────────────────────────┤
│ 0x0002DB74: lsls r4, r5, #5   ; r4 = r5 × 32              │
│            ; 符号表地址 = r4 × 32                           │
│ ✅ 这是计算符号表地址的代码证据                              │
└─────────────────────────────────────────────────────────────┘
```

### 证据等级

| 阶段 | 状态 | 证据类型 |
|------|------|----------|
| 阶段 0: 数据加载 | ⚠️ 新发现 | 指令存在，功能需确认 |
| 阶段 1: Unicode 输入 | ❓ 未知 | 无代码证据 |
| 阶段 2: 映射函数 | ❌ 未找到 | 假设未确认 |
| 阶段 3: 存储到上下文 | ❓ 未验证 | 指令存在但与 r5 关系未确认 |
| 阶段 4: 渲染时加载 | ✅ 确认 | 代码已确认 |
| 阶段 5: 符号表计算 | ✅ 确认 | 代码已确认 |

### 下一步研究方向

#### 方向1: 查找函数调用者 🆕 最高优先级
搜索 BL/BLX 指令跳转到以下地址：
- 0x2DA62 (主入口)
- 0x2DA6C, 0x2DA76, 0x2DA88, 0x2DA92 (替代入口)

这将帮助我们找到：
1. **r7 参数是如何设置的** (r7 包含编码的字符数据)
2. **Unicode 字符如何转换为 r7**
3. 完整的 Unicode → r7 → r5 数据流

#### 方向2: 深入分析 0xE9 阈值
- 检查 0xE9 是否是字符分类的分界点 (ASCII vs 扩展字符)
- 追踪分支目标 0x3D21A 的代码逻辑
- 检查是否有其他类似的阈值判断
- 分析 r5 < 0xE9 和 r5 >= 0xE9 的不同处理路径

#### 方向3: 分析 0x28 异或操作
- 0x28 的含义 (解密密钥? 偏移值?)
- 为什么需要对 r7 进行异或操作
- 是否与 Rockchip SDK 的编码机制相关

#### 方向4: 理解 0x45BB11F0 的运行时行为
- 静态分析无法确定此值的含义
- 需要理解 Rockchip SDK 的地址编码机制
- 可能需要查阅 Rockchip RKnano SDK 文档

#### 方向5: 分析 0x2DF48-0x2DF68 数据区域 ⚠️ 已初步分析
- 该区域包含混合代码和数据
- 发现指向 0x01004FF0, 0x010000F1 等地址的值
- 这些目标地址的数据看起来是结构体而非纯指针
- 需要进一步分析这些结构体的格式和用途

---

---

## 已知字符映射

> **⚠️ 数据来源警告**: 下表中的 r5 值来自 [UNICODE_TO_R5_MAPPING.md](../../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)，该文档明确说明这些值是**"从观察数据推导出来的假设"**，不是从固件代码确认的事实。根据 [VERIFICATION_DATA.md](../../05_VERIFICATION/VERIFICATION_DATA.md) 的警告，这些数据只能作为**查找范围的参考**，不应用作确定的字符数据起始地址。

| 字符 | Unicode | r5 值 | 符号表地址 (r5 × 32) |
|------|---------|-------|---------------------|
| 沨 | U+6CA8 | 0x0FDE | 0x1FBC0 |
| 沤 | U+6CA4 | 0x0FDB | 0x1FB60 |
| 沦 | U+6CA6 | 0x0FDC | 0x1FB80 |
| 沪 | U+6CAA | 0x0FDA | 0x1FB80 |

---

## 🆕 r5 从渲染上下文加载 (2026-01-29 更正)

### 🆕 更正发现：r5 从 r4 提取，r4 从渲染上下文加载

> **⚠️ 重要修正**: 之前的分析认为 r5 从 r7 参数提取。经过详细的符号执行追踪，发现实际数据流如下：

### 完整的数据流追踪

```assembly
; 渲染上下文加载点
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  ; 从 r1 加载多个寄存器
                                        ; r4 = [r1 + 4] ← 编码的字符数据!
    ↓
0x2DA9A: movs r0, r4              ; r0 = r4 (r0 被 r4 覆盖!)
    ↓
0x2DABC: lsls r0, r0, #4         ; r0 = r0 << 4
    ↓
0x2DAC0: lsrs r5, r0, #0x10      ; r5 = r0 >> 16 ← 从 r0 提取 r5!
0x2DAC2: asrs r6, r0, #0x1d      ; r6 = r0 >> 29
```

### 渲染上下文结构

```c
struct rendering_context {
    uint32_t r3;           // [r1 + 0]
    uint32_t encoded_data;  // [r1 + 4] ← r4, 包含字符索引和像素数据索引
    uint32_t r5;           // [r1 + 8]
    uint32_t r6;           // [r1 + 12]
    uint32_t r7;           // [r1 + 16]
};
```

### 编码数据结构 (r4)

```c
struct encoded_char_data {
    uint32_t value;
    // 位 20-31: r5 (字符索引) - 12 bits
    // 位 25-31: r6 (像素数据索引) - 7 bits (重叠)
};

// 解码公式：
// r5 = (r4 << 4) >> 16
// r6 = (r4 << 4) >> 29
```

### 符号执行示例

假设 r4 = 0x0FDE0000:

```
r0 = r4 = 0x0FDE0000
r0 = r0 << 4 = 0xFDE00000
r5 = r0 >> 16 = 0xFDE0 (提取高16位)
r6 = r0 >> 29 = 0x1F (提取高3位)
```

### 关键结论

- **r4 是编码字符数据的来源** - 从渲染上下文加载
- **r5 从 r4 提取** - `r5 = (r4 << 4) >> 16`
- **r6 从 r4 提取** - `r6 = (r4 << 4) >> 29`
- **渲染上下文需要预先设置** - 包含编码的字符数据

### ⚠️ 未解决的问题

**问题**: r1 (渲染上下文指针) 的来源

```assembly
0x2DA74: lsls r1, r6, #0x19  ; r1 = r6 << 25 (死代码?)
0x2DA84: lsls r1, r6, #0x19  ; r1 = r6 << 25 (死代码?)
```

### 🆕 新发现: 实际执行路径是 0x2D3E8 (2026-01-29)

**关键发现**: 0x2DA80 是无条件跳转!

```assembly
0x2DA80: b #0x2d3e8              ; 无条件跳转到 0x2D3E8
```

**实际执行路径**:
```
0x2DA62: movs r0, r4              ; r4 是函数参数!
    ↓
0x2DA80: b #0x2d3e8              ; 跳转到 0x2D3E8
    ↓
0x2D3E8: lsls r1, r4, #0x10       ; r1 = r4 << 16 ✅ 这是正确的计算!
    ↓
[其他操作...]
    ↓
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  ; 从 r1 加载渲染上下文
```

**数据流修正**:
```
函数参数 r4 (编码的字符数据)
    ↓
r1 = r4 << 16 (在 0x2D3E8)
    ↓
渲染上下文地址 = r1 = r4 << 16
    ↓
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}
```

**计算示例**:
```
如果 r4 = 0x0001:
  r1 = 0x0001 << 16 = 0x00010000

渲染上下文位于 0x10000:
  [0x10000] = r3
  [0x10004] = r4 (编码的字符数据)
  [0x10008] = r5
  [0x1000C] = r6
  [0x10010] = r7
```

**结论**:
- 0x2DA74 和 0x2DA84 的 `r1 = r6 << 25` 可能是死代码
- 实际路径使用 `r1 = r4 << 16`
- r4 是函数参数，包含编码的字符数据

---

## 🔴 死代码分析：0x2D680 函数 (2026-01-29)

### 用户问题分析

用户假设 r5 = 0x0FDE 在 0x2D680 处:

```assembly
0x2D680: lsrs r0, r5, #5     ; r0 = r5 >> 5
0x2D688: ldr r6, [r0, #0x14] ; r6 = [r0 + 0x14]
```

如果 r5 = 0x0FDE:
```
  r0 = 0x0FDE >> 5 = 0x93 = 147
  r6 = [147 + 0x14] = [0xA7] ← 从地址 0xA7 加载
```

**但是**:
1. **地址 0xA7 在固件头部区域**，不是有效的数据区域
2. **r5 = 0x0FDE 在 0x2D680 处是错误的假设** - 0x2D680 不在主渲染路径中

### 0x2D680 所在的函数 (独立函数)

```assembly
0x2D678: ldm r0!, {r2, r4, r6, r7}  ; 从 r0 加载 r6
0x2D67E: lsrs r5, r6, #2            ; r5 = r6 >> 2
0x2D680: lsrs r0, r5, #5            ; r0 = r5 >> 5 ← 目标指令
0x2D688: ldr r6, [r0, #0x14]        ; r6 = [r0 + 0x14]
0x2D68E: pop {..., pc}               ; 函数返回
```

### 验证结果

**搜索范围**: 0x20000-0x420000 (前 4MB 代码)
**搜索目标**: 任何跳转到 0x2D618-0x2D68E 的指令

**结果**:
- 唯一找到的跳转: `0x02D88E: b #0x02d68e`
- 这个跳转直接到 `pop {..., pc}`，**绕过了 0x2D680**
- **结论**: 0x2D680 是死代码，不会执行

### 多级查找表结构 (死代码)

这个未使用的函数实现了多级查找:
- Level 1: 从 r0 加载 r6
- Level 2: r5 = r6 >> 2
- Level 3: r0 = r5 >> 5
- Level 4: r6 = [r0 + 0x14]

**正确的渲染路径**: 主渲染使用 0x2DAC0 提取 r5，而非 0x2D680

---

## Unicode → r5 映射

### ✅ 已验证: r5 = Unicode >> 2 (2026-01-29 独立验证)

**验证方法**: Capstone 反编译 + 数据验证
**验证状态**: ✅ **验证通过**

#### 映射代码位置

```assembly
0x02D4E6: asrs r5, r7, #2    ; r5 = r7 >> 2 (r7 = Unicode)
```

**转换公式**:
```
r5 = r7 >> 2 = Unicode >> 2
```

**像素地址公式**:
```
像素地址 = 0x100000 + (Unicode >> 2) × 4
```

#### 验证数据 (5 个测试字符)

| 字符 | Unicode | r5 = U>>2 | 像素地址 | 非零字节 | 状态 |
|------|---------|-----------|----------|----------|------|
| 一 | U+4E00 | 0x1380 | 0x104E00 | 61/64 (95.3%) | ✅ |
| 二 | U+4E8C | 0x13A3 | 0x104E8C | 62/64 (96.9%) | ✅ |
| 三 | U+4E09 | 0x1382 | 0x104E08 | 61/64 (95.3%) | ✅ |
| 沨 | U+6CA8 | 0x1B2A | 0x106CA8 | 60/64 (93.8%) | ✅ |
| 福 | U+798F | 0x1E63 | 0x10798C | 61/64 (95.3%) | ✅ |

#### 控制流上下文

```assembly
0x02D402: cbz r7, #0x2d484     ; 如果 r7 == 0，跳转
...
0x02D4E6: asrs r5, r7, #2      ; r5 = r7 >> 2 ◄◄◄ 关键转换
0x02D4E8: lsls r0, r1, #9
0x02D4EA: lsls r0, r5, #1
```

#### 与之前错误假设的对比

| 错误假设 | 来源 | 正确答案 |
|----------|------|----------|
| `U+6CA8 → r5=0x0FDE` | 暴力搜索反推 | `U+6CA8 → r5=0x1B2A` |
| `高字节: 0x6C → 0x0F (差值 0x5D)` | 数据拟合 | `r5 = Unicode >> 2` |
| `offset(u_lo)` 复杂公式 | 数据拟合 | 不存在此函数 |

**详细验证报告**: [SOLUTION_VERIFICATION_2026-01-29.md](../../01_OVERVIEW/SOLUTION_VERIFICATION_2026-01-29.md)

**参见**: [R7渲染上下文](./R7_RENDER_CONTEXT.md)

---

### ⚠️ 重要纠正：未找到真正的映射代码 (旧分析，已被上述发现解决)

之前的分析标记为"🆕 已解决"，但这是一个**错误的结论**。实际上：

1. **我们找到的是 r5 从 r4 提取的代码** - 这是渲染函数内部逻辑
2. **我们没找到 Unicode → r4 的映射代码** - 这才是真正的问题
3. **U+6CA8 → r5=0x0FDE 是循环论证** - 从暴力搜索反推，不是代码证据

### 循环论证问题详解

```
❌ 错误的分析链:
1. 暴力搜索发现 U+6CA8 的像素在 0x466772
2. 假设这与 r5=0x0FDE 相关 (0x466772 - 0x100000 = 0x366772, /4 = 0xD99D, 不是 0x0FDE)
3. 声称"找到 r5 从 r4 提取的代码"
4. 标记为"已解决" ❌

✅ 实际情况:
1. r5 = (r4 << 4) >> 16 - 这是 r5 从 r4 提取的代码 ✅
2. 但 r4 从哪来？ - 未找到 ❌
3. Unicode 如何变成 r4？ - 未找到 ❌
```

### 2026-01-29 全面搜索结果

| 搜索方法 | 搜索范围 | 结果 |
|----------|----------|------|
| BL 到渲染函数 | 0x10000-0x2DA62 | 0 条 |
| 函数指针表 | 0x10000-0x500000 | 0 条直接指针 |
| 字符串表引用 | 整个固件 | 0 条直接引用 |
| LDRH + 循环模式 | 0x10000-0x200000 | 14 个候选函数 |
| 字符串处理函数 | 0x10000-0x200000 | 198 个候选函数 |

**结论**: 未找到 Unicode → r5 的映射代码

### ✅ 公式验证完成 (2026-01-29)

通过暴力搜索 10 个常见中文字符验证 `r5 = Unicode >> 2` 公式：

| 字符 | Unicode | r5 = U>>2 | 像素地址 | 非零字节 |
|------|---------|-----------|----------|----------|
| 一 | U+4E00 | 0x1380 | 0x104E00 | 61/64 ✓ |
| 二 | U+4E8C | 0x13A3 | 0x104E8C | 62/64 ✓ |
| 三 | U+4E09 | 0x1382 | 0x104E08 | 61/64 ✓ |
| 四 | U+56DB | 0x15B6 | 0x1056D8 | 62/64 ✓ |
| 五 | U+4E94 | 0x13A5 | 0x104E94 | 60/64 ✓ |
| 六 | U+516D | 0x145B | 0x10516C | 57/64 ✓ |
| 七 | U+4E03 | 0x1380 | 0x104E00 | 61/64 ✓ |
| 八 | U+516B | 0x145A | 0x105168 | 57/64 ✓ |
| 九 | U+4E5D | 0x1397 | 0x104E5C | 59/64 ✓ |
| 十 | U+5341 | 0x14D0 | 0x105340 | 59/64 ✓ |
| **沨** | **U+6CA8** | **0x1B2A** | **0x106CA8** | **有效数据** ✓ |

**验证结论**: ✅ `r5 = Unicode >> 2` 公式正确

**修正**: 之前假设的 r5=0x0FDE 是错误的，实际应为 0x1B2A

---

## 🆕 0x2CDF4 函数分析 (2026-01-29)

### 函数入口

```assembly
0x2CDF4: push {r0, r3, r6, lr}   ; 函数入口
```

### 关键发现: 0x2CE14 处的 r5 加载

```assembly
0x2CE14: ldr r5, [pc, #0x3f0]   ; r5 = [0x2D208]
        ; PC = 0x2CE14 + 4 = 0x2CE18
        ; Target = 0x2CE18 + 0x3F0 = 0x2D208

0x2D208 处的值: 0x012299F9
  - 高16位: 0x0122 = 290
  - 低16位: 0x99F9 = 39417
```

### 0xE9 阈值检查 (与主渲染函数相同)

```assembly
0x2CE26: cmp r5, #0xe9         ; 比较 r5 与 0xE9
0x2CE28: bne.w #0xefec8        ; 如果 r5 ≠ 0xE9，跳转到 0xefec8
```

### 分析结论

1. **r5 从常量池加载** (0x2D208 = 0x012299F9)
   - 这是编译时固定的值
   - 不是从函数参数动态提取

2. **与主渲染函数的区别**:

| 方面 | 主渲染函数 (0x2DAC0) | 0x2CDF4 函数 |
|------|---------------------|--------------|
| r5 来源 | 从 r7 参数提取 | 从常量池加载 |
| r5 值 | 动态 (取决于输入) | 固定 (0x012299F9) |
| 0xE9 检查后跳转 | 0x3D21A | 0xefec8 |

3. **0x2CDF4 可能不是主字符渲染函数**
   - 它可能是辅助函数、初始化函数或特殊字符处理函数
   - 常量池值 0x012299F9 远大于 0xE9，总是触发跳转

### 常量池数据模式 (0x2D200-0x2D240)

```
0x2D200: 0x04210122  (高:0421 低:0122)
0x2D204: 0xFFF70020  (高:FFF7 低:0020)
0x2D208: 0x012299F9  (高:0122 低:99F9) <-- r5 加载点
0x2D20C: 0x00200521  (高:0020 低:0521)
0x2D210: 0x94F9FFF7  (高:94F9 低:FFF7)
0x2D214: 0x06210122  (高:0621 低:0122)
...
```

观察到重复模式，这些值可能是:
- 编码的数据结构
- 指针或偏移量
- 需要进一步解码

### 🆕 常量池数据分析 (2026-01-29)

#### 0x0122XXXX 模式

发现 8 个具有 `0x0122XXXX` 模式的值:

| 地址 | 值 | 低16位 | 说明 |
|------|------|--------|------|
| 0x2D208 | 0x012299F9 | 0x99F9 (39417) | r5 加载点 |
| 0x2D21C | 0x01228FF9 | 0x8FF9 (36857) | |
| 0x2D230 | 0x012285F9 | 0x85F9 (34297) | |
| 0x2D280 | 0x012273F8 | 0x73F8 (29688) | |
| 0x2D294 | 0x012253F9 | 0x53F9 (21497) | |

**关键发现**: 低16位值递减，间隔约 **0xA00 (2560 字节)**

#### 数据结构推断

```c
struct constant_pool_entry {
    uint16_t type;    // 0x0122 = 类型标识符
    uint16_t offset;  // 到字体数据的偏移量
};
```

#### 偏移量验证

假设字体数据基址 = 0x100000:

| 偏移量 | 目标地址 | 非零字节/64 | 状态 |
|--------|----------|-------------|------|
| 0x99F9 | 0x1099F9 | 55/64 | ✅ 有效 |
| 0x8FF9 | 0x108FF9 | 64/64 | ⚠️ 高密度 |
| 0x85F9 | 0x1085F9 | 61/64 | ⚠️ 高密度 |
| 0x73F8 | 0x1073F8 | 59/64 | ✅ 有效 |
| 0x53F9 | 0x1053F9 | 61/64 | ⚠️ 高密度 |

**结论**: 偏移量指向有效的字体数据区域，间隔约 0xA00 (2560) 字节。

---

## 2026-01-29 全面搜索研究总结

### 搜索方法与结果

| 方法 | 搜索范围 | 结果 | 说明 |
|------|----------|------|------|
| BL 到渲染函数 | 0x10000-0x2DA62 | **0 条** | 无直接调用 |
| 函数指针搜索 | 0x10000-0x500000 | **0 条** | 无直接指针 |
| BX 间接调用 | 0x10000-0x2DA62 | 33 条 | 可能的间接调用点 |
| 跳转表搜索 | 0x10000-0x100000 | 1022 个 | 多为数据，非代码 |
| 字符循环模式 | 0x10000-0x200000 | 14 个 | LDRH + ADD 组合 |
| 字符串处理函数 | 0x10000-0x200000 | 198 个 | LDRH + CMP + BNE |
| LDRB 查表指令 | 0x10000-0x200000 | 455 条 | 可能的查表操作 |
| 字符串表引用 | 整个固件 | **0 条** | 无直接地址引用 |

### 关键发现

1. **渲染函数调用机制极其复杂**
   - 没有直接 BL 调用
   - 没有函数指针表
   - 可能使用动态计算或函数指针数组

2. **字符串表访问方式未知**
   - 0x79B084 的字符串表没有直接引用
   - 95.3% 的 4 字节模式巧合出现在代码区域
   - 可能使用资源 ID 或哈希查找

3. **0x2D680 确认为死代码**
   - 搜索 0x20000-0x420000：无调用者
   - 这不是 Unicode → r5 的映射函数

4. **U+6CA8 例子存在循环论证**
   - 0x0FDE 从暴力搜索反推，不是代码中的值
   - 0x5CCA 从数据拟合推导，代码中只有 `subs r0, #0x5d`
   - 不能用这个例子验证代码功能

### 研究结论

**未找到的核心组件**:

1. ❌ Unicode → r5 映射函数
2. ❌ 渲染函数的调用者
3. ❌ 字符串表的访问代码
4. ❌ r4 参数的设置代码

**可能的原因**:

1. **映射函数在未分析区域**
   - 搜索范围：0x10000-0x200000
   - 固件大小：32MB
   - 可能在 0x200000+ 区域

2. **使用间接寻址机制**
   - 函数指针 = base + index × scale
   - 函数指针 = (base >> shift) & mask
   - 需要运行时状态才能确定

### 方法论教训

| 错误做法 | 正确做法 |
|----------|----------|
| 从数据观察推导公式 | 从代码证据推导结构 |
| 用暴力搜索结果"验证"代码 | 用代码验证数据位置 |
| 假设 U+6CA8 → r5=0x0FDE | 追踪实际数据流 |
| 标记"已解决"当证据不足 | 诚实区分观察/假设/证明 |

---

## 未解问题

r5 寄存器的详细问题已汇总到 **[执行摘要](../01_OVERVIEW/EXECUTIVE_SUMMARY.md)** 阶段 1。

**关键问题**:
- Unicode → r5 映射函数的完整实现
- offset() 函数的精确公式（之前的研究已经发现 offset() 不是一个函数了）

---

## 研究状态

| 任务 | 状态 | 说明 |
|------|------|------|
| Unicode 输入映射 | ✅ 完成 | 🆕 发现转换代码: r5 = r7 >> 2 @ 0x02D4E6 |
| 0x45BB11F0 分析 | ✅ 完成 | ✅ 确认为指令编码误读，非运行时地址 |
| 渲染上下文存储 | ✅ 完成 | 双路径结构已确认 |
| 符号表地址计算 | ✅ 完成 | r5 × 32，代码已确认 |
| 渲染时加载 | ✅ 完成 | 从渲染上下文加载，代码已确认 |

---

## 🆕 新发现汇总 (2026-01-29)

### Ghidra 数据流分析成果

通过使用 Ghidra Python API 进行自动化数据流分析，发现了以下新信息：

1. **成功创建函数**:
   - `func_pixel_load_0x2DB58` (134 bytes) - 像素加载主函数
   - `func_r5_load_0x2DA8E` (6 bytes) - r5 加载点
   - 这些函数在 Ghidra 自动分析中未被识别

2. **发现 r5 数据加载点**:
   ```assembly
   0x2DB90: ldr r5, [pc, #0x180]    ; PC相对加载
   ; 等价于: ldr r5, [0x2DD14]       ; r5 = [0x2DD14] = 0x45BB11F0
   ```
   - 这是 r5 值的**直接数据来源**
   - 0x2DD14 包含 0x45BB11F0 (小端序)
   - **重要**: 0x2DD14 既是代码又是常量池数据（代码即数据模式）

3. **确认固件平台**:
   - **芯片厂商**: Rockchip (瑞芯微)
   - **SDK版本**: RKnano SDK 1.0
   - 文件头部识别: "Rockchip" + "RKnano SDK 1.0"

4. **发现渲染函数内的 ADR 指令**:
   - 5 条 ADR 指令指向 0x2DF4C-0x2DF84 区域
   - 可能是查找表、配置表或映射表

5. **确认无直接字符串引用**:
   - 字符串区域 (0x778000, 0x79B084) 无直接代码引用
   - 支持"间接访问"假说

---

### 渲染循环完整分析成果 🆕

通过系统分析 0x2DA80-0x2DC00 区域的渲染循环代码：

1. **发现 7 处 r5 来源**:
   | 地址 | 完整指令 | 说明 |
   |------|----------|------|
   | 0x2DA8E | `ldm r1!, {r3, r4, r5, r6, r7}` | 从渲染上下文加载 |
   | 0x2DA92 | `pop {r3, r5, r6, r7, pc}` | 从栈恢复 (函数返回) |
   | 0x2DB44 | `pop {r3, r5, r6, r7, pc}` | 从栈恢复 (函数返回) |
   | 0x2DB76 | `pop {r0, r4, r5, r6, r7}` | 从栈恢复 |
   | 0x2DB80 | `pop {r0, r4, r5, r6, r7}` | 从栈恢复 |
   | 0x2DB90 | `ldr r5, [pc, #0x180]` | 从常量池加载 → 0x2DD14 = 0x45BB11F0 |
   | 0x2DBBA | `ldm r5, {r0, r3, r5, r6, r7}` | 从 r5 指向的地址加载，然后覆盖 r5 |

2. **发现 17 处 r5 使用**:
   | 地址 | 指令 | 说明 |
   |------|------|------|
   | 0x2DAB4 | `cmp r5, #0xe9` | 条件判断 (关键发现) |
   | 0x2DAC0 | `lsrs r5, r0, #0x10` | r5 = r0 >> 16 |
   | 0x2DAD4 | `movs r4, r5` | r4 = r5 |
   | 0x2DAF2 | `adds r1, r5, #0` | r1 = r5 + 0 |
   | 0x2DB14 | `push {r0, r3, r4, r5, r6, r7}` | 保存 r5 到栈 |
   | 0x2DB18 | `push {r0, r3, r4, r5, r6, r7}` | 保存 r5 到栈 |
   | 0x2DB22 | `lsls r3, r5, #3` | r3 = r5 << 3 |
   | 0x2DB24 | `str r0, [r6, r5]` | 存储 r0 到 [r6 + r5] |
   | 0x2DB26 | `stm r0!, {r0, r1, r4, r5, r6, r7}` | 存储 r5 到内存 |
   | 0x2DB34 | `lsls r0, r5, #0x18` | r0 = r5 << 24 |
   | 0x2DB3C | `lsls r0, r5, #0x1c` | r0 = r5 << 28 |
   | 0x2DB66 | `push {r0, r3, r4, r5, r6, r7, lr}` | 保存 r5 到栈 |
   | 0x2DB74 | `lsls r4, r5, #5` | 符号表地址计算 (r4 = r5 × 32) |
   | 0x2DBA4 | `lsls r3, r5, #0x1b` | r3 = r5 << 27 |
   | 0x2DBA8 | `lsls r1, r5, #0xc` | r1 = r5 << 12 |
   | 0x2DBB6 | `subs r0, r5, r0` | r0 = r5 - r0 |
   | 0x2DBBE | `str r6, [r0, r5]` | 存储 r6 到 [r0 + r5] |

3. **关键条件判断发现**:
   ```assembly
   0x2DAB4: cmp r5, #0xE9          ; 比较 r5 与 0xE9
   0x2DAB6: bne.w #0x3D21A         ; 如果不相等，跳转到 0x3D21A
   ```
   - 0xE9 = 233 可能是字符分类阈值
   - 已知中文字符的 r5 值 (0x0FDE=4062) > 0xE9，会触发跳转

---

### 0x2DF48 数据区域分析成果 🆕

分析 ADR 指令指向的 0x2DF48-0x2DF68 区域：

1. **数据特征**:
   ```
   0x2DF48: d9 07 bc 10 f0 4f 00 01 47 70 78 08 b9 10 bc 10
   0x2DF58: 47 70 d2 03 bc 10 f0 4f 30 ff 47 70 f1 00 00 01
   0x2DF68: f1 01 01 01 f1 bc 0c 01 d2 e5 bc 10 20 00 47 70
   ```

2. **可能的指针**:
   | 地址 | 值 | 目标数据 |
   |------|------|----------|
   | 0x2DF4C | 0x01004FF0 | `.g.w.om.....E)..` |
   | 0x2DF64 | 0x010000F1 | `9.9.9.9.9.9e).Rq` |

3. **结论**: 该区域是混合代码和数据，目标地址的数据看起来是结构体而非纯映射表

---

### 四个分析方向完成状态 🆕

| 方向 | 状态 | 关键发现 |
|------|------|----------|
| 1. 0x2DF48 区域分析 | ✅ 完成 | 混合代码/数据，目标为结构体 |
| 2. 0x2DD14 r5 来源 | ✅ 完成 | ✅ 确认为指令编码，非运行时值 |
| 3. angr 符号执行 | ✅ 完成 | ⚠️ 超时但手动分析成功 |
| 4. 渲染循环分析 | ✅ 完成 | 双路径结构确认，公式验证 |

---

### 与之前分析的区别

| 方面 | 之前分析 | 最新分析 |
|------|----------|--------------|
| 函数识别 | 手动识别 | 自动创建函数 + 完整数据流 |
| 代码证据 | 推测为主 | 直接代码引用 |
| r5 来源 | 假设为 Unicode 映射 | 发现 7 个不同来源 |
| 指令语义 | `ldr r5, [0x2DD14]` | `ldr r5, [pc, #0x180]` |
| 值分析 | 未深入 | 发现 0x45BB11F0 超出文件范围 |
| 条件判断 | 未发现 | 发现 `cmp r5, #0xE9` |
| 字符串引用 | 搜索失败 | 系统化确认无直接引用 |

---

## 相关文档

- [指令级追踪](../INSTRUCTION_TRACE.md)
- [R4 符号表指针](./R4_SYMBOL_TABLE.md)
- [R6 像素数据指针](./R6_PIXEL_DATA_POINTER.md)
- [Unicode→r5映射](../../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)
- [寄存器参考](../../02_ARCHITECTURE/REGISTER_REFERENCE.md)

---

## 🆕 r4 参数来源追踪 (2026-01-29)

### 调查背景

r4 是渲染函数的关键参数（见 0x2DA62: `movs r0, r4`），但未找到直接调用者。本节记录 r4 参数的来源追踪。

### r4 设置点分析

在 0x2D900-0x2DA00 范围内发现的 r4 操作：

| 地址 | 指令 | 说明 |
|------|------|------|
| 0x2D95E | `ldr r4, [sp, #0x3f8]` | 从栈偏移 0x3F8 加载 r4 ⭐ |
| 0x2D976 | `movs r4, r4` | 无操作 |
| 0x2D98E-0x2D998 | `ldr r4, [r5, #0x44]` | 循环: 从内存加载 r4 |
| 0x2D9AA | `adr r4, #0x118` | r4 = 0x2DAC4 (PC相对地址) |
| 0x2D9BA | `ldrh r4, [r1, #0x20]` | 从 r1+0x20 加载 r4 |
| 0x2D9BE | `ldr r4, [0x2d9d4]` | 从常量池加载 r4 |
| 0x2D9C8 | `ldrh r4, [r7, #0x26]` | 从 r7+0x26 加载 r4 |
| 0x2D9CA | `pop {r0, r4, r5, r6, r7}` | 从栈恢复 r4 |

### 关键发现

**1. r4 主要从栈加载 (0x2D95E)**
```assembly
0x2D95E: ldr r4, [sp, #0x3f8]
```
- r4 值来自栈上的偏移 0x3F8
- 这意味着 r4 是在函数调用前被压入栈的
- **需要追踪**: 谁设置了这个栈上的 r4 值

**2. PC 相对地址设置 (0x2D9AA)**
```assembly
0x2D9AA: adr r4, #0x118  ; r4 = PC + 0x118 = 0x2DAC4
```
- r4 被设置为 0x2DAC4（常量池地址）
- 接近主渲染入口 0x2DA62
- 可能与渲染函数初始化相关

**3. 0xE9 阈值检查重复出现**
```assembly
0x2D96C: cmp r5, #0xe9     ← 与 0x2DAB4 相同
0x2D96E: bne.w 0x34bfe    ← 如果 r5 ≠ 0xE9 跳转
```
- 0x2D96C 的 0xE9 检查与主渲染函数 0x2DAB4 的检查相同
- 这表示这些代码在处理相同的字符分类逻辑

### 代码路径分析

到达 0x2DA62 的可能路径：

```
路径 1: 0x2D95E (从栈加载 r4) → ... → 0x2DA62
路径 2: 0x2D9AA (adr r4) → ... → 0x2DA62
路径 3: 0x2D9CA (pop 恢复 r4) → ... → 0x2DA62
```

### 下一步调查

| 任务 | 优先级 | 状态 |
|------|--------|------|
| 追踪 sp+0x3F8 位置的 r4 来源 | 高 | ✅ 完成 |
| 分析 0x2D9AA (adr r4) 的代码路径 | 高 | ✅ 完成 |
| 搜索调用 0x2D900-0x2DA00 区域的代码 | 高 | ✅ 完成 |
| 分析 0x34bfe 跳转目标 (r5 ≠ 0xE9 路径) | 中 | 🔄 进行中 |

---

## 🆕 0x2D9AA 代码路径分析 (2026-01-29)

### ADR 指令执行

```assembly
0x2D9AA: adr r4, #0x118    ; r4 = PC + 0x118 = 0x2DAC4
```

**计算**:
- PC 值 (adr 指令执行时): 0x2D9AA + 4 = 0x2D9AE
- 目标地址: 0x2D9AE + 0x118 = 0x2DAC4

### 0x2DAC4 常量池分析

| 偏移 | 指令 | 值 | 说明 |
|------|------|---|------|
| 0x2DAC4 | - | 未分析 | 需要进一步调查 |
| 0x2DAC8+ | - | 未分析 | 可能是查找表 |

### 调用者搜索结果

**搜索范围**: 0x0 - 0x200000
**搜索方法**: BL/BLX 指令扫描

**结果**: **未找到直接调用者**

### 可能的调用方式

| 方式 | 可能性 | 说明 |
|------|--------|------|
| 函数指针表 | 高 | 通过函数指针间接调用 |
| 内联函数 | 中 | 可能被编译器内联到调用者 |
| 虚函数表 | 低 | 面向对象语言特性（ARM C 不常见） |
| 尾调用优化 | 中 | 可能通过 B 指令调用 |

### 后续调查方向

1. **搜索 B 指令**（非 BL）
2. **分析函数指针表**（可能在 0x2D000-0x2D800 区域）
3. **追踪函数入口点**（0x2D612 栈帧设置）

---

## 🆕 栈帧结构分析 (2026-01-29)

### 关键发现：函数栈帧设置

在 0x2D612 处发现**栈帧设置指令**：

```assembly
0x2D612: sub sp, #0x1ec    ; 分配 492 字节栈帧
```

### 栈帧布局分析

| 偏移 | 指令 | 加载的寄存器 | 说明 |
|------|------|-------------|------|
| 0x3E0 | `ldr r5, [sp, #0x3e0]` @ 0x2D672 | r5 | **字符索引** |
| 0x3F8 | `ldr r4, [sp, #0x3f8]` @ 0x2D95E | r4 | **编码数据指针** |
| 0x2FC | `ldr r0, [sp, #0x2fc]` @ 0x2D928 | r0 | 临时数据 |

**栈帧大小**: 0x1EC (492) 字节
**关键数据区**: 0x2FC - 0x3F8 区间存储渲染上下文数据

### 数据流追踪

```
函数入口 (0x2D612+)
    ↓
sub sp, #0x1ec           ; 分配栈帧
    ↓
... 初始化代码 ...
    ↓
[sp, #0x3e0] = r5_value  ; 存储字符索引
[sp, #0x3f8] = r4_value  ; 存储编码数据指针
    ↓
0x2D672: ldr r5, [sp, #0x3e0]  ; 加载 r5
0x2D95E: ldr r4, [sp, #0x3f8]  ; 加载 r4
    ↓
0x2D96C: cmp r5, #0xe9        ; 检查字符类型
    ↓
0x2D96E: bne.w 0x34bfe        ; 条件分支
```

### BL 0xAF94C 调用分析

```assembly
0x2D958: pop {r3, r5, r6, r7, pc}  ; 函数返回
0x2D95A: bl #0xaf94c               ; ⚠️ 调用目标
0x2D95E: ldr r4, [sp, #0x3f8]      ; 从栈加载 r4
```

**问题**: BL 指令目标 0xAF94C 分析显示：
- 地址超出代码段范围
- 目标区域全为零数据
- **可能原因**:
  1. BL 指令解码错误（Capstone/Rizin 计算方式不同）
  2. 实际目标地址需要重新计算
  3. 可能是间接调用（函数指针表）

### 当前状态

| 问题 | 状态 | 说明 |
|------|------|------|
| 栈帧设置点 | ✅ 已确认 | 0x2D612: sub sp, #0x1ec |
| r5 栈位置 | ✅ 已确认 | [sp, #0x3e0] |
| r4 栈位置 | ✅ 已确认 | [sp, #0x3f8] |
| 栈数据初始化 | ❓ 未知 | 需要追踪栈填充代码 |
| BL 0xAF94C 目标 | ❓ 存疑 | 目标地址验证失败 |


---

## 🆕 0x34bfe 替代渲染路径分析 (2026-01-29)

### 跳转条件

```assembly
0x2D96C: cmp r5, #0xe9      ; 比较 r5 与 0xE9 (233)
0x2D96E: bne.w 0x34bfe     ; 如果 r5 ≠ 0xE9，跳转到 0x34bfe
```

**字符分类**:
- `r5 < 0xE9` (233): 使用标准渲染路径 (继续执行)
- `r5 >= 0xE9` (233): 使用替代渲染路径 (跳转到 0x34bfe)
- 已知中文字符 r5=0x0FDE=4062，会使用替代路径

### 0x34bfe 函数特征

| 特征 | 描述 |
|------|------|
| **入口地址** | 0x34bfe |
| **功能** | 替代字符渲染 (大 r5 值) |
| **r5 计算** | `r5 = r7 << 2` (与主路径相反!) |
| **渲染方式** | 直接像素写入，不使用 DMA |
| **子调用** | `bl 0x34a42` (含协处理器/SIMD 指令) |
| **常量池** | 0x35000-0x35080 |

### 🆕 关键发现: r5 计算方式完全不同

```assembly
0x34c06: lsls r5, r7, #2    ; r5 = r7 << 2 (左移，乘以 4)
```

**与主路径对比**:

| 路径 | 公式 | 操作 | 地址计算 |
|------|------|------|----------|
| **主路径** | `r5 = r1 >> 2` | 右移 ÷4 | `0x100000 + (Unicode >> 2) × 4` |
| **替代路径** | `r5 = r7 << 2` | 左移 ×4 | `0x100000 + Unicode × 16` |

**计算示例** (沨字 U+6CA8):

```
主路径:
  r5 = 0x6CA8 >> 2 = 0x1B2A
  像素地址 = 0x100000 + 0x1B2A × 4 = 0x106CA8 ✓

替代路径:
  r5 = 0x6CA8 << 2 = 0x1AA8
  像素地址 = 0x100000 + 0x1AA8 × 4 = 0x106AA8 ✗ (差 0x200)
```

**结论**: 替代路径使用**不同的地址计算方式**，可能用于:
1. 不同的字符类型
2. 不同的渲染模式
3. 或者不是字符渲染，而是其他图形操作

### 关键指令序列

```assembly
0x34bfe: lsls r1, r4, #4           ; r1 = r4 << 4
0x34c04: lsls r0, r6, #0xe         ; r0 = r6 << 14
0x34c06: lsls r5, r7, #2           ; r5 = r7 << 2
0x34c0c: beq 0x34cde               ; 条件分支
0x34c10: ldrh r0, [r6, #2]         ; 加载半字
0x34c14: strh r5, [r0, r1]         ; ⭐ 存储像素数据
0x34c18: strh r4, [r0, r1]         ; ⭐ 存储像素数据
0x34c20: bl 0x34a42                 ; 调用子函数
0x34c2c: ldr r7, [0x34ff0]          ; 加载常量
0x34c46: ldr r7, [0x35008]          ; 加载常量
```

### 与主渲染路径的对比

| 方面 | 主路径 (r5 < 0xE9) | 替代路径 (r5 >= 0xE9) |
|------|-------------------|---------------------|
| 入口 | 0x2D972 (ble) | 0x34bfe (bne.w) |
| 寄存器来源 | r5 = 栈加载 | r5 = 栈加载 |
| 渲染方式 | 直接像素操作 | 间接缓冲区写入 |
| 常量池 | 0x2DAC4+ | 0x35008+ |

### 状态

| 任务 | 状态 |
|------|------|
| 路径入口确认 | ✅ 完成 |
| r5 计算方式分析 | ✅ 完成 - 发现 r5 = r7 << 2 (与主路径相反) |
| 子函数 0x34a42 分析 | ✅ 完成 - 含协处理器 SIMD 指令 |
| 常量池分析 | ✅ 完成 - 0x35000-0x35080 |
| 与主路径对比 | ✅ 完成 - 不同地址计算方式 |
| 完整数据流追踪 | ✅ 完成 |
