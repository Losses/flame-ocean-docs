# R1 寄存器 - 渲染上下文指针

**状态**: 🆕 新文档
**创建日期**: 2026-01-29
**分析目标**: 追踪 r1 寄存器来源以找到 Unicode → r5 映射函数

---

## 寄存器用途

**r1** 在渲染代码中的主要用途：
1. **渲染上下文指针** - 指向包含字符渲染数据的内存结构
2. **数据加载源** - `0x2DA8E: ldm r1\!, {r3,r4,r5,r6,r7}` 从 r1 加载 r5

---

## 关键代码位置

### 0x2DA8E: 从 r1 加载 r5

```assembly
0x0002DA8E: ldm r1\!, {r3, r4, r5, r6, r7}
```

**操作**: 从 r1 指向的地址加载 5 个寄存器，然后 r1 递增。

**加载的数据结构**:
```
[r1 + 0] → r3
[r1 + 4] → r4
[r1 + 8] → r5  ← 字符索引\!
[r1 + 12] → r6
[r1 + 16] → r7
```

---

## r1 的来源追踪

### 分析结果

通过从 0x2DA8E 向前追踪，发现：

**r1 的最后设置位置**: `0x2DA84: lsls r1, r6, #0x19`

**计算**: r1 = r6 << 25

**问题**: 这个值非常大（左移 25 位），不太可能是有效的内存地址。

---

## 代码流程分析

### 0x2DA72-0x2DA80 循环结构

```assembly
┌───> 0x2DA72: lsls r3, r7, #3
╎    0x2DA74: lsls r1, r6, #0x19  ; r1 = r6 << 25 (循环内)
╎    0x2DA76: movs r3, r4
╎    0x2DA78: adds r2, #0x46
╎    0x2DA7A: eors r6, r0
╎    0x2DA7C: lsls r0, r6, #3
└───< 0x2DA7E: bne 0x2DA72          ; 如果不相等，跳回循环开始
     0x2DA80: b 0x2D3E8             ; 否则跳转到 0x2D3E8
```

**执行流程**:
1. 0x2DA72-0x2DA7E 是一个循环
2. 如果 bne 条件满足 → 跳回 0x2DA72
3. 如果 bne 条件不满足 → 执行 0x2DA80 跳转到 0x2D3E8
4. **0x2DA82-0x2DA8E 在正常流程中不可达**

---

## 关键发现

### 发现 1: 0x2DA82-0x2DA8E 可能是不可达代码

**原因**: 0x2DA80 是无条件跳转 `b 0x2D3E8`

**可能性**:
1. 这些字节是数据而非代码
2. 需要从其他位置直接跳转到 0x2DA82 才能执行
3. 反汇编工具错误地将数据识别为代码

### 发现 2: r1 的值来源复杂

- 在 0x2DA74 和 0x2DA84 都有 `lsls r1, r6, #0x19`
- r6 的值需要进一步追踪
- 可能需要查看调用此函数的代码

---

## 未解问题

| 问题 | 状态 | 说明 |
|------|------|------|
| r1 的真正来源 | 🔴 未解决 | 需要向上追踪调用链 |
| 0x2DA82 是否可达 | 🔴 未解决 | 需要查找跳转到此处的代码 |
| r6 的值来源 | 🔴 未解决 | r6 可能来自更早的代码 |
| 渲染上下文结构 | ⚠️ 部分理解 | 偏移 +8 是 r5 (字符索引) |

---

## 下一步方向

### 优先级 1: 查找函数调用点

- 搜索 BL/BLX 指令跳转到 0x2DA00-0x2DA90 区域
- 检查函数指针表
- 分析参数传递方式

### 优先级 2: 追踪 r6 寄存器

- r6 是 r1 的计算来源 (r1 = r6 << 25)
- 可能是关键的中介值
- 需要找到 r6 的设置点

### 优先级 3: 验证代码可达性

- 确认 0x2DA82 是否真的会被执行
- 检查是否有跳转表或动态跳转

---

## 相关文档

- [R5 字符索引](./R5_CHARACTER_INDEX.md)
- [寄存器参考](../../02_ARCHITECTURE/REGISTER_REFERENCE.md)
- [未完成工作](../../01_OVERVIEW/REMAINING_WORK.md)
