# R4 寄存器 - 符号表指针与编码判定

**状态**: ✅ 已记录
**最后更新**: 2026-01-29

---

## 寄存器用途

**r4** 主要用途：
1. **符号表指针** - 指向字符的符号表数据
2. **编码类型判定** - 通过 r4 判定 15 列 vs 14 列编码
3. **显示缓冲区基址** - 某些情况下作为显示缓冲区指针

---

## 符号表计算

### 计算公式

```assembly
0x0002DAD4:  movs   r4, r5         ; r4 = r5
0x0002DB10:  lsls   r0, r4, #4     ; r0 = r4 << 4
0x0002DB12:  cmp    r0, #0x80      ; 比较 r0 与 0x80
0x0002DB74:  lsls   r4, r5, #5     ; r4 = r5 * 32 (符号表地址)
```

**计算流程**:
```
r5 (字符内部索引)
    ↓
movs r4, r5  (r4 = r5)
    ↓
lsls r4, r5, #5  (r4 = r5 × 32)
    ↓
符号表地址 = r4 (作为基址)
```

### 符号表地址示例

| 字符 | Unicode | r5 值 | 符号表地址 (r5 × 32) |
|------|---------|-------|---------------------|
| 沨 | U+6CA8 | 0x0FDE | 0x1FBC0 |
| 沤 | U+6CA4 | 0x0FDB | 0x1FB60 |
| 沦 | U+6CA6 | 0x0FDC | 0x1FB80 |
| 沪 | U+6CAA | 0x0FDA | 0x1FB80 |

---

## 编码类型判定

### 判定机制

```assembly
0x0002DAD4:  movs   r4, r5         ; r4 = r5 (首字节 >> 4)
0x0002DB10:  lsls   r0, r4, #4     ; r0 = r4 << 4
0x0002DB12:  cmp    r0, #0x80      ; 比较 r0 与 0x80 (bit 7 测试)
0x0002DB2C:  bne    #0x2db4e       ; 条件分支
```

### 判定规则

```
r0 = (r5 >> 4) << 4 = r5 & 0xF0

如果 r0 >= 0x80 (bit 7 = 1):
  → 特殊编码 (14 列)
  → 跳转到 0x2DB4E

如果 r0 < 0x80 (bit 7 = 0):
  → 标准编码 (15 列)
  → 继续执行 0x2DB2E
```

### 两种编码路径的差异

| 特性 | 标准编码 (Bit 7=0) | 特殊编码 (Bit 7=1) |
|------|-------------------|-------------------|
| 分支目标 | 0x2DB2E (顺序执行) | 0x2DB4E (跳转) |
| 是否执行 adds r7, r7, #2 | ✅ 是 | ❌ 否 |
| 列数 | 15 | 14 |
| 字节交换 | ❌ 否 | ✅ (revsh) |

---

## 符号表数据加载

### LDSB 指令

```assembly
0x0002DB74:  lsls   r4, r5, #5     ; r4 = r5 * 32
0x0002DB78:  subs   r1, r1, #0xf   ; r1 = r1 - 15
0x0002DB94:  ldrsb  r0, [r4, r1]   ; 加载符号字节
```

**操作分析**:
1. `lsls r4, r5, #5`: 计算符号表基址 (r5 × 32)
2. `subs r1, r1, #0xf`: 调整偏移量
3. `ldrsb r0, [r4, r1]`: 从符号表加载带符号字节

### 符号表结构

**符号表结构验证** (沨字 @ 0x1FBC0):
```
偏移  值(HEX)  值(DEC)  说明
+00   0xCD     205      列 0 基准值
+01   0xDE     222      列 1 调整值
+02   0xCD     205      列 2 基准值
+03   0xDF     223      列 3 调整值
+04   0xCD     205      列 4 基准值
+05   0xE0     224      列 5 调整值
+06   0xCD     205      列 6 基准值
+07   0xE1     225      列 7 调整值
+08   0x00       0      列 8+ (空)

模式: 偶数索引 = 0xCD (固定), 奇数索引 = 递增值
```

---

## r4 值的生命周期

```
┌─────────────────────────────────────────────────────────────┐
│ 阶段 1: 渲染上下文加载 (0x2DA8E)                            │
├─────────────────────────────────────────────────────────────┤
│ ldm r1!, {r3, r4, r5, r6, r7}                               │
│ r4 从渲染上下文加载                                          │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 2: 复制 r5 到 r4 (0x2DAD4)                             │
├─────────────────────────────────────────────────────────────┤
│ movs r4, r5  (r4 = 字符内部索引)                            │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 3: 编码类型判定 (0x2DB10)                              │
├─────────────────────────────────────────────────────────────┤
│ lsls r0, r4, #4  (r0 = r4 << 4)                            │
│ cmp r0, #0x80     (测试 bit 7)                              │
│ 决定编码类型                                                 │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 4: 符号表计算 (0x2DB74)                                │
├─────────────────────────────────────────────────────────────┤
│ lsls r4, r5, #5  (r4 = r5 × 32)                            │
│ 符号表地址 = r4                                              │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 5: 符号表数据加载 (0x2DB94)                            │
├─────────────────────────────────────────────────────────────┤
│ ldrsb r0, [r4, r1]  (加载符号字节)                          │
└─────────────────────────────────────────────────────────────┘
```

---

## 未解问题

### 问题 1: 符号表数据的实际用途

**代码序列**:
```assembly
0x2DB94: ldrsb r0, [r4, r1]  ; 加载符号表值到 r0
0x2DB9A: cbnz  r1, 0x2dc1a   ; 条件分支

路径 A (r1 == 0):
  0x2DB9C: movs r0, #0xd0     ; r0 被覆盖！

路径 B (r1 != 0):
  0x2DC1A: lsls r0, r6, #0xe ; r0 被覆盖！
```

**疑问**: 符号表值被加载后立即被覆盖，实际用途是什么？

### 问题 2: 符号表作为动态存储

**代码序列**:
```assembly
0x2DBB0: str r0, [r4, #4]  ; 写入 0xD0 到 symbol_table+4
```

**疑问**: 符号表区域被用作动态存储，这是设计意图还是副作用？

### 问题 3: 显示缓冲区基址角色

在某些代码路径中，r4 被用作显示缓冲区基址：
```assembly
; 从其他分析中发现
- r4: 显示缓冲区基址
```

**疑问**: r4 的角色是固定的还是动态变化的？

---

## 研究状态

| 任务 | 状态 | 说明 |
|------|------|------|
| 符号表地址计算 | ✅ 完成 | r4 = r5 × 32 |
| 编码类型判定 | ✅ 完成 | Bit 7 测试机制 |
| 符号表结构 | ✅ 完成 | 偶数=0xCD, 奇数=递增 |
| 符号表数据用途 | ❓ 未知 | 加载后立即被覆盖 |
| 动态存储用途 | ❓ 未知 | str 指令写入符号表 |

---

## 相关文档

- [指令级追踪](../INSTRUCTION_TRACE.md)
- [R0 Bit 7 测试](./R0_BIT7_TEST.md)
- [元数据分析](../../04_DATA_DISCOVERY/METADATA_ANALYSIS.md)
- [内联渲染逻辑](../INLINE_RENDERING.md)
- [寄存器参考](../../02_ARCHITECTURE/REGISTER_REFERENCE.md)
