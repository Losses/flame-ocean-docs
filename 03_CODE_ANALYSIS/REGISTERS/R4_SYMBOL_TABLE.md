# R4 寄存器 - 符号表指针与编码判定

**状态**: ✅ 已完成
**最后更新**: 2026-01-29

---

## 寄存器用途

**r4** 主要用途：
1. **编码类型判定** - r4 = 首字节 >> 4，决定 15 列 vs 14 列编码
2. **符号表指针** - 后续计算为 r5 × 32，指向符号表数据

---

## r4 的来源与值 ✅ 已解决

### 来源追踪

```assembly
; 阶段 1: 渲染上下文加载 (0x2DA8E)
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  ; 从渲染上下文加载
         ; r5 = [r1 + 8] = 首字节 >> 4

; 阶段 2: 复制 r5 到 r4 (0x2DAD4)
0x2DAD4: movs r4, r5  ; r4 = r5 = 首字节 >> 4
```

**结论**: r4 = 首字节 >> 4（首字节的高 4 位）

---

## 编码类型判定 ✅ 已解决

### 判定指令序列

```assembly
0x2DB04: ldrsb r0, [r4, r1]    ; 从 [r4+r1] 加载有符号字节到 r0
0x2DB06: subs r2, r7, #7
0x2DB08: strh r2, [r7, #6]
0x2DB0A: revsh r1, r6
0x2DB0C: movs r7, r1
0x2DB0E: ldr r0, [r2, #0x4c]    ; 覆盖 r0
0x2DB10: lsls r0, r4, #4        ; r0 = r4 << 4
0x2DB12: cmp r0, #0x80          ; 比较 r0 与 0x80
```

**关键结论**:
- 在 0x2DB12 处，r0 = r4 << 4
- 所以 `cmp r0, #0x80` 实际上是测试 `r4 << 4 >= 0x80`
- 这等价于测试 `r4 >= 0x08`

### 判定规则 (已验证)

```
r4 = 首字节 >> 4

如果 r4 >= 8 (首字节 >= 0x80):
  → 特殊编码 (14 列)
  → 跳转到 0x2DB4E

如果 r4 < 8 (首字节 < 0x80):
  → 标准编码 (15 列)
  → 继续执行 0x2DB2E
```

---

## 证伪的假设

### ❌ 假设 1: r4 = r5

**证据**: 0x2DAD4 处有 `movs r4, r5`

**问题**: r5 的值约为 0x0FDE，远大于 0x08

**结论**: 如果 r4 = r5，所有字符都会触发特殊编码路径（不符合观察）

### ❌ 假设 2: r4 = metadata[0]

**问题**: r5 的值约为 0x0FDE，远大于 0x08。如果 r4 = r5，所有字符都会触发特殊编码路径（不符合观察）。

**修正**: r4 不是 metadata[0]，而是 metadata[0] >> 4

---

## 符号表计算

### 计算公式

```assembly
0x0002DAD4:  movs   r4, r5         ; r4 = r5
0x0002DB10:  lsls   r0, r4, #4     ; r0 = r4 << 4
0x0002DB12:  cmp    r0, #0x80      ; 比较 r0 与 0x80
0x0002DB74:  lsls   r4, r5, #5     ; r4 = r5 * 32 (符号表地址)
```

**计算流程**:
```
r5 (字符内部索引)
    ↓
movs r4, r5  (r4 = r5)
    ↓
lsls r4, r5, #5  (r4 = r5 × 32)
    ↓
符号表地址 = r4 (作为基址)
```

### 符号表地址示例

> **⚠️ 数据来源警告**: 下表中的 r5 值来自 [UNICODE_TO_R5_MAPPING.md](../../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)，该文档明确说明这些值是"从观察数据推导出来的假设"，不是从固件代码确认的事实。使用这些数据时请谨慎。

| 字符 | Unicode | r5 值 | 符号表地址 (r5 × 32) |
|------|---------|-------|---------------------|
| 沨 | U+6CA8 | 0x0FDE | 0x1FBC0 |
| 沤 | U+6CA4 | 0x0FDB | 0x1FB60 |
| 沦 | U+6CA6 | 0x0FDC | 0x1FB80 |
| 沪 | U+6CAA | 0x0FDA | 0x1FB80 |

---

## 编码类型判定

### 判定机制

```assembly
0x0002DAD4:  movs   r4, r5         ; r4 = r5 (首字节 >> 4)
0x0002DB10:  lsls   r0, r4, #4     ; r0 = r4 << 4
0x0002DB12:  cmp    r0, #0x80      ; 比较 r0 与 0x80 (bit 7 测试)
0x0002DB2C:  bne    #0x2db4e       ; 条件分支
```

### 判定规则

```
r0 = (r5 >> 4) << 4 = r5 & 0xF0

如果 r0 >= 0x80 (bit 7 = 1):
  → 特殊编码 (14 列)
  → 跳转到 0x2DB4E

如果 r0 < 0x80 (bit 7 = 0):
  → 标准编码 (15 列)
  → 继续执行 0x2DB2E
```

### 两种编码路径的差异

| 特性 | 标准编码 (Bit 7=0) | 特殊编码 (Bit 7=1) |
|------|-------------------|-------------------|
| 分支目标 | 0x2DB2E (顺序执行) | 0x2DB4E (跳转) |
| 是否执行 adds r7, r7, #2 | ✅ 是 | ❌ 否 |
| 列数 | 15 | 14 |
| 字节交换 | ❌ 否 | ✅ (revsh) |

---

## 符号表数据加载

### LDSB 指令

```assembly
0x0002DB74:  lsls   r4, r5, #5     ; r4 = r5 * 32
0x0002DB78:  subs   r1, r1, #0xf   ; r1 = r1 - 15
0x0002DB94:  ldrsb  r0, [r4, r1]   ; 加载符号字节
```

**操作分析**:
1. `lsls r4, r5, #5`: 计算符号表基址 (r5 × 32)
2. `subs r1, r1, #0xf`: 调整偏移量
3. `ldrsb r0, [r4, r1]`: 从符号表加载带符号字节

### 符号表结构

**符号表结构验证** (沨字 @ 0x1FBC0):
```
偏移  值(HEX)  值(DEC)  说明
+00   0xCD     205      列 0 基准值
+01   0xDE     222      列 1 调整值
+02   0xCD     205      列 2 基准值
+03   0xDF     223      列 3 调整值
+04   0xCD     205      列 4 基准值
+05   0xE0     224      列 5 调整值
+06   0xCD     205      列 6 基准值
+07   0xE1     225      列 7 调整值
+08   0x00       0      列 8+ (空)

模式: 偶数索引 = 0xCD (固定), 奇数索引 = 递增值
```

---

## r4 值的生命周期

```
┌─────────────────────────────────────────────────────────────┐
│ 阶段 1: 渲染上下文加载 (0x2DA8E)                            │
├─────────────────────────────────────────────────────────────┤
│ ldm r1!, {r3, r4, r5, r6, r7}                               │
│ r4 从渲染上下文加载                                          │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 2: 复制 r5 到 r4 (0x2DAD4)                             │
├─────────────────────────────────────────────────────────────┤
│ movs r4, r5  (r4 = 字符内部索引)                            │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 3: 编码类型判定 (0x2DB10)                              │
├─────────────────────────────────────────────────────────────┤
│ lsls r0, r4, #4  (r0 = r4 << 4)                            │
│ cmp r0, #0x80     (测试 bit 7)                              │
│ 决定编码类型                                                 │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 4: 符号表计算 (0x2DB74)                                │
├─────────────────────────────────────────────────────────────┤
│ lsls r4, r5, #5  (r4 = r5 × 32)                            │
│ 符号表地址 = r4                                              │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 5: 符号表数据加载 (0x2DB94)                            │
├─────────────────────────────────────────────────────────────┤
│ ldrsb r0, [r4, r1]  (加载符号字节)                          │
└─────────────────────────────────────────────────────────────┘
```

---

## 未解问题

符号表相关的详细问题已汇总到 **[执行摘要](../01_OVERVIEW/EXECUTIVE_SUMMARY.md)** 阶段 3.2。

**关键发现**:
- ldrsb 加载的值在两条路径中都被立即覆盖
- **最可能用途**: 设置 CPU 标志位 (N 标志)，而非使用加载的值本身

**关键问题**:
- 符号表作为动态存储的用途 (`str r0, [r4, #4]`)
- 为什么某些字符有有效符号表数据，其他字符是全零？

---

## 研究状态

| 任务 | 状态 | 说明 |
|------|------|------|
| r4 的来源 | ✅ 完成 | r4 = 首字节 >> 4 |
| 编码类型判定 | ✅ 完成 | r4 >= 8 → 特殊，r4 < 8 → 标准 |
| 符号表地址计算 | ✅ 完成 | r4 = r5 × 32 |
| 符号表结构 | ✅ 完成 | 偶数=0xCD, 奇数=递增 |
| 符号表数据用途 | ⚠️ 部分 | 主要用于设置 CPU 标志位 |
| 动态存储用途 | ❓ 未知 | str 指令写入符号表 |

---

## 调查历史

本文档整合了 `R4_REGISTER_INVESTIGATION.md` (2026-01-28) 的调查结果。

### 已解决的问题

| 问题 | 状态 | 解决方案 |
|------|------|----------|
| r4 的真正来源 | ✅ 已解决 | r4 = 首字节 >> 4 |
| 编码类型决策的完整逻辑 | ✅ 已解决 | 通过 r4 >= 8 判定 |
| 渲染上下文的结构 | ✅ 已发现 | Offset +8 处为 r5 |

### 证伪的假设

| 假设 | 状态 | 说明 |
|------|------|------|
| r4 = r5 (会导致所有字符都触发特殊编码) | ❌ 证伪 | r4 = 首字节 >> 4，而非完整的 r5 |
| r4 = metadata[0] (测试结果不完全匹配) | ❌ 修正 | r4 = metadata[0] >> 4 |

### 剩余问题

| 问题 | 优先级 | 状态 |
|------|--------|------|
| 0x2DB04 处 r1 作为偏移的含义 | 🟡 中 | ❓ 待分析 |
| 符号表作为动态存储的用途 | 🟡 中 | ❓ 待分析 |

---

## 相关文档

- [指令级追踪](../INSTRUCTION_TRACE.md)
- [R0 Bit 7 测试](./R0_BIT7_TEST.md)
- [元数据分析](../../04_DATA_DISCOVERY/METADATA_ANALYSIS.md)
- [内联渲染逻辑](../INLINE_RENDERING.md)
- [寄存器参考](../../02_ARCHITECTURE/REGISTER_REFERENCE.md)
