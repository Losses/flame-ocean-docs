# R0 寄存器 - Bit 7 测试与临时数据

**状态**: ✅ 已记录
**最后更新**: 2026-01-29

---

## 寄存器用途

**r0** 是一个临时寄存器，主要用于：
1. **Bit 7 测试** - 判定字符编码类型
2. **数据加载** - 加载像素数据和符号字节
3. **临时计算** - 各种中间计算结果

---

## Bit 7 测试机制

### 测试位置 1: 0x2DAC8 (主要测试)

```assembly
初始化阶段 (0x2DA94-0x2DAC6):
  0x2DA94: eor r0, r7, #0x28          r0 = r7 ^ 0x28
  0x2DABA: lsrs r6, r0, #0x19         r6 = r0 >> 25
  0x2DABC: lsls r0, r0, #4            r0 = r0 << 4
  0x2DAC0: lsrs r5, r0, #0x10         r5 = r0 >> 16
  0x2DAC2: asrs r6, r0, #0x1d         r6 = r0 >> 29
  0x2DAC6: movs r2, r0                r2 = r0 (用于 bit 7 测试)

Bit 7 测试 (0x2DAC8):
  0x2DAC8: cmp r2, #0x80              如果 r2 >= 0x80 (bit 7 = 1)...
```

**逻辑流程**:
```
如果 r2 >= 0x80 (Bit 7 = 1):
  → Z=0, bne 跳转到 0x2DB4E
  → 特殊编码路径

如果 r2 < 0x80 (Bit 7 = 0):
  → Z=1, bne 不跳转
  → 标准编码路径
```

### 测试位置 2: 0x2DB12 (次要测试)

```assembly
0x0002DB04:  ldrsb  r0, [r4, r1]   ; Load signed byte (sign extension!)
0x0002DB08:  strh   r2, [r7, #6]
0x0002DB10:  lsls   r0, r4, #4     ; r0 = r4 << 4
0x0002DB12:  cmp    r0, #0x80      ; CMP #128 (bit 7 test!)
0x0002DB2C:  bne    #0x2db4e       ; Branch if not equal
```

**测试公式**:
```
r0 = r4 << 4
r0 >= 0x80 ? 特殊编码 : 标准编码
```

---

## 数据加载用途

### 像素数据加载 (0x13365E 函数)

```assembly
0x0013365A:  ldrsb  r0, [r7, r3]   ; Load signed byte (sign extension)
0x0013365C:  lsls  r3, r3, #0x10  ; 16-bit shift (row counter!)
0x0013365E:  ldrh  r0, [r7, r3]   ; Load half-word (pixel data!)
```

### 符号字节加载 (渲染循环)

```assembly
0x0002DB94:  ldrsb  r0, [r4, r1]     ; 加载符号字节
0x0002DB96:  subs   r2, r7, 7
0x0002DB98:  strh   r3, [r7, 6]       ; 存储结果
```

---

## r0 生命周期追踪

```
┌─────────────────────────────────────────────────────────────┐
│ 阶段 1: 初始化 (0x2DA94)                                    │
├─────────────────────────────────────────────────────────────┤
│ r0 = r7 ^ 0x28                                               │
│ r0 = r0 << 4                                                │
│ r5 = r0 >> 16                                               │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 2: Bit 7 测试 (0x2DAC8)                                │
├─────────────────────────────────────────────────────────────┤
│ r2 = r0                                                      │
│ cmp r2, #0x80                                               │
│ 决定编码类型                                                 │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 3: 像素数据加载 (0x13365E)                              │
├─────────────────────────────────────────────────────────────┤
│ ldrsb r0, [r7, r3]   ; 加载符号扩展字节                      │
│ ldrh r0, [r7, r3]    ; 加载 16 位像素数据                    │
└─────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 4: 渲染循环 (0x2DB94)                                   │
├─────────────────────────────────────────────────────────────┤
│ ldrsb r0, [r4, r1]   ; 加载符号表字节                        │
│ ... 但立即被覆盖                                            │
└─────────────────────────────────────────────────────────────┘
```

---

## 未解问题

r0 寄存器的详细问题已汇总到 **[REMAINING_WORK.md](../../01_OVERVIEW/REMAINING_WORK.md)** 阶段 4.3。

**关键问题**:
- ldrsb 加载的值为何被立即覆盖？
- 初始化阶段的计算目的（eor/lsrs/lsls 组合）
- 符号扩展加载的实际用途

---

## 研究状态

| 任务 | 状态 | 说明 |
|------|------|------|
| Bit 7 测试机制 | ✅ 完成 | 已确认测试位置和逻辑 |
| 像素数据加载 | ✅ 完成 | 已确认加载指令 |
| 符号字节加载用途 | ❓ 未知 | 加载后立即被覆盖 |
| 初始化计算目的 | ❓ 未知 | eor/lsrs/lsls 组合的意义 |

---

## 相关文档

- [指令级追踪](../INSTRUCTION_TRACE.md)
- [R4 符号表计算](./R4_SYMBOL_TABLE.md)
- [寄存器参考](../../02_ARCHITECTURE/REGISTER_REFERENCE.md)
