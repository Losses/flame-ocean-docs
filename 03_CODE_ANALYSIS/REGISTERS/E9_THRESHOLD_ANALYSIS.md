# 0xE9 阈值分析 - 字符分类边界

**状态**: ✅ 分析完成
**创建日期**: 2026-01-29
**分析目标**: 理解 `cmp r5, #0xE9` 的两个分支含义

---

## 关键代码位置

```assembly
0x0002DAB4: cmp    r5, #0xe9          ; 比较 r5 与 0xE9
0x0002DAB6: bne.w  #0x3d21a         ; 如果 r5 ≠ 0xE9，跳转到分支1
; 继续执行 = 分支2 (r5 = 0xE9 的情况)
```

---

## 两个分支的代码路径

### 分支1: r5 ≠ 0xE9 (扩展字符路径)

**跳转目标**: 0x3D21A

**代码特征**:
```assembly
0x3D21A: movs r4, #0           ; r4 = 0
0x3D21C: movs r1, r4           ; r1 = 0
0x3D21E: movs r0, r5           ; r0 = r5 (使用 r5 的值)
0x3D222: adds r5, #0xf8       ; r5 = r5 + 0xF8
0x3D22C: ldrh r2, [r6, #0xc]  ; 从 r6+0xC 加载半字
0x3D22E: ldrh r2, [r0, #2]   ; 从 r0+2 加载半字
```

**关键操作**:
1. **直接使用 r5 的值** - `movs r0, r5`
2. **r5 偏移调整** - `adds r5, #0xF8`
3. **从计算地址加载** - `ldrh r2, [r0, #2]`

**用途**: 处理 r5 ≥ 0xE9 的字符（扩展字符、特殊字符）

---

### 分支2: r5 = 0xE9 (ASCII/基本字符路径)

**继续执行**: 0x2DABA

**代码特征**:
```assembly
0x2DABA: lsrs   r6, r0, #0x19    ; r6 = r0 >> 25
0x2DABC: lsls   r0, r0, #4       ; r0 = r0 << 4
0x2DABE: ble    #0x2da94        ; 如果 ≤ 0，跳到 0x2DA94
0x2DAC0: lsrs   r5, r0, #0x10    ; r5 = r0 >> 16
0x2DAC2: asrs   r6, r0, #0x1d   ; r6 = r0 >> 29
0x2DAD2: ldr    r4, [r1, #4]    ; r4 = [r1 + 4]
0x2DAD4: movs   r4, r5           ; r4 = r5
0x2DAD6: ldrb   r0, [r2, #0x13] ; 从 r2+0x13 加载字节
0x2DAD8: str    r0, [r1, #0x18]  ; 存储到 [r1 + 0x18]
0x2DADA: adds   r0, r0, r6       ; r0 = r0 + r6
0x2DAE8: lsls   r1, r4, #5       ; r1 = r4 × 32
0x2DAF2: adds   r1, r5, #0       ; r1 = r1 + r5
0x2DB04: ldrsb  r0, [r4, r1]   ; 从 [r4 + r1] 加载字节
```

**关键操作**:
1. **从 r0 提取 r5** - `lsrs r5, r0, #0x10` (r5 = r0 >> 16)
2. **从渲染上下文加载 r4** - `ldr r4, [r1, #4]`
3. **符号表计算** - `lsls r1, r4, #5` (r1 = r4 × 32)
4. **查表操作** - `ldrsb r0, [r4, r1]` (从表读取)

**用途**: 处理 r5 = 0xE9 的特殊字符或默认路径

---

## 0xE9 的含义分析

### 数值分析

| 属性 | 值 |
|------|------|
| 十六进制 | 0xE9 |
| 十进制 | 233 |
| 二进制 | 1110 1001 |
| Unicode | U+00E9 = 'é' (拉丁小写带锐音符 e) |

### 可能的解释

1. **相关问题SCII/扩展字符分界点**
   - 0xE9 = 233 可能是区分 ASCII 和扩展字符的阈值
   - r5 < 0xE9: 可能是 ASCII 字符或基本拉丁字符
   - r5 ≥ 0xE9: 可能是扩展字符、符号或特殊字符

2. **字符表大小**
   - 0xE9 可能表示某个字符表的大小或索引范围

3. **特殊字符标记**
   - U+00E9 是 'é'，可能表示 Latin-1 扩展字符的开始
   - 0xE9 本身可能有特殊含义（如默认/错误值）

---

## 代码模式对比

| 方面 | 分支1 (r5 ≠ 0xE9) | 分支2 (r5 = 0xE9) |
|------|------------------|------------------|
| r5 使用 | 直接使用 r5 值 | 从 r0 提取 r5 |
| 地址计算 | r5 + 0xF8 | 符号表计算 (r4 × 32) |
| 数据访问 | 直接计算地址 | 查表 (ldrsb) |
| 复杂度 | 相对简单 | 相对复杂 |

---

## 关键发现

1. **两个分支使用完全不同的处理逻辑**
   - 分支1: 直接使用 r5 作为索引/偏移
   - 分支2: 从 r0 提取 r5，然后查表

2. **分支2 的 r5 来源**
   - `0x2DAC0: lsrs r5, r0, #0x10` → r5 = r0 >> 16
   - 这意味着 r5 是从 r0 的高 16 位提取的

3. **分支2 的符号表计算**
   - `0x2DAE8: lsls r1, r4, #5` → r1 = r4 × 32
   - `0x2DAF2: adds r1, r5, #0` → r1 = r1 + r5
   - 这是已知的符号表地址计算公式！

---

## 未解问题

| 问题 | 状态 | 说明 |
|------|------|------|
| r0 的来源 | ✅ 已解决 | r0 = r7 XOR 0x28 (见 [R0_BRANCH2_SOURCE](./R0_BRANCH2_SOURCE.md)) |
| r7 参数的来源 | 🔴 未解决 | 需要查找调用此函数的代码 |
| 分支1 的 r6 来源 | 🔴 未解决 | 0x3D22C 使用 r6+0xC |
| 0xE9 的确切含义 | ⚠️ 部分理解 | 可能是字符分类阈值 |
| 何时执行哪个分支 | ⚠️ 部分理解 | 取决于 r5 的值 |

---

## 🆕 r0 来源分析 (2026-01-29)

### 发现

通过追踪代码流程，发现 r0 在分支2 的来源：

```assembly
0x2DA94: eor r0, r7, #0x28    ; r0 = r7 XOR 0x28
0x2DABA: lsrs r6, r0, #0x19   ; 使用 r0
0x2DABC: lsls r0, r0, #4      ; r0 = r0 << 4
0x2DAC0: lsrs r5, r0, #0x10   ; r5 = r0 >> 16 (从r0提取)
```

### 结论

- **r0 来自函数参数 r7**
- r7 包含编码后的字符数据
- r5 从 r0 的高16位提取
- 0x28 可能是解密密钥或偏移值

详细分析参见: [R0_BRANCH2_SOURCE.md](./R0_BRANCH2_SOURCE.md)

---

## 下一步方向

### 优先级 1: 查找函数调用者
搜索 BL/BLX 指令跳转到：
- 0x2DA62 (主入口)
- 0x2DA6C, 0x2DA76, 0x2DA88, 0x2DA92 (替代入口)

这将帮助我们找到 Unicode → r7 的转换函数。

### 优先级 2: 分析 0x2DA94 (分支2的子分支)
- `0x2DABE: ble 0x2DA94`
- 理解这个子分支的逻辑

### 优先级 3: 分析符号表结构
- 分支2 包含符号表计算: `lsls r1, r4, #5`
- 查表操作: `ldrsb r0, [r4, r1]`

---

## 相关文档

- [R5 字符索引](./R5_CHARACTER_INDEX.md)
- [R6 像素数据指针](./R6_PIXEL_DATA_POINTER.md)
- [渲染循环分析](./R1_RENDER_CONTEXT_POINTER.md)
- [未解决问题](../01_OVERVIEW/EXECUTIVE_SUMMARY.md)
