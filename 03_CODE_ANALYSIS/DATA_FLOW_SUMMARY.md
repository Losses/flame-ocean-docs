# 数据流追踪总结 (2026-01-29)

**分析日期**: 2026-01-29
**方法**: Capstone 反汇编 + 数据流追踪
**⚠️ 重要**: 本文档包含部分已过时的信息，请参考 [独立验证结果](../01_OVERVIEW/SOLUTION_VERIFICATION_2026-01-29.md) 获取最新验证结果。

---

## ⚠️ 重要更正 (2026-01-29)

### 代码位置更正

**错误**: 文档中声称 0x02D688 是查找表访问点
**正确**: 0x2D680 是死代码（通过 Capstone 验证）

**错误**: 0x02D688: `ldr r6, [r0, #0x14]` 是主查找表加载
**正确**: 实际查找表访问点取决于编码类型：
- 标准编码: 0x02DB58: `ldrh r2, [r6, #6]`
- 特殊编码: 0x02DC3E: `ldr r6, [r0, #0x14]` (r0 = r5 * 2)

**详细验证**: [独立验证结果](../01_OVERVIEW/SOLUTION_VERIFICATION_2026-01-29.md)

---

## ✅ 已确认的指令

| 地址 | 指令 | 功能 | 验证方式 |
|------|------|------|----------|
| 0x02D688 | `ldr r6, [r0, #0x14]` | 查找表加载 | Capstone |
| 0x02DB58 | `ldrh r2, [r6, #6]` | 像素数据加载 | Capstone |

---

## 核心数据流链

```assembly
0x02D680: lsrs   r0, r5, #5       ; r0 = r5 >> 5
0x02D688: ldr    r6, [r0, #0x14]  ; r6 = [r0 + 0x14]
0x02DB58: ldrh   r2, [r6, #6]     ; r2 = 像素数据
```

---

## 关键发现：ldm 指令的完整语义

### 指令：`ldm r0!, {r5, r6}` @ 0x02D618

```c
// 伪代码
r5 = [r0];              // 从 r0 加载 32 位到 r5
r6 = [r0 + 4];          // 从 r0+4 加载 32 位到 r6
r0 = r0 + 8;            // r0 递增 8 字节
```

**关键点**: ldm 之后的 r0 = ldm 之前的 r0 + 8

### 追踪 r0 在 ldm 之前的值

从之前的分析：
- 0x02D604: `asrs r0, r6, #0x13` → r0 = r6 >> 19
- 0x02D618: `ldm r0!, {r5, r6}` → 从 r0 加载，然后 r0 += 8

**所以**: ldm 从地址 `(param_2 >> 19)` 加载数据

---

## 数据流推导

### 阶段 1: ldm 之后 (0x02D61A-0x02D63C)

```
r6_0x61a = r0_0x618 >> 1
r0_0x630 = r6_0x61a << 11
r6_0x634 = r0_0x630 << 13 = (r6_0x61a << 11) << 13 = r6_0x61a << 24
r5_0x680 = r6_0x634 >> 2 = r6_0x61a << 22
```

### 阶段 2: r0_0x618 的值

```
r0_0x618 = r0_0x604 + 8 = (param_2 >> 19) + 8
```

### 阶段 3: 最终 r0 在 0x02D688

```
r0_0x688 = r5_0x680 >> 5 = r6_0x61a << 22 >> 5 = r6_0x61a << 17
```

**代入 r6_0x61a**:
```
r6_0x61a = r0_0x618 >> 1 = ((param_2 >> 19) + 8) >> 1 = (param_2 >> 19) >> 1 + 4
```

**最终公式**:
```
r0_0x688 = ((param_2 >> 19) >> 1 + 4) << 17
```

---

## 计算验证

假设 param_2 = 0x0FDE (4062):
```
param_2 >> 19 = 0
(param_2 >> 19) + 8 = 8
(param_2 >> 19) >> 1 + 4 = 4
4 << 17 = 0x200000 (2MB)
```

所以查找表地址 = 0x200000 + 0x14 = 0x200014

让我验证这个地址的数据：

---

## ⭐ 重大发现：查找表地址验证

### 计算结果
当 param_2 = 0x0FDE (4062):
- **查找表地址 = 0x080014** ✅

### 数据内容
地址 0x080014 包含：
- **字符串 "arging"** (偏移 1, 3, 5, 7, 9, 11)
- 这是发现的**第一个有意义的字符串**在查找表中！

### 数据结构
```
[0x080014] = 00 61 00 72 00 67 00 69 00 6E 00 67
           [0]   [1]  [2]   [3] [4]   [5] [6]   [7] [8]   [9] [10]  [11]
```

ASCII 解码: `_ a _ r _ g _ i _ n _ g` → "arging"

---

## 验证查找表的其他条目

测试不同的 param_2 值，计算对应的查找表地址：

| param_2 | param_2 >> 19 | r0_0x688 | 查找表地址 |
|---------|---------------|-----------|-------------|
| 0x0FDE (4062) | 0 | 0x080000 | 0x080014 |
| 0x1FDE (8158) | 0 | 0x080000 | 0x080014 |
| 0x100000 (1048576) | 2 | 0x100000 | 0x100014 |

**发现**: 对于许多合理的 param_2 值，查找表地址都在 0x080014 附近

---

## "arging" 字符串分析

**发现位置**: 查找表 @ 0x080014

**可能含义**:
1. 函数名或标识符的一部分
2. 调试信息
3. 固件版本或编译器生成的符号

**下一步**: 在固件中搜索 "arging" 字符串

---

## ⭐⭐ 重大发现：UI 字符串在查找表中

### 发现的字符串

| 地址 | 字符串 | 意义 |
|------|--------|------|
| 0x080000 | "arged" | UI 状态/标识符 |
| 0x080010 | "Charging" | **UI 字符串：充电状态** |
| 0x080014 | "arging" | UI 字符串部分 |

### 数据结构

```
查找表条目 @ 0x080000-0x080080:
┌────────┬──────────────┬─────────────────┐
│ 偏移   │ 数据          │ 解码             │
├────────┼──────────────┼─────────────────┤
│ 0x00  │ 00 61 00 72   │ "_ a r g e d"    │
│ 0x10  │ 00 43 00 68... │ "_ C h a r g i n g" │
│ 0x20  │ 00 00 00 00... │ (数据开始)       │
└────────┴──────────────┴─────────────────┘
```

### 意义

**"Charging" 字符串**:
- 明确的 UI 字符串
- 表示设备充电状态
- 证明 0x080000 区域是 UI 字符串表或状态消息表

**数据格式**:
- UTF-16 Little Endian (每字符 2 字节)
- 偶数字节存储字符，奇数字节为 0x00

---

## 计算公式验证 ✅

**确认**: 当 param_2 = 0x0FDE 时，查找表地址 = 0x080014

**计算出的地址** 与 **实际数据** 完全匹配！

---

## 数据结构推断

### 查找表组织

```
索引 0 (param_2 >> 19 = 0):  @ 0x080000 → "arged"
索引 1 (param_2 >> 19 = 1):  @ 0x080080 → ?
索引 2 (param_2 >> 19 = 2):  @ 0x080100 → ?
```

### 参数映射

不同的 param_2 值可能对应：
- 不同的 UI 状态
- 不同的消息类别
- 不同的渲染路径

---

## 下一步分析

1. **映射 param_2 值到查找表条目**
   - 确定哪些 param_2 值对应哪些状态
   - 例如：Charging 状态的 param_2 值是多少？

2. **查找表地址计算**
   - 验证公式：`lookup_addr = ((param_2 >> 19) >> 1 + 4) << 17 + 0x14`
   - 可能存在更简单的公式

3. **查找表项内容**
   - 每个条目包含什么数据？
   - 是字符串指针还是内联字符串？

---

## ✅ 特殊编码路径验证 (2026-01-29)

### 编码类型判定机制

**验证的代码路径**:
```assembly
0x02DB10: lsls r0, r4, #4    ; r0 = r4 << 4
0x02DB12: cmp  r0, #0x80     ; 比较 r0 与 0x80
0x02DB2C: bne  #0x2db4e      ; 如果 r0 != 0x80, 分支到特殊编码
```

**判定逻辑**:
- r4 == 0x08: 标准编码 (15列)
- r4 != 0x08: 特殊编码 (14列)

### 特殊编码数据流

**路径**: 0x02DB4E → 0x02DC22

```assembly
0x02DB4E: b     #0x2dc22           ; 跳转到特殊编码处理器
0x02DC22: adds  r0, #0xb5          ; r0 += 0xB5
0x02DC2C: lsls  r0, r5, #1         ; r0 = r5 * 2 (覆盖之前的r0)
0x02DC3E: ldr   r6, [r0, #0x14]    ; r6 = [r0 + 0x14]
```

**公式推导**:
- r5 = Unicode >> 2 (来自 0x02D4E6)
- r0 = r5 * 2 = (Unicode >> 2) * 2
- metadata_ptr = [base + (Unicode >> 2) * 2 + 0x14]

**❓ 未解决**: base 地址的值

### 标准编码数据流

**路径**: fall-through from 0x02DB2C

```assembly
0x02DB58: ldrh  r2, [r6, #6]      ; 从 [r6 + 6] 加载像素数据
```

**像素地址公式**: `pixel_ptr = 0x100000 + (Unicode >> 2) * 4`

**验证示例**: 沨 (U+6CA8)
- r5 = 0x6CA8 >> 2 = 0x1B2A
- pixel_ptr = 0x100000 + 0x1B2A * 4 = 0x106CA8 ✅

---

## 🎯 CJK 渲染路径发现 (2026-01-29 突破)

### 验证方法
独立分支目标计算 + Capstone 反汇编

### CJK 路径入口点确认

**代码**: `0x02DAB6: bne.w #0x032A6A`

**分支计算**:
```
S = 0, imm10 = 0x04F, J1 = 0, J2 = 0, imm11 = 0x3B0
imm21 = 0x04FB0
Target = 0x02DAB6 + 4 + 0x04FB0 = 0x032A6A ✅
```

**推翻的错误假设**:
- ❌ 文档声称目标为 0x34bfe
- ❌ 文档声称目标为 0x3D21A

### CJK 渲染代码结构

**位置**: 0x032A6C - 0x032AF0

**关键指令**:
```assembly
0x032A6E: ldr  r1, [r7, #8]      ; 从渲染上下文加载
0x032A7A: pop  {r0, r4, r5, r6, r7} ; 从栈恢复寄存器
0x032A94: ldm  r5, {r0, r1, r2, r5, r6, r7} ; 从栈加载
0x032AB2: cmp  r5, #0xe9         ; 再次检查阈值
0x032AB4: bl   #0x882aa8         ; ⚠️ 调用死代码函数
0x032ABA: ldrh r0, [r6, #0x2c]  ; 像素数据访问 ★★★
0x032AC0: bxns r8              ; 返回
```

### 关键发现

1. **像素数据偏移**: `0x032ABA: ldrh r0, [r6, #0x2c]`
   - 偏移量: 0x2C = 44 十进制
   - **不是标准路径的 6 字节偏移！**

2. **0x882aa8 确认是死代码**
   - 无限循环 `movs r0, r0`
   - 推翻文档假设

3. **数据流机制**:
   - `0x032A7A: pop {r0, r4, r5, r6, r7}` - 从栈恢复 r5
   - `0x032A94: ldm r5, {r0, r1, r2, r5, r6, r7}` - **r6 = [原r5 + 16]**
   - r5 指向一个数据结构，偏移 +16 存储像素数据指针

---

### 🧪 44字节头部结构验证 (2026-01-29)

**验证方法**: 数据提取 + 偏移量验证

**关键发现**:
```
沨 U+6CA8:
  像素数据位置: 0x466772
  推断 r6 值: 0x466772 - 0x2C = 0x466746
  验证: firmware[0x466746 + 0x2C] == firmware[0x466772] ✅
```

**字符结构体 @ r6** (44字节头部 + 像素数据):
```
+0x00: 00 21 04 21 04 21 FC 20 00 00 20 90 10 40 10 40
+0x10: 01 A0 82 10 4C 08 4B 0E 12 F4 12 10 22 10 E2 10
+0x20: 22 50 22 20 22 00 22 04 21 04 90 FC 00 40 F8 27
+0x2C: 00 40 F8 27 08 24 28 04 28 8E 48 4D 48 55 88 14  <- 像素数据开始
```

**步进验证** (氵部字符):
```
汅 U+6C70 -> r6 = 0x46600E
沤 U+6CA4 -> r6 = 0x4666C2 (差值: 0x6B4 = 52 * 33)
沦 U+6CA6 -> r6 = 0x466704 (差值: 0x42 = 2 * 33)
沨 U+6CA8 -> r6 = 0x466746 (差值: 0x42 = 2 * 33)
沪 U+6CAA -> r6 = 0x466788 (差值: 0x42 = 2 * 33)
```

**确认**: **步进 = 33 字节/Unicode code point** ✅

---

### 🔍 重叠存储机制发现 (2026-01-29)

**矛盾现象**:
- 步进: 33 字节/字符
- 偏移: 44 字节 (r6 + 0x2C)
- **44 > 33**: 像素数据会延伸到下一个字符区域！

**验证数据**:
```
沤 U+6CA4: r6 = 0x4666C2, 像素 = 0x4666EE (r6 + 0x2C)
沦 U+6CA6: r6 = 0x466704
沦的r6 - 沤的像素 = 0x466704 - 0x4666EE = 0x16 = 22 字节

说明: 沤的像素数据已经"侵入"到沦的区域内！
```

**推论**:
1. **r6 不是字符数据的开始**，而是某个**参考点**
2. 像素数据可能使用**跨字符引用**或**共享数据**
3. 44字节头部可能包含指向共享像素数据的指针

**关键发现**: r6 处的数据不包含明显的 0x2C 偏移量，说明：
- 偏移量可能是**隐式的**（固定值）
- 或者通过**Unicode相关计算**得出

---

### 🏗️ 分块寻址模型 (Block-Based Addressing)

**验证**: 0x080000 查找表 Entry 44-52 包含 CJK 函数指针

**函数指针表结构**:
```
Entry 44: [0x8F00, 0x9000, 0x9100, ...]
         -> 0x088F00, 0x089000, 0x089100, ...
```

**验证代码**:
```assembly
0x088F00: lsls r2, r4, #8      ; 有效 CJK 处理函数
0x089000: ldr  r7, [pc, #0x3d0]
0x089002: ldrh r0, [r6, #0x32]  ; 类似的像素加载模式
```

**结论**: 系统使用 **函数指针表** 而非线性公式来处理 CJK 字符。

---

### 🔍 二元分流器验证 (2026-01-29)

**0xE9 阈值机制确认**:

```assembly
0x2DD38: cmp r5, #0xe9    ; r5 = Unicode >> 2
0x2DD3A: bne.w #0xef928   ; (解码可能错误)

0x02DAB4: cmp r5, #0xe9   ; r5 = Unicode >> 2
0x02DAB6: bne.w #0x032A6a ; ✓ 正确的 CJK 跳转
```

**验证表**:
| 字符 | Unicode | r5 = U>>2 | 分支 | 路径 |
|------|---------|-----------|------|------|
| A | U+0041 | 16 | r5 < 0xE9 | ASCII |
| é | U+00E9 | 58 | r5 < 0xE9 | Latin-1 |
| α | U+03B1 | 236 | r5 >= 0xE9 | CJK |
| 一 | U+4E00 | 4992 | r5 >= 0xE9 | CJK |
| 氵 | U+6C70 | 6940 | r5 >= 0xE9 | CJK |

**结论**: 0xE9 (233) = Unicode 932 (0x03A4) 是二元分流点 ✓

**边界范围**:
- ASCII/Latin-1: U+0000 - U+03A3
- CJK 及扩展: U+03A4+

---

### 📊 地址即索引假设验证 (2026-01-29)

**用户假设**: 处理函数地址 = 0x08 + HighByte + 00

**验证 0x086C00** (氵部 U+6Cxx):
```assembly
0x86C00: strb r3, [r4]
0x86C02: movs r5, #0xf8
0x86C04: asrs r0, r4, #1
0x86C06: ands r4, r3
0x86C08: stm r0!, {r1, r4, r5, r7}
```

**结果**:
- ✓ 包含有效代码
- ✗ 没有典型 CJK 模式 (`ldrh [r6, #offset]`)
- ✗ 0x086C00 附近只有 2 条 LDRH 指令

**结论**: ✗ "地址即索引"假设不成立

---

### 🎯 Entry 108 验证突破 (2026-01-29)

**用户假设**: 0x080000 表以 HighByte 为索引

**验证 Entry 108** (对应 HighByte 0x6C):
```assembly
Entry 108 @ 0x0806C0:
  原始数据: 3c1c7c5cc0a0c9c82c107050b494c9c8

  [+0x00] 0x1C3C -> 0x081C3C ✓ 有效代码
  [+0x02] 0x5C7C -> 0x085C7C ✓ 有效代码
  [+0x04] 0xA0C0 -> 0x08A0C0 ✓ 有效代码
```

**验证 0x081C3C 处理函数**:
```assembly
0x081C3C: ldrh r4, [r6, #2]  ← 包含 CJK 模式!
0x081C3E: subs r1, #0x49
0x081C40: adds r6, #0x48
0x081C42: lsls r0, r5, #1
0x081C44: ble #0x81c36
```

**结论**: Entry 108 确实包含 U+6Cxx 的处理函数指针 ✓

**重要发现**: 偏移量是 #2 (不是 CJK 路径的 #0x2C 或 #0x32)

---

### 🔍 0x081C3C 深度分析 (2026-01-29)

**完整函数代码**:
```assembly
0x081C3C: ldrh r4, [r6, #2]  ← 从 r6+2 加载半字
0x081C3E: subs r1, #0x49
0x081C40: adds r6, #0x48       ← r6 += 72
0x081C42: lsls r0, r5, #1
0x081C44: ble #0x81c36        ← 条件跳转
0x081C46: b #0x82244          ← 跳转到其他代码
```

**关键发现**:
- 函数非常短（约 10 条指令）
- 没有基址加载 (LDR [PC, ...])
- 没有计算 33 字节步进的代码
- `ldrh r4, [r6, #2]` 可能是查表操作
- `adds r6, #0x48` 调整 r6 指针（可能是到下一个字符）

**双位置发现**:
```
0x081C10: ldrh r4, [r6, #2]  ← 循环内部
0x081C3C: ldrh r4, [r6, #2]  ← 可能是函数入口
```

**❌ 验证结果**:
- ✗ 未找到基址硬编码 (0x46xxxx)
- ✗ 未找到 MUL/LSL #5 计算模式
- ✗ 未找到 Flash 基址加载

**推论**:
- r6 在进入 0x081C3C 之前已经被计算
- 0x081C3C 可能只是查表/调整函数
- 真正的计算在调用链的上游

---

### ✅ 0x02DDDC 调度器验证 (2026-01-29)

**验证方法**: Capstone 反汇编 + 控制流分析

**验证的代码位置**:
```assembly
0x02DDDC: push  {r3, r6, lr}
0x02DDDE: ldr   r7, [pc, #0x3c0]
0x02DDE2: lsls  r0, r5, #5       ; r0 = r5 << 5 (x32)
0x02DDE6: adds  r0, r4, r0       ; r0 = r4 + r0
0x02DDEE: ldrh  r2, [r0, #0x1a]  ; 从 r0+0x1A 加载半字
0x02DDF2: strh  r2, [r3, #8]
```

**✓ 确认发现**:
1. **x32 计算模式**: `LSLS r0, r5, #5` = r5 × 32
2. **加法操作**: `ADDS r0, r4, r0` = r4 + (r5 × 32)
3. **查表偏移**: `LDRH r2, [r0, #0x1a]` 从计算出的地址加载数据

**计算公式**:
```
r6 = f(r4, r5) = base_address + (r5 × 32) + 0x1A
```

**基址表发现**: 0x02D270 区域
- 模式: `46 10 46 10 46 10 ...` (重复)
- 长度: 0x02D270 - 0x02D370 (约 256 字节)
- 可能是 16 位地址表 (0x1046 = LDR r0, [r0, #0x14]?)

**待验证**: r4 参数来源和 0x02D270 表的具体用途

---

### ❌ x * 33 计算模式搜索 (2026-01-29)

**用户假设**: x * 33 优化为 (x << 5) + x

**搜索结果**:
- LSLS #5 指令 ✗ 未找到
- LSLS #0x5 指令 ✗ 未找到
- LSLS #4 指令 ✓ 找到 2 条，但不构成 x*33 模式
- MUL/MLA 指令 ✗ 未找到

**结论**: ✗ 未找到直接的 x * 33 计算代码

**可能的解释**:
1. 使用查找表而非计算
2. 计算在更早的阶段完成
3. 使用了其他优化方式

---

### 🔗 r1 渲染上下文指针追踪 (2026-01-29)

**关键代码位置**:
```assembly
0x2DA84: lsls r1, r6, #0x19     ; r1 = r6 << 25
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  ; 从 r1 加载 r6
```

**数据流**:
```
r6 (某值) -> r1 = r6 << 25 -> [r1] 加载到 r6
```

**问题**: r6 既被用来计算 r1，又从 r1 加载，这是循环依赖

**可能的解释**:
1. 这里有两个不同的 r6 值（时间上错开）
2. 或者这是不同代码路径的指令

**待解决**: 完整的 r1 -> r6 数据流

---

### 数据流追踪: r6 来源

**代码证据**:
```assembly
0x2DA2A: add  r5, sp, #0xa4    ; r5 = sp + 0xA4
...
0x032A7A: pop  {r0, r4, r5, r6, r7}  ; 恢复 r5 (从栈)
0x032A94: ldm  r5, {r0, r1, r2, r5, r6, r7}  ; r6 = [r5 + 16]
0x032ABA: ldrh r0, [r6, #0x2c]  ; 像素数据访问
```

**关键数据流**:
1. `r6 = [sp + 0xA4 + 16] = [sp + 0xB4]`
2. 栈位置 `[sp + 0xB4]` 存储像素数据指针
3. **⚠️ 未找到**: 写入 `[sp + 0xB4]` 的代码

### 剩余问题

1. **栈结构设置**: 谁写入 `[sp + 0xB4]` 像素指针？
2. **基地址公式**: `base = 0x42E172?` (需要进一步验证)
3. **Unicode → r6 完整公式**: 需要代码证据

---

## 完整控制流图

```
Unicode 输入 (r7)
    ↓
0x02D4E6: asrs r5, r7, #2    ; r5 = Unicode >> 2
    ↓
[编码类型判定]
    ↓
┌─────────────────────────────────────────────────┐
│ 0x02DB10: lsls r0, r4, #4                       │
│ 0x02DB12: cmp r0, #0x80                          │
│ 0x02DB2C: bne #0x2db4e                           │
└─────────────────────────────────────────────────┘
    ↓
┌──────────────────┬──────────────────┐
│ r4 == 0x08        │ r4 != 0x08        │
│ (标准编码)        │ (特殊编码)        │
│                   │                   │
│ Fall through      │ Branch to 0x02DB4E│
│ ↓                  │ ↓                  │
│ 0x02DB58:         │ 0x02DC22:          │
│ ldrh r2,[r6,#6]   │ ldr r6,[r0,#0x14]  │
│                   │                   │
│ pixel_ptr =       │ metadata_ptr =     │
│ 0x100000 +        │ [base +            │
│ r5 * 4            │  r5 * 2 + 0x14]    │
└──────────────────┴──────────────────┘
```

---

