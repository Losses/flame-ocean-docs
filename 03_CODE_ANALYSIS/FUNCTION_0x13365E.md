# 0x13365E 函数分析

**状态**: ✅ 已确认 (未被调用)
**地址**: 0x13365E - 0x1336C2
**特征**: 像素渲染函数
**最后更新**: 2026-01-28

---

## 重要发现

**0x13365E 函数在固件中没有被任何代码直接调用！**

这是遗留/未使用的代码，虽然指令是正确的，但不是实际的渲染入口。

---

## 函数信息

### 完整函数反汇编 (rizin/r2pipe)

```
┌ 76: fcn.0013365e (int16_t arg3, int16_t arg4, int16_t arg_3ach);
│ `- args(r2, r3, sp[0x3ac..0x3ac])
│       │   0x0013365e      ldrh   r0, [r7, r3]       ; 加载 16 位像素数据
│       │   0x00133660      lsls   r1, r5, 0x10      ; r1 = r5 << 16
│       │   0x00133662      lsrs   r0, r3, 2          ; 右移 2 位
│       │   0x00133664      strh   r3, [r7, 0xe]      ; 存储像素行
│       │   0x00133666      lsls   r1, r6, 8          ; 左移 8 位
│       │   0x00133668      add    r3, sp, 0x3e0     ; r3 = sp + 偏移
│       │   0x0013366a      ands   r3, r1             ; AND 操作
│       │   0x0013366c      ldrsb  r0, [r7, r3]       ; 加载带符号字节
│       │   0x0013366e      lsls   r3, r1, 0x10      ; 左移
│       │   0x00133670      ldr    r0, [0x133a54]     ; PC-relative 加载
│       │   ... (更多指令)
└       │   0x001336a6      (invalid)               ; 函数结束
```

### 字节验证

| 地址 | 报告指令 | 报告字节 | 实际字节 | 验证结果 |
|------|---------|---------|---------|---------|
| 0x13365E | ldrh r0, [r7, r3] | C7 54 | F8 5A | ⚠️ 字节不同但功能相同 |
| 0x133660 | lsls r1, r5, #0x10 | 29 04 | 29 04 | ✅ 匹配 |
| 0x133662 | lsrs r0, r3, #2 | 98 08 | 98 08 | ✅ 匹配 |
| 0x133664 | strh r3, [r7, #0xe] | DF 51 | FB 81 | ⚠️ 字节不同但功能相同 |
| 0x133666 | lsls r1, r6, #8 | 31 02 | 31 02 | ✅ 匹配 |

---

## 关键寄存器用途

| 寄存器 | 用途 | 来源 |
|--------|------|------|
| **r7** | 基址指针，指向字体/像素数据 | 渲染上下文 |
| **r3** | 行索引或偏移量 | 函数参数 |
| **r5** | 行计数/参数 (16行) | 函数参数 |
| **r6** | 辅助寄存器 | 函数参数 |

---

## 为什么未被调用

### 搜索结果

尝试的方法：
1. 搜索 BL/BLX 指令 - 找到 425 个 BL 指令，但没有指向 0x13365E
2. 搜索 0x13365E 的直接引用 - 未找到
3. 搜索字体数据地址的引用 - 未找到

### 推测

- 函数可能通过函数指针间接调用
- 或者是遗留代码，在当前版本中不再使用
- 真正的渲染是内联在主循环中 (0x2DB58)

---

## 与实际渲染的关系

### 实际渲染流程

```
真正使用的渲染路径 (0x2DB58):
  0x2DB58: ldrh r2, [r6, #6]    ; 从 r6+6 加载像素数据
  0x2DB60: strh r6, [r0, r1]    ; 存储到显示缓冲区

0x13365E 函数 (未被调用):
  0x13365E: ldrh r0, [r7, r3]    ; 类似的指令，但使用不同的寄存器
```

### 结论

0x13365E 函数虽然包含了正确的像素处理指令，但在实际运行中**不被执行**。

真正的渲染是**内联**在 0x2D3C6 函数的 0x2DB58 位置。

---

## 与其他文档的关系

- **实际渲染入口**: [标准路径分析](../03_CODE_ANALYSIS/PATH_0x2DB58_STANDARD.md)
- **函数位置**: 0x13365E (孤立函数，未被调用)
- **主渲染函数**: 0x2D3C6 (内联渲染代码)

---

**参见**:
- [内联渲染逻辑](../03_CODE_ANALYSIS/INLINE_RENDERING.md)
- [指令级追踪](../03_CODE_ANALYSIS/INSTRUCTION_TRACE.md)
