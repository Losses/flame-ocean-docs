# 基于已验证指令的代码分析

**分析日期**: 2026-01-29
**方法**: Capstone 反汇编验证

---

## 函数签名 (代码证据)

```c
void FUN_02d500(int param_1, int param_2, int param_3)
```

**参数映射**:
- `r0` = param_1 (数据结构指针)
- `r1` = param_2 (字符索引/数据)
- `r2` = param_3

---

## 已验证的数据流

### 关键指令序列

```assembly
0x02D500: stm    r0!, {r1, r2}    ; 存储参数到栈
0x02D504: movs   r6, r1           ; r6 = param_2  ⚠️ 关键!
0x02D518: asrs   r5, r6, #2       ; r5 = r6 >> 2
0x02D5F4: movs   r0, r5           ; r0 = r5
0x02D604: asrs   r0, r6, #0x13    ; r0 = r6 >> 19
0x02D618: ldm    r0!, {r5, r6}    ; 从 r0 加载 r5, r6
0x02D63C: asrs   r5, r6, #2       ; r5 = r6 >> 2
0x02D63E: lsrs   r0, r5, #5       ; r0 = r5 >> 5
0x02D688: ldr    r6, [r0, #0x14]  ; r6 = [r0 + 0x14]
0x02DB58: ldrh   r2, [r6, #6]     ; r2 = [r6 + 6] (像素数据)
```

---

## 数据流分析

### 阶段 1: 参数传递 (0x02D500-0x02D504)

```
r6 = param_2
```

**结论**: r6 保存字符索引（来自 param_2）

### 阶段 2: 第一次索引计算 (0x02D518)

```
r5 = r6 >> 2
```

### 阶段 3: 地址计算 (0x02D5F4-0x02D604)

```
r0 = r5                    ; r0 = (r6 >> 2)
r0 = r6 >> 19              ; r0 = param_2 >> 19  ⚠️
```

**问题**: `r6 >> 19` 的值很小（如果 r6 ≈ 0x0FDE，结果为 0）

### 阶段 4: 数据加载 (0x02D618)

```
ldm r0!, {r5, r6}          ; 从 r0 加载两个 32 位值
```

### 阶段 5: 查找表计算 (0x02D63C-0x02D688)

```
r5 = r6 >> 2               ; r5 = r6 >> 2
r0 = r5 >> 5               ; r0 = r6 >> 7
r6 = [r0 + 0x14]           ; 从查找表加载
```

### 阶段 6: 像素数据加载 (0x02DB58)

```
r2 = [r6 + 6]              ; 像素数据
```

---

## 未解决的问题

### 1. `r6 >> 19` 的含义

如果 r6 = param_2 ≈ 0x0FDE (4062)，那么：
- `r6 >> 19 = 0`

这个 0 地址有什么意义？

### 2. r0 在 0x02D618 处的值

从数据流看，r0 = (param_2 >> 19)，这通常是一个很小的值（0 或 1）。

**假设**: 可能存在一个基址寄存器，r0 是偏移量？

### 3. 常量 0xD1

```assembly
0x02D5E8: movs r4, #0xd1     ; r4 = 0xD1
```

这个常量的用途是什么？
