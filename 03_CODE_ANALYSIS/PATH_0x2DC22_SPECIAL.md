# 特殊路径分析 (0x2DC22)

**状态**: ❌ 已确认为死代码/调试代码
**Bit 7**: 1 (特殊14列，已废弃)
**最后更新**: 2026-01-28

---

## ⚠️ 重要结论

**0x2DC22 是死代码**，在实际运行中不被执行。

### 证据

1. **无效内存访问**: `ldm` 加载的 r0 = 0xAE5B3854 不是有效地址
2. **不必要路径**: 0x2DB58 已处理所有字符
3. **Bit 7 不是编码类型标志**: 元数据中的 Bit 7 = 1 并不意味着使用 0x2DC22

---

## 原问题的错误假设

```
❌ 错误问题: "如何从 0x2600 到达 0x2680？（0x80 偏移）"
❌ 错误假设: 0x2680 是像素数据
```

### 正确理解

```
✓ 0x2600-0x267F: 字符串表/元数据（128 字节，64% ASCII）
✓ 0x2680-0x26FF: 参数表（128 字节，16 位值）
✓ 两者是同一数据结构的不同部分
✓ 真正的像素数据在: 0x100000 + r5 × 4
```

---

## 指令序列分析

### Capstone 精确反汇编

```assembly
0x0002DC22:  adds  r0, r0, #0xb5     ; r0 = r0 + 0xB5
0x0002DC24:  lsls  r6, r0, #0x11     ; r6 = r0 << 17
0x0002DC26:  asrs  r0, r1, #0x11     ; r0 = r1 >> 17 (算术右移)
0x0002DC28:  asrs  r6, r0, #0x15     ; r6 = r0 >> 21
0x0002DC2A:  strh  r0, [r6, #0x3c]   ; 存储 r0 到 [r6+0x3C]
0x0002DC2C:  lsls  r0, r5, #1
0x0002DC2E:  ldr   r7, [pc, #0x3c0]  ; r7 = 0x57F80026 (PC-relative)
0x0002DC30:  adds  r2, r0, r0
0x0002DC3E:  ldr   r6, [r0, #0x14]   ; r6 = [r0 + 0x14]
0x0002DC40:  asrs  r0, r6, #3        ; r0 = r6 >> 3
0x0002DC42:  revsh r6, r7            ; r6 = revsh(r7) = 0xFFFFF857
0x0002DC48:  ldm   r6!, {r0-r5, r7}  ; 从 0x2600 加载 7 个寄存器
```

### PC-relative 加载验证

```
PC = 0x2DC32 (0x2DC2E + 4)
目标 = PC + 0x3C0 = 0x2DFF2

0x2DFF2 处的字节: F8 57 40 20
Little-endian 值: 0x204057F8
```

---

## REVSH 计算分析

```
r7 = 0x204057F8
revsh r6, r7 执行:
  1. 取低 16 位: 0x57F8
  2. 字节交换: 0xF857
  3. 符号扩展: 0xFFFFF857 (负数)
```

**问题**: 0xFFFFF857 不是有效内存地址！

---

## 数据地址验证

| 地址 | 内容 | 类型 |
|------|------|------|
| 0x2600 | ASCII 字符串 | 字符串表 |
| 0x2680 | 二进制数据 | 参数表 |
| 0xFFFFF857 | (超出范围) | 无效 |

---

## 重大发现: 0x2DFF0 vs 0x2DFF2

检查 0x2DFF0 的值：

```
0x2DFF0: 26 00 F8 57 (little-endian: 0x57F80026)
0x2DFF2: F8 57 40 20 (little-endian: 0x204057F8)

REVSH(0x57F80026):
  - 低 16 位: 0x0026
  - 字节交换: 0x2600
  - 符号扩展: 0x00002600 ✓ 有效地址！
```

---

## 执行流程澄清

```assembly
0x2DC2E: ldr r7, [pc, #0x3c0]  ; r7 = 0x57F80026 (编码地址)
0x2DC42: revsh r6, r7          ; r6 = 0x2600 (元数据基地址)
0x2DC48: ldm r6!, {r0-r5, r7} ; 从 0x2600 加载 7 个寄存器
```

**LDM 加载的内容**:
- 从 0x2600 加载 7 个寄存器 (28 字节)
- r6 递增到 0x2600 + 28 = 0x261C
- 这些是渲染参数，不是像素数据

---

## 结论

| 问题 | 答案 |
|------|------|
| "0x80 偏移" 如何到达 0x2680？ | 不存在这个问题。0x2600 和 0x2680 是同一渲染配置结构的不同部分。 |
| 0x2DC22 路径是否被使用？ | ❌ 否，这是死代码/调试代码 |
| 真正的像素数据在哪里？ | 0x100000 + r5 × 4 |

---

**参见**:
- [标准路径分析](./PATH_0x2DB58_STANDARD.md)
- [废弃代码路径](../06_FAILED_HYPOTHESES/DEAD_CODE_PATHS.md)
