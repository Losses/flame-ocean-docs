# 标准路径分析 (0x2DB58)

**状态**: ✅ 主要渲染路径
**编码类型**: Bit7=0 (标准15列)
**最后更新**: 2026-01-28

---

## 关键发现

**0x2DB58 是主要的渲染入口点**，所有字符（包括沨、沪、潢）都使用这条路径。

---

## 指令序列

### 像素数据加载 (0x2DB58)

```assembly
0x0002DB58:  ldrh   r2, [r6, #6]    ; 从 r6+6 加载16位数据
                                      ; r6 = 0x100000 + r5 × 4
```

### 地址计算 (0x2DB5A-0x2DB5C)

```assembly
0x0002DB5A:  subs   r0, r0, #0x46   ; r0 = r0 - 0x46
0x0002DB5C:  lsls   r0, r6, #3      ; r0 = r6 << 3
```

### 像素数据存储 (0x2DB5E-0x2DB60)

```assembly
0x0002DB5E:  str    r0, [r7, #0x1c]  ; 存储计算出的地址
0x0002DB60:  strh   r6, [r0, r1]    ; 存储像素数据到显示缓冲区！
```

---

## 寄存器用途

| 寄存器 | 用途 | 证据 |
|--------|------|------|
| r6 | 字体数据指针 | `ldrh r2, [r6, #6]` |
| r7 | 渲染上下文 | `str r0, [r7, #0x1c]` |
| r2 | 临时数据 | `ldrh r2, [r6, #6]` |

---

## 渲染流程伪代码

```c
void render_standard(
    uint16_t* font_data,      // r6: 字体数据指针 @ 0x100000 + r5 × 4
    rendering_context* ctx,   // r7: 渲染上下文
    int column_index          // r1: 当前列索引
) {
    // 1. 加载16位字体数据 (跳过 6 字节元数据)
    uint16_t pixel_data = font_data[6];  // ldrh r2, [r6, #6]

    // 2. 计算目标地址
    uint32_t target_addr = font_data << 3;  // lsls r0, r6, #3

    // 3. 存储到显示缓冲区
    display_buffer[target_addr] = pixel_data;  // strh r6, [r0, r1]
}
```

---

## 与 0x2DC22 的对比

| 特性 | 0x2DB58 (标准路径) | 0x2DC22 (死代码) |
|------|-------------------|------------------|
| 状态 | ✅ 实际使用 | ❌ 不执行 |
| 像素数据源 | 0x100000 + r5 × 4 | 0x2600 |
| 结果 | 正确渲染 | 无效内存访问 |

---

## 数据流

```
r5 (字符索引)
    │
    ▼
r6 = 0x100000 + r5 × 4
    │
    ▼
ldrh r2, [r6, #6]  →  加载像素数据
    │
    ▼
strh r6, [r0, r1]  →  写入显示缓冲区
```

---

**参见**:
- [内联渲染逻辑](./INLINE_RENDERING.md)
- [特殊路径分析](./PATH_0x2DC22_SPECIAL.md)
