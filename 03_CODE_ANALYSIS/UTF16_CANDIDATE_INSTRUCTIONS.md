# UTF-16 字符串处理候选指令分析

**状态**: ⚠️ 搜索进行中，未找到确认的 UTF-16 处理代码
**最后更新**: 2026-01-29
**分析者**: Claude (Capstone 反汇编)

---

## 概述

本文档记录了对可能处理 UTF-16 字符串的 LDRH 指令的分析结果。

**重要警告**: 以下所有指令都只是**候选**，没有确认它们实际用于 UTF-16 字符串处理。

---

## 候选指令列表

### 已知渲染代码 (非 UTF-16)

| 地址 | 指令 | 功能 | 状态 |
|------|------|------|------|
| 0x2DB58 | `ldrh r2, [r6, #6]` | 像素数据加载 | ✅ 已确认 |
| 0x2DB64 | `ldrh r0, [r7, #6]` | 未知 | ⚠️ 候选 |
| 0x2DB96 | `subs r2, r7, #7` | 未知 | ⚠️ 候选 |

**注意**: 0x2DB58 确认是像素数据加载，不是 UTF-16 处理。

### UTF-16 候选 (未确认)

| 地址 | 指令序列 | 位置 | 状态 |
|------|----------|------|------|
| 0x10C026 | `ldrh r0, [r7, r3]` → `cmp r0, #0` | 可能检查 null 终止符 | ⚠️ 候选 |
| 0x10C022 | `ldrh r5, [r5, #0x12]` | 在循环中 (跳转到 0x010514) | ⚠️ 候选 |
| 0x10C022 | `ldrh r5, [r5, #0x22]` | 在循环中 (跳转到 0x010514) | ⚠️ 候选 |
| 0x2FCF4 | `ldrh r6, [r7, #0xe]` | Ghidra 创建的函数 | ❌ 反汇编错误 |

---

## 详细分析

### 候选 1: 0x10C026 - Null 终止符检查?

```assembly
0x10C01A: strh   r3, [r7, #6]
0x10C01C: lsrs   r0, r0, #0x13
0x10C01E: stm    r6!, {r3, r4, r5, r6, r7}
0x10C020: ldrb   r1, [r6]
0x10C022: lsrs   r3, r6
0x10C024: str    r4, [sp, #0xac]
0x10C026: ldrh   r0, [r7, r3]    ; 加载半字
0x10C028: cmp    r0, #0         ; 与 0 比较
0x10C02A: asrs   r3, r3, #0x1e
0x10C02C: strh   r6, [r0, #0x32] ; 使用 r0 作为地址!
```

**分析**:
- `ldrh r0, [r7, r3]` - 从 [r7 + r3] 加载 16 位值
- `cmp r0, #0` - 与 0 比较 (可能是检查 null 终止符)
- **但是**: `strh r6, [r0, #0x32]` 将 r0 作为地址使用，这不像是字符串处理

**结论**: 可能不是 UTF-16 处理，更可能是某种数据结构访问。

---

### 候选 2: 0x10C022 - 循环中的 LDRH

```assembly
; 循环范围: 0x010514 - 0x010C30
0x010C20: ldrh r5, [r5, #0x22]  ; 从 [r5 + 0x22] 加载半字
0x010C22: ldrb r5, [r5, #5]     ; 从 [r5 + 5] 加载字节
; ... 跳转回 0x010514
```

**分析**:
- LDRH 和 LDRB 组合使用
- 在循环结构中
- **但是**: r5 既用于加载又用于地址计算，这是不寻常的模式

**结论**: 可能是某种数据结构遍历，不一定是字符串处理。

---

### 候选 3: 0x2FCF4 - Ghidra 创建的函数

```assembly
0x02FCB0: udf    #0x20           ; 永久陷阱指令!
0x02FCB2: asrs   r0, r6, #0xb
0x02FCB4: ldr    r1, [pc, #0x3e8]
...
```

**分析**:
- 以 `udf #0x20` (永久陷阱) 开头
- 这表明该区域不是有效的代码
- Ghidra 错误地将数据识别为代码

**结论**: **不是代码**，这是数据区域被误识别。

---

## 搜索方法总结

### 方法 1: LDRH + CMP #0 模式

**原理**: UTF-16 字符串处理通常检查 null 终止符 (`0x0000`)

**结果**:
- 找到 20+ 个候选位置
- 大多数不是字符串处理
- 没有找到明确的 UTF-16 字符串长度计算函数

### 方法 2: LDRH 在循环结构中

**原理**: 字符串迭代通常在循环中加载字符

**结果**:
- 找到 10+ 个候选
- 大多数是数据结构遍历
- 没有找到典型的字符串迭代模式

### 方法 3: LDRH + LDRB 组合

**原理**: UTF-16 LE 的低字节检查

**结果**:
- 找到 10+ 个候选
- 没有确认是 UTF-16 处理

---

## 结论

### ❌ 未找到确认的 UTF-16 处理代码

经过详细分析，**没有找到任何确认的 UTF-16 字符串处理代码**。

### 可能的原因

1. **代码未在我们搜索的区域内**
   - UTF-16 处理可能在其他内存区域
   - 可能在 Part 3 或其他分区

2. **使用不同的实现方式**
   - 可能使用 DMA 或硬件加速
   - 可能使用库函数（不在固件中）

3. **静态分析局限**
   - 代码可能被混淆或加密
   - 可能需要运行时才能确定地址

4. **我们的搜索方法不正确**
   - 可能有其他指令模式
   - 可能使用我们未考虑的方法

### 建议的后续方向

1. **分析 Part 3 Resource 索引表**
   - 938,405 条目的大索引表
   - 可能包含字符串查找机制

2. **动态分析**（需要设备）
   - 在真实设备上设置断点
   - 观察运行时行为

3. **接受静态分析的局限性**
   - 将字符串表标记为"数据存在，访问方式未知"
   - 继续专注于位图字体渲染（有更多代码证据）

---

## 附录: 证据等级说明

| 等级 | 描述 | 示例 |
|------|------|------|
| ✅ 已确认 | 有完整证据链 | `0x2DB58: ldrh r2, [r6, #6]` 像素数据加载 |
| ⚠️ 指令存在 | 找到指令但功能未知 | `0x10C026: ldrh r0, [r7, r3]` 可能是 UTF-16 |
| ⚠️ 数据存在 | 找到数据但用途未知 | 字符串表 @ 0x79B084 |
| ⚠️ 从数据反推 | 从数据反推的模式 | Unicode 映射公式 |

---

**相关文档**:
- [字符串表数据发现](../04_DATA_DISCOVERY/LANGUAGE_TABLE.md)
- [执行摘要](../01_OVERVIEW/EXECUTIVE_SUMMARY.md)
- [方法论经验教训](./METHODOLOGY_LESSONS.md)
