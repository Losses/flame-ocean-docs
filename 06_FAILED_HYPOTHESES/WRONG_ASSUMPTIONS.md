# 错误假设记录

**状态**: ✅ 已记录
**最后更新**: 2026-01-28

---

## 假设 1: 错位读取 (已证伪)

### 假设内容

`adds r7, r7, #2` 跳过 2 字节，导致后续读取错位

### 实现方式

```python
char_data = data[offset + 2:offset + CHAR_SIZE]
```

### 结果

匹配率 **14.3%** (完全失败)

### 结论

❌ 错误假设

---

## 假设 2: 0x96 是分隔标记 (已证伪)

### 假设内容

每 4 字节 = [值1] [值2] [0x96] [值3]

### 错误实现

```python
def extract_bitmap_wrong(data, addr):
    bitmap_data = []
    i = 0
    while i < 64:
        if b == 0x96:
            i += 1  # ← 错误: 0x96 不是标记!
        else:
            val = data[addr + i] | (data[addr + i + 1] << 8)
            bitmap_data.append(val)
            i += 2
    return bitmap_data
```

### 证据

| 字符 | r5 | 0x96 位置 | 结论 |
|------|----|----------|------|
| 沨 | 0x0FDE | [1] | 0x96 在第 2 字节 |
| 沤 | 0x0FDB | [1, 7, 13] | 0x96 在多个位置 |
| 沦 | 0x0FDC | [3, 9] | 0x96 在不同位置 |

### 结论

❌ 0x96 是像素数据的一部分，不是分隔符

---

## 假设 3: 0x80 偏移问题 (不存在)

### 原错误问题

"如何从 0x2600 到达 0x2680？（0x80 偏移）"

### 正确理解

```
✓ 0x2600-0x267F: 字符串表/元数据（128 字节）
✓ 0x2680-0x26FF: 参数表（128 字节）
✓ 两者是同一数据结构的不同部分
✓ 真正的像素数据在: 0x100000 + r5 × 4
```

### 结论

❌ "0x80 偏移"问题不存在。0x2600 和 0x2680 是渲染配置数据，不是像素数据。

---

## 假设 4: 两条路径由 Bit 7 决定 (已修正)

### 原错误理解

- Bit 7 = 0: 使用 0x2DB58
- Bit 7 = 1: 使用 0x2DC22

### 正确理解

- **0x2DB58**: 主要渲染路径（所有字符都使用）
- **0x2DC22**: 死代码/调试代码（不执行）
- **Bit 7 不是编码类型标志**

### 结论

❌ 错误假设

---

## 假设 5: 简单字节交换 (未经验证)

### 假设内容

只需交换字节顺序，不跳过字节

### 状态

⚠️ 未通过逆向工程验证
- 经验性测试声称 80-88% 匹配
- 但未在固件代码中找到对应逻辑

### 结论

❓ 需要进一步验证

---

## 总结

| 方法 | 结果 | 结论 |
|------|------|------|
| 偏移读取假设 | 14.3% 匹配率 | ❌ 证伪 |
| 0x96 标记假设 | 多位置不一致 | ❌ 证伪 |
| 0x80 偏移问题 | 不存在 | ❌ 证伪 |
| 双路径 Bit 7 决定 | 实际只有一条路径 | ❌ 证伪 |
| 简单字节交换 | 未经验证 | ❓ 待验证 |

---

**参见**:
- [废弃代码路径](./DEAD_CODE_PATHS.md)
