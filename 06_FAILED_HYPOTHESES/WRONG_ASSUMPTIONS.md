# 错误假设记录

**状态**: ✅ 已记录
**最后更新**: 2026-01-29

---

## 假设 0: 之前的 Unicode → r5 映射错误 (已证伪)

### 验证日期: 2026-01-29

### 之前的错误假设

| 错误假设 | 来源 | 正确答案 |
|----------|------|----------|
| `U+6CA8 → r5=0x0FDE` | 暴力搜索反推 | `U+6CA8 → r5=0x1B2A` |
| `高字节: 0x6C → 0x0F (差值 0x5D)` | 数据拟合 | `r5 = Unicode >> 2` |
| `offset(u_lo)` 复杂公式 | 数据拟合 | 不存在此函数 |

### 为什么之前出错？

1. **循环论证**: 暴力搜索找到的地址 (0x466772) 被用来推导 r5 值
2. **数据拟合**: 从有限的样本推导复杂的数学公式
3. **缺少代码验证**: 没有从反编译代码中确认假设

### 正确的映射机制

**映射代码**: `0x02D4E6: asrs r5, r7, #2`
**映射公式**: `r5 = Unicode >> 2`
**像素地址**: `0x100000 + (Unicode >> 2) * 4`

### 验证结果（全部错误，为避免误导删除之）

### 结论

❌ **之前的映射假设完全错误**
✅ **正确的映射已通过 Capstone 反汇编验证**

---

## 假设 1: 错位读取 (已证伪)

### 假设内容

`adds r7, r7, #2` 跳过 2 字节，导致后续读取错位

### 实现方式

```python
char_data = data[offset + 2:offset + CHAR_SIZE]
```

### 结果

匹配率 **14.3%** (完全失败)

### 结论

❌ 错误假设

---

## 假设 2: 0x96 是分隔标记 (已证伪)

### 假设内容

每 4 字节 = [值1] [值2] [0x96] [值3]

### 错误实现 (来自原分析)

```python
# ❌ 错误：跳过 0x96
if data[addr + i] == 0x96:
    i += 1  # 跳过标记 ← 错误！
```

### 证据

| 字符 | r5 | 0x96 位置 | 结论 |
|------|----|----------|------|
| 沨 | 0x0FDE | [1] | 0x96 在第 2 字节 |
| 沤 | 0x0FDB | [1, 7, 13] | 0x96 在多个位置 |
| 沦 | 0x0FDC | [3, 9] | 0x96 在不同位置 |

### 结论

❌ 0x96 是像素数据的一部分，不是分隔符

---

## 假设 3: 0x80 偏移问题 (不存在)

### 原错误问题

"如何从 0x2600 到达 0x2680？（0x80 偏移）"

### 正确理解

```
✓ 0x2600-0x267F: 字符串表/元数据（128 字节）
✓ 0x2680-0x26FF: 参数表（128 字节）
✓ 两者是同一数据结构的不同部分
✓ 真正的像素数据在: 0x100000 + r5 × 4
```

### 结论

❌ "0x80 偏移"问题不存在。0x2600 和 0x2680 是渲染配置数据，不是像素数据。

---

## 假设 4: 两条路径由 Bit 7 决定 (已修正)

### 原错误理解

- Bit 7 = 0: 使用 0x2DB58
- Bit 7 = 1: 使用 0x2DC22

### 正确理解

- **0x2DB58**: 主要渲染路径（所有字符都使用）
- **0x2DC22**: 死代码/调试代码（不执行）
- **Bit 7 不是编码类型标志**

### 结论

❌ 错误假设

---

## 假设 5: 简单字节交换 (未经验证)

### 假设内容

只需交换字节顺序，不跳过字节

### 状态

⚠️ 未通过逆向工程验证
- 经验性测试声称 80-88% 匹配
- 但未在固件代码中找到对应逻辑

### 结论

❓ 需要进一步验证

---

## 总结

| 方法 | 结果 | 结论 |
|------|------|------|
| 偏移读取假设 | 14.3% 匹配率 | ❌ 证伪 |
| 0x96 标记假设 | 多位置不一致 | ❌ 证伪 |
| 0x80 偏移问题 | 不存在 | ❌ 证伪 |
| 双路径 Bit 7 决定 | 实际只有一条路径 | ❌ 证伪 |
| 简单字节交换 | 未经验证 | ❓ 待验证 |
| r6 计算公式搜索 | 静态搜索 0 结果 | ❌ 未找到 |

---

**参见**:
- [废弃代码路径](./DEAD_CODE_PATHS.md)

---

## 假设 6: r6 计算公式直接在代码中找到 (搜索失败)

### 假设内容

`r6 = 0x100000 + r5 × 4` 的计算代码可以通过静态分析在固件中找到。

### 搜索尝试

#### 尝试 1: 搜索特定指令模式

**搜索目标**:
- `lsls r6, r5, #2` (r5 × 4)
- `ldr r6, [pc, #offset]` (加载 0x100000 基址)
- `adds r6, r5, lsl #2` (r5 × 4 + 基址)

**搜索范围**: 0x10000 - 0x80000

**结果**: 0 条匹配

#### 尝试 2: 从渲染代码向前追踪

**追踪路径**:
```
0x2DB58: ldrh r2, [r6, #6]  ← 从这里向前
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  ← r6 从这里加载
```

**搜索范围**: 0x28000 - 0x2DA8E (159 条指令)

**结果**:
- 写入 r6 的指令: 0 条
- pop/push r6: 0 条
- 函数调用 (bl): 0 条

#### 尝试 3: 搜索所有写入 r6 的指令

**搜索范围**: 0x10000 - 0x50000

**结果**:
- Thumb 模式: 仅 1 条 `str r6, [sp, #0x150]` (不是计算)
- ARM 模式: 无法解析 (代码是 Thumb 模式)

#### 尝试 4: 搜索常量 0x100000

**搜索目标**: 字节序列 `00 00 10 00` (little-endian)

**结果**: 找到多处，但无法确认哪处用于 r6 计算

### 遇到的困难

1. **代码区域识别困难**
   ```
   搜索范围: 0x10000-0x80000 (448KB)
   解析结果: 仅 30 条 Thumb 指令
   ```
   固件 33MB 中大部分是数据，无法确定哪部分是可执行代码。

2. **计算方式可能不是直接的**
   可能是：
   - 查表（r5 作为索引）
   - 函数返回值
   - 多步计算（通过不同寄存器）
   - 在不同区域（0x28000 之前）

3. **不知道入口点**
   无法从 Unicode 输入点开始追踪完整数据流。

### 结论

❌ **静态搜索未能找到 r6 计算代码**

**可能的原因**:
- 计算代码在未搜索到的区域
- 使用了未预料的方式（查表、函数调用等）

**下一步建议**:
1. 找到 Unicode 输入的入口点

---

## 假设 7: "行交错"字体格式 (已证伪)

### 假设内容

字体数据使用"行交错"格式存储在多个表中：
```
假设的公式: addr = (table_idx << 16) | 0x09C4 + (row << 10) + (char << 1)
```

### 错误实现 (2026-01-29)

```python
# ❌ 错误：假设行交错格式
table_base = (table_idx << 16) | 0x09C4
for row in range(16):
    row_offset = row * 512 * 2  # 行交错
    char_offset = char_idx * 2
    addr = table_base + row_offset + char_offset
```

### 问题

1. **没有遵循汇编代码证据**
   - 当时假设文档说明 `r6 = 0x100000 + r5 × 4`
   - 但使用了错误的基址 `(table_idx << 16) | 0x09C4`

2. **基于数据模式的错误推测**
   - 看到一些重复模式就推断是"行交错"
   - 没有验证提取结果是否正确

3. **提取结果破碎**
   - 字符出现"撕裂"和错位
   - 仍坚持错误假设

### 正确理解（2026-01-29 更新）

```
✅ 像素数据通过暴力搜索样本验证
✅ 实际位置: 0x44xxxx/0x46xxxx/0x4Axxxx/0x4Cxxxx 区域
✅ 每字符 32 字节 (16 行 × 2 字节)
✅ odd/even 字节交换编码
✅ `r6 = 0x100000 + r5 × 4` 是错误假设，未找到代码证据
```

### 结论

❌ **错误假设** - 基于猜测而非汇编代码证据

### 经验教训

1. 信任暴力搜索 + 样本验证，而非猜测公式
2. 提取结果不正确时，重新审视假设
3. `r6 = 0x100000 + r5 × 4` 本身是未经验证的假设

---

## 假设 8: `r6 = 0x100000 + r5 × 4` 字符地址公式 (已证伪)

### 假设内容

字符数据地址 = 0x100000 + r5 × 4，其中 r5 是字符索引。

### 错误实现

```python
# ❌ 错误：基于未验证的公式
char_base = 0x100000 + char_idx * 4  # 每字符 4 字节？
# 或者
char_base = 0x100000 + char_idx * 64  # 每字符 64 字节？
```

### 证据 - 暴力搜索验证

| 字符 | 公式计算 (r5=0x0FDE) | 实际位置 (暴力搜索) | 匹配? |
|------|---------------------|-------------------|-------|
| 沨 | 0x103F78 | 0x466772 | ✗ |
| 沤 | 0x103F6C | 0x4666EE | ✗ |
| 沦 | 0x103F70 | 0x466730 | ✗ |
| 婔 | 0x103F78 | 0x440A9E | ✗ |

### 正确理解（通过样本验证）

```
✅ 像素数据位置通过暴力搜索样本像素图模式找到
✅ 验证方法: sample_texts/ 目录的 ASCII 像素图
✅ 编码为二进制模式后在固件中精确搜索
✅ 验证结果: 65 个字符，100% 匹配
```

### 结论

❌ **错误假设** - `r6 = 0x100000 + r5 × 4` 未找到代码证据，与实际数据不匹配

### 参见文档

- [R6_PIXEL_DATA_POINTER.md](../03_CODE_ANALYSIS/REGISTERS/R6_PIXEL_DATA_POINTER.md) - 明确标记"未找到代码证据"
- [PIXEL_DATA_LOCATION.md](../04_DATA_DISCOVERY/PIXEL_DATA_LOCATION.md) - 正确的提取方法

---

## 更新总结

| 日期 | 假设 | 结果 |
|------|------|------|
| 2026-01-28 | 假设 1-5 | 各种错误假设 |
| 2026-01-29 | 假设 6 | r6 计算公式搜索失败 |
| 2026-01-29 | 假设 7 | "行交错"字体格式错误 |
| 2026-01-29 | 假设 8 | `r6 = 0x100000 + r5 × 4` 公式错误 |

---

## 假设 9: 系统性假设验证研究 (2026-01-29)

### 研究概述

经过 7 个系统性假设的全面验证，寻找 Unicode → r5 映射机制。

### 假设 9.1: 函数指针表/跳转表机制 ❌

**假设内容**: 渲染函数通过函数指针表或跳转表调用

**验证方法**: 搜索 0x02FA00 跳转表是否包含 0x2DA62

**结果**:
- 跳转表地址范围: 0x02FA00-0x030000
- 分析了 32 个条目
- 未找到 0x2DA62 渲染函数地址
- 未找到直接函数指针

**结论**: ❌ 渲染函数不通过跳转表调用

### 假设 9.2: Unicode 范围检测 + 条件分发 ❌

**假设内容**: 系统根据 Unicode 范围选择不同的渲染函数

**验证方法**: 搜索 CMP 指令对比 Unicode 范围边界

**范围边界**: 0x80, 0x100, 0x4E00, 0x9FFF, 0xE9

**结果**:
- 搜索范围: 0x10000-0x200000
- 找到 1134 个 CMP + 分支模式
- 找到 1411 个可能的字符分发函数
- **但无 Unicode 范围边界检测**

**结论**: ❌ 不存在 Unicode 范围检测机制

### 假设 9.3: 0x13E024 SUBS #0x5D 映射指令 ❌

**假设内容**: 0x13E024 的 `subs r0, #0x5d` 是执行 Unicode 高字节映射

**验证方法**: 完整追踪 r2 寄存器变化

**r2 变化轨迹**:
```
0x13DFB6: r2 = 0x28 (40)
0x13DFC2: r2 = r3 - r4
0x13DFC4: r2 = r3 - r0
0x13E01C: lsrs r0, r2, #8  (r0 = r2 >> 8)
0x13E024: subs r0, #0x5d    (r0 = r0 - 0x5D)
```

**发现**:
- r2 的值来自算术运算，不是 Unicode 字符
- r1 在 0x13DFFA 被 ADR 重定位到局部缓冲区
- `0x13DFFE: ldrh r7, [r1, #0x20]` 从局部缓冲区加载

**结论**: ❌ 0x13E024 的 SUBS #0x5D 与 Unicode 映射无关

### 假设 9.4: Rockchip SDK 特定机制 ⚠️

**假设内容**: 使用 Rockchip RKnano SDK 特定的字符渲染机制

**验证结果**:
- ✅ 确认固件头部: "Rockchip RKnano SDK 1.0"
- ✅ 发现 0x2DD14: 0x45BB11F0 (超出固件范围)
- ⚠️ 0x45BB11F0 可能是 SDK 虚拟地址编码
- ❓ 未找到 SDK 特定的字符映射函数

**结论**: ⚠️ SDK 确认，但映射机制未找到

### 验证统计

| 搜索方法 | 搜索范围 | 结果 |
|----------|----------|------|
| BL 到渲染函数 | 0x10000-0x500000 | 0 条 |
| 函数指针表 | 0x10000-0x500000 | 0 条直接指针 |
| 跳转表分析 | 0x02FA00-0x038000 | 1022 个 (多为数据) |
| SUBS #0x5D | 0x10000-0x500000 | 76 个 |
| CMP r5,#0xE9 | 0x2D000-0x2E000 | 9 个 |
| 字符串表引用 | 整个固件 | 0 条 |

### 核心结论

❌ **经过 7 个假设的全面验证，Unicode → r5 映射代码仍未找到**

### 相关文档

- [UNICODE_TO_R5_MAPPING.md](../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md) - 详细假设验证记录
- [REMAINING_WORK.md](../01_OVERVIEW/REMAINING_WORK.md) - 未解决问题汇总

---
