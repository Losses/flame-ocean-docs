# 废弃代码路径

**状态**: ✅ 已确认
**最后更新**: 2026-01-29

---

## 0x2D680 死代码确认 (2026-01-29 验证)

### 验证状态

**状态**: ✅ **已确认为死代码**

### 目标代码 @ 0x2D680-0x2D688

```assembly
0x2D680: lsrs r0, r5, #5      ; r0 = r5 >> 5
0x2D688: ldr  r6, [r0, #0x14] ; r6 = [r0 + 0x14]
```

### 地址计算分析

当 `r5 = 0x1B2A` (沨字的正确值):
```
r0 = 0x1B2A >> 5 = 0xD1 = 209
访问地址 = 0xD1 + 0x14 = 0xE5
```

**结论**: 0xE5 位于固件头部区域，不是有效的像素数据地址。

### 调用者搜索

- **搜索范围**: 0x2D680 ± 4KB
- **搜索方法**: B/BL 指令模式匹配
- **结果**: **0 条跳转指令**

**结论**: 0x2D680-0x2D68E 是未被调用的死代码。

### 与之前错误假设的对比

| 错误假设 | 来源 | 正确答案 |
|----------|------|----------|
| `0x2D680 是查找表访问点` | 之前文档分析 | 0x2D680 是**死代码** |
| `lsrs r0, r5, #5` 计算 r6 | 之前文档分析 | 此代码不执行 |

---

## 0x2DC22 路径分析

### 结论

**0x2DC22 是死代码/调试代码**，在实际运行中不被执行。

---

## 证据

### 1. 无效内存访问

```assembly
0x2DC48: ldm r6!, {r0-r5, r7}  ; r0 = 0xAE5B3854 (超出范围)
0x2DC4A: ldr r6, [r0, #4]     ; [0xAE5B3858] 会访问无效地址
```

**问题**: r0 不是有效地址，为什么要加载 [r0 + 4]？

### 2. 不必要路径

0x2DB58 已处理所有字符（包括沨、沪、潢），不需要第二条路径。

### 3. Bit 7 不是编码类型标志

元数据中的 Bit 7 = 1 并不意味着使用 0x2DC22。

---

## 数据结构真相

### 0x2600-0x26FF 区域

```
0x2600 - 0x267F: 字符串表/元数据（128 字节，64% ASCII）
0x2680 - 0x26FF: 参数表（128 字节，16 位值）
```

两者是同一数据结构的不同部分，都是配置数据，不是像素数据。

---

## 执行流程

### Capstone 精确反汇编

```assembly
0x2DC2E: ldr r7, [pc, #0x3c0]  ; r7 = 0x57F80026 (编码地址)
0x2DC42: revsh r6, r7          ; r6 = 0x2600 (元数据基地址)
0x2DC48: ldm r6!, {r0-r5, r7} ; 从 0x2600 加载 7 个寄存器
```

### LDM 加载的内容

```
r0 = [0x2600] = 0xAE5B3854 (原始字节 "T8[._" 的 32 位表示)
r1 = [0x2604] = 0x2560135F (字节 "%e`.Q" 的 32 位表示)
```

这些是嵌入的值，不是指针！

---

## 数据地址验证

| 地址 | 内容 | 类型 |
|------|------|------|
| 0x2600 | ASCII 字符串 | 字符串表 |
| 0x2680 | 二进制数据 | 参数表 |
| 0xFFFFF857 | (超出范围) | 无效 |

---

## 关键代码位置对比

| 位置 | 路径 | 状态 | 说明 |
|------|------|------|------|
| 0x2DB58 | 主要路径 | ✅ 实际使用 | 所有字符都使用 |
| 0x2DC22 | 死代码 | ❌ 不执行 | 无效内存访问 |

---

## 与其他发现的关系

### 像素数据位置

**真正的像素数据**: 0x100000 + r5 × 4

0x2600 和 0x2680 是渲染配置数据，不是像素数据。

---

**参见**:
- [特殊路径分析](../03_CODE_ANALYSIS/PATH_0x2DC22_SPECIAL.md)
- [错误假设记录](./WRONG_ASSUMPTIONS.md)
