# r6 LDM 加载机制验证报告 - 死代码分析

**日期**: 2026-01-29
**状态**: ✅ 验证完成 - 之前的研究结论需要更正

---

## 执行摘要

经过完整的反汇编验证，**之前关于 "r6 通过 LDM 从渲染上下文加载，使用 r6_param << 25 计算数组索引" 的研究结论是错误的**。

**真相**: `r6_param << 25` 计算路径位于**死代码区域**，实际渲染流程使用的是 `r1 = r4 << 16`。

---

## 验证方法

使用 Capstone 反汇编工具对以下关键地址进行验证：
- 0x2DA80-0x2DA8E (包含 "r6 << 25" 的区域)
- 0x2D3E8 (实际执行路径)
- 0x2DA62-0x2DA64 (函数返回点)
- 0x2DA40 (跳转指令)

---

## 验证结果

### 验证点 1: 0x2DA80 是无条件跳转 ✅

```assembly
0x2DA80: b #0x2d3e8
```

**结论**: `0x2DA80` 处的无条件跳转意味着 CPU 会跳过 `0x2DA82-0x2DA8C` 之间的所有代码。

### 验证点 2: "r6 << 25" 位于死代码路径 ✅

```assembly
0x2DA82: lsls r3, r7, #0x13  ; 死代码开始
0x2DA84: lsls r1, r6, #0x19  ; ← 这是之前错误分析的 "r6 << 25"
0x2DA86: lsls r3, r4, #4
0x2DA88: adds r2, #0x46
0x2DA8A: eors r6, r0
0x2DA8C: lsls r0, r6, #3
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  ; ← 这个 LDM 也在死代码区域
```

**结论**: 之前研究报告中的关键发现 - `r6 通过 LDM 从渲染上下文加载`，实际上位于死代码区域，不会被执行。

### 验证点 3: 真实路径使用 r4 << 16 ✅

```assembly
; 实际执行路径 (0x2D3E8)
0x2D3E8: lsls r1, r4, #0x10  ; r1 = r4 << 16 (不是 r6 << 25!)
0x2D3EA: lsls r0, r4, #4
0x2D3EC: vqshlu.s64 q13, q12, #0x37
0x2D3F0: lsls r2, r4, #4
0x2D3F2: lsls r1, r4, #0x10
```

**结论**: 真实的渲染上下文指针计算是 `r1 = r4 << 16`，而不是 `r1 = r6 << 25`。

### 验证点 4: 0x2DA64 是函数返回点 ✅

```assembly
0x2DA62: movs r0, r4
0x2DA64: pop {r3, r5, r6, r7, pc}  ; ← 函数返回指令
```

**结论**: `0x2DA64` 处的 `pop {..., pc}` 是函数返回指令，意味着 `0x2DA62` 不是函数入口点，而是函数内部的一个跳转目标。

### 验证点 5: 0x2DA62 是内部跳转目标 ✅

```assembly
0x2DA3E: cbnz r1, #0x2da7e
0x2DA40: bhi #0x2da62  ; ← 跳转到 0x2DA62
0x2DA42: lsrs r7, r7, #2
```

**结论**: `0x2DA62` 是通过 `bhi #0x2da62` 指令跳转的内部目标，不是独立函数的入口点。

---

## 控制流图

```
                      ┌─────────────────┐
                      │   0x2DA3E       │
                      │   cbnz r1, ...  │
                      └────────┬────────┘
                               │
                      ┌────────▼────────┐
                      │   0x2DA40       │
                      │   bhi #0x2da62  │ ← 如果满足条件，跳转到 0x2DA62
                      └────────┬────────┘
                               │ 否
                      ┌────────▼────────┐
                      │   0x2DA42       │
                      │   lsrs r7, r7, 2│
                      │   ...           │
                      │   0x2DA80       │
                      │   b #0x2d3e8    │ ← 无条件跳转到 0x2D3E8
                      └────────┬────────┘
                               │
                ┌──────────────┴──────────────┐
                │                             │
                ▼                             ▼
    ┌───────────────────┐         ┌───────────────────┐
    │  0x2DA62-0x2DA64  │         │   0x2D3E8         │
    │  函数返回点        │         │  真实执行路径      │
    │  (pop {..., pc})  │         │  r1 = r4 << 16    │
    └───────────────────┘         └───────────────────┘

    ❌ 0x2DA82-0x2DA8C 之间的代码永远不会执行
       (包含之前错误分析的 "r6 << 25")
```

---

## 错误来源分析

### 之前研究的错误假设

1. **假设**: `0x2DA64` 是函数入口点
   - **错误**: `0x2DA64` 是 `pop {..., pc}` 函数返回指令

2. **假设**: `r1 = r6 << 25` 是渲染上下文数组索引计算
   - **错误**: 这个指令位于死代码区域，不会执行

3. **假设**: `r6_param` 是函数参数
   - **错误**: 没有找到任何代码调用这个"函数"

### 为什么会犯这个错误

1. **没有验证控制流**: 没有检查 `0x2DA80: b #0x2d3e8` 这个关键跳转
2. **误解函数边界**: 把 `pop {..., pc}` 返回点当作函数入口
3. **没有搜索调用者**: 没有验证是否存在调用 `0x2DA64` 的代码

---

## 正确的理解

### 真实的渲染上下文指针来源

```c
// 真实路径 (0x2D3E8)
r1 = r4 << 16;

// r4 的来源需要进一步追踪
// 可能是从栈加载: ldr r4, [sp, #offset]
```

### 死代码区域

以下代码区域位于 `0x2DA80: b #0x2d3e8` 之后，永远不会执行：

```assembly
0x2DA82: lsls r3, r7, #0x13
0x2DA84: lsls r1, r6, #0x19  ← 之前错误分析的 "r6 << 25"
0x2DA86: lsls r3, r4, #4
0x2DA88: adds r2, #0x46
0x2DA8A: eors r6, r0
0x2DA8C: lsls r0, r6, #3
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  ← 之前错误分析的 "LDM 加载"
```

---

## 需要重新研究的方向

### 优先级 1: 追踪 r4 的来源

```c
// 目标: 找到设置 r4 的代码
// 搜索范围: 0x2D3E8 之前
// 可能的指令: ldr r4, [sp, #offset]
```

### 优先级 2: 理解 r4 << 16 的用途

```c
// r1 = r4 << 16
// 这可能是一个地址计算或数组索引
// 需要理解 r4 代表什么
```

### 优先级 3: 验证 0x2D3E8 路径的完整性

```c
// 确认从 0x2D3E8 开始的代码路径
// 追踪完整的数据流
// 确认像素数据如何被加载
```

---

## 相关文档

- [R6 像素数据指针](../03_CODE_ANALYSIS/REGISTERS/R6_PIXEL_DATA_POINTER.md) - 需要更新
- [未解决问题](../01_OVERVIEW/REMAINING_WORK.md) - 需要更新
- [错误假设记录](./WRONG_ASSUMPTIONS.md) - 添加此案例

---

## 结论

**之前的研究报告需要全面更正**：

1. ❌ **错误**: r6 通过 LDM 从渲染上下文加载，使用 r6_param << 25 计算数组索引
2. ✅ **正确**: 真实渲染路径使用 r1 = r4 << 16

**教训**:
- 在分析代码时，必须先验证控制流
- 不能假设某个地址是函数入口点
- 必须验证代码路径是否真的被执行

---

## 方法论反思

这次错误验证了文档中的方法论警告：

> ❌ **错误做法**: 把看到的指令序列当作实际执行的代码
> ✅ **正确做法**: 必须验证控制流，确认代码是否真的被执行

**具体到本案例**：
- ❌ 看到了 `lsls r1, r6, #0x19` 就假设它是渲染上下文计算
- ✅ 应该先检查 `0x2DA80: b #0x2d3e8` 跳转，确认后续代码是死代码
