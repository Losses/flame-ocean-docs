# 逆向工程方法论 - 经验教训

**日期**: 2026-01-29
**主题**: 数据观察 vs 代码证据的区分

---

## 核心教训

**❌ 错误做法**: 把数据模式当成代码证据
**✅ 正确做法**: 只文档化能从代码证明的东西

---

## 我的错误分析流程

### 第一步：发现数据
```
在固件中发现：
- 字符串 "日本語" @ 0x778666
- 偏移表 @ 0x14AD6
- 映射关系 U+6CA8 → r5=0x0FDE
```

### 第二步：观察模式
```
从数据中观察：
- 高字节 0x6C → 0x0F (差值 0x5D)
- 低字节有不同的偏移量
```

### 第三步：推导公式
```
基于数据拟合：
r5_hi = u_hi - 0x5D
offset(u_lo) = 0x32 + (((10 - (u_lo - 0xA0)) ^ adj) >> 1)
```

### 第四步：搜索"匹配"
```
找到了执行类似操作的指令：
subs r0, #0x5d @ 0x13E024
```

### 第五步：**假设即证明** ❌
```
错误地认为：
"找到了执行减 0x5D 的指令"
↓
"这个指令处理 Unicode 高字节"
↓
"高字节处理已确认"
```

**问题**: 我从来没有验证：
- r0 在这个位置的值是什么？
- 这个指令是否真的被调用？
- 这个指令的结果真的被用于 r5 计算吗？

---

## 正确的分析流程

### 原则 1: 从已知代码点开始

```
已知确认的代码入口点:
✅ 0x2DB58: ldrh r2, [r6, #6] - 像素加载
✅ 0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7} - r5 加载

↓ 从这些点开始追踪 ↓

向前: 谁调用了这些函数？
向后: 数据从哪里来？
```

### 原则 2: 确认数据流

```
不只要找到"看起来像"的代码
要追踪完整的数据流:

Unicode 输入 → [?] → [?] → r5 → [?] → 像素输出

每个箭头都必须有代码证据
```

### 原则 3: 区分观察和证明

| 证据类型 | 例子 | 文档方式 |
|----------|------|----------|
| 代码证据 | `subs r0, #0x5d` @ 0x13E024 | "指令存在 @ 0x13E024" |
| 数据观察 | U+6CA8 → r5=0x0FDE | "从像素位置反推的映射关系" |
| 假设 | 这个指令处理高字节 | "可能的功能（未确认）" |
| 证明 | 追踪到 Unicode 输入 | "数据流追踪确认了..." |

---

## 我的错误案例

### 案例 1: offset() 函数

**错误做法**:
```
1. 观察: u_lo 和 offset 有某种关系
2. 拟合: offset = 0x32 + (((10 - (u_lo - 0xA0)) ^ adj) >> 1)
3. 搜索: 寻找匹配这个公式的指令
4. 宣称: "offset() 函数公式" ❌
```

**正确做法应该是**:
```
1. 从 r5 加载点 (0x2DA8E) 开始
2. 向后追踪: r5 从哪里来？
3. 找到 r5 被计算/赋值的代码
4. 确认输入是什么
5. 分析算法
```

**结果**: 公式是拟合的，不是从代码得到的。搜索失败。

### 案例 2: 高字节处理

**错误做法**:
```
1. 观察: 0x6C → 0x0F (差值 0x5D)
2. 搜索: 找到 `subs r0, #0x5d` @ 0x13E024
3. 宣称: "高字节处理已确认" ❌
```

**问题**: 无法确认 r0 = u_hi

**正确做法应该是**:
```
1. 从 r5 加载点 (0x2DA8E) 开始
2. 追踪 r5 的计算过程
3. 确认是否有操作 `r5_hi = u_hi - 0x5D`
4. 找到对应的代码和数据流
```

**结果**: 找到了匹配的指令，但无法确认功能。

---

## ✅ 正确案例: r6 像素指针研究 (2026-01-29)

### 研究背景

之前假设 `r6 = 0x100000 + r5 × 4` 是像素数据指针的计算公式，但这个公式是从数据观察推导的，没有代码证据支持。

### 正确的研究流程

```
问题: r6 如何被计算/加载？
  ↓
研究方向1: 指针扫描 - 验证暴力搜索地址是否被引用
  → 结果: 0x00466772 不存在于固件中 ✅
  ↓
研究方向2: 分析 0x2D6F8 查找逻辑
  → 结果: 发现 0x2D680 是死代码，实际执行其他路径 ✅
  ↓
研究方向3: 分析活代码路径 0x2DAC0-0x2DAC2
  → 发现: ldm r1!, {r3, r4, r5, r6, r7} @ 0x02DA8E ✅
  → 确认: r6 从渲染上下文结构加载 ✅
  ↓
研究方向4: 验证 DMA 与内存重映射
  → 部分证据，但确认了 r6_param << 25 的计算 ✅
```

### 关键代码证据

```assembly
; 确认的指令序列
0x02DA8E: ldm r1!, {r3, r4, r5, r6, r7}  ; r6 = [r1 + 12]
0x02DB58: ldrh r2, [r6, #6]             ; 使用 r6 加载像素
```

### 数据结构发现

```c
struct rendering_context {
    uint32_t r3;           // [r1 + 0]
    uint32_t r4;           // [r1 + 4]
    uint32_t r5;           // [r1 + 8]
    uint32_t r6;           // [r1 + 12] ← 像素数据指针
    uint32_t r7;           // [r1 + 16]
};
```

### 方法论亮点

| 方法 | 描述 | 结果 |
|------|------|------|
| ✅ 代码证据优先 | 从已知指令点开始追踪 | 找到 LDM 加载机制 |
| ✅ 死代码识别 | 验证代码路径是否实际执行 | 排除 0x2D680 死代码 |
| ✅ 数据流追踪 | 完整追踪 r6 的来源和用途 | 确认渲染上下文结构 |
| ✅ 诚实记录 | 区分代码证据和数据观察 | 明确标记证伪的公式 |

### 对比: 正确 vs 错误

| 方法 | 错误做法 (之前) | 正确做法 (本次研究) |
|------|----------------|-------------------|
| 起始点 | 数据观察 | 已知代码点 (0x02DB58) |
| 研究方向 | 搜索"匹配"的指令 | 系统性排除假设 |
| 证据标准 | "看起来像" = "确实是" | 需要完整代码证据链 |
| 结果报告 | 直接宣称"已确认" | 区分"已确认"、"数据观察"、"已证伪" |

### 核心收获

1. **系统性研究**: 4 个方向互相验证，而不是依赖单一数据点
2. **死代码识别**: 排除不执行的代码路径，避免误分析
3. **数据结构发现**: 从 LDM 指令推导出渲染上下文结构
4. **诚实报告**: 明确标记什么被确认、什么被证伪、什么仍未知

---


### 案例 3: 语言表

**错误做法**:
```
1. 发现: 字符串 "日本語" @ 0x778666
2. 宣称: "语言表已确认" ❌
```

**问题**: 没有找到使用这个表的代码

**正确做法应该是**:
```
1. 发现: 字符串 @ 0x778666
2. 搜索: 引用这个地址的代码 (LDR/ADR)
3. 追踪: 代码如何使用这个字符串
4. 确认: 是否真的被渲染
```

**结果**: 数据存在，但用途未知。

---

## 证据等级

| 等级 | 描述 | 文档标记 |
|------|------|----------|
| **Level 1: 代码确认** | 有完整的代码证据链 | ✅ 已确认 |
| **Level 2: 指令存在** | 找到了指令，但功能未知 | ⚠️ 指令存在 |
| **Level 3: 数据存在** | 找到了数据，但用途未知 | ⚠️ 数据存在 |
| **Level 4: 数据观察** | 从数据反推的模式 | ⚠️ 从数据反推 |
| **Level 5: 理论假设** | 未验证的假设 | ❓ 假设 |

---

## 检查清单

在文档化任何发现之前，问自己：

### 对于"功能"发现
- [ ] 我找到了实现这个功能的代码吗？
- [ ] 我追踪了完整的数据流吗？
- [ ] 我能从代码解释这个功能是如何工作的吗？

如果答案都是"否"，不要文档化为"已确认"。

### 对于"数据"发现
- [ ] 这个数据被代码使用了吗？
- [ ] 我找到了引用这个数据的代码吗？
- [ ] 我知道这个数据的用途吗？

如果答案都是"否"，文档化为"数据存在，用途未知"。

### 对于"指令"发现
- [ ] 我知道这个指令的输入是什么吗？
- [ ] 我知道这个指令的输出被怎么使用吗？
- [ ] 这个指令真的被执行了吗？

如果答案都是"否"，文档化为"指令存在，功能未知"。

---

## 建议的搜索策略

### 策略 1: 从已知到未知
```
已知: 0x2DB58 像素加载 (有代码证据)
  ↓
向前: 谁调用了这个函数？
向后: r6 从哪里来？r5 从哪里来？
  ↓
逐步推进到未知区域
```

### 策略 2: 数据流追踪
```
输入 → [代码] → [代码] → 输出
        ↑        ↑
     每一步都需要代码证据
```

### 策略 3: 交叉验证
```
从数据推导出假设
  ↓
在代码中寻找证据
  ↓
找到证据了吗？
  是 → 保留假设
  否 → 放弃假设
```

---

## 总结

**我犯的核心错误**: 把"看起来像"等同于"确实是"

**正确的做法**:
1. 从已知代码点开始
2. 追踪数据流
3. 只文档化能证明的东西
4. 诚实地区分观察、假设和证明

**文档诚实性原则**:
- 如果只是数据观察 → 说"观察到..."
- 如果只是假设 → 说"可能..."
- 如果找到了代码 → 说"找到代码 @ 地址"
- 如果确认了功能 → 说"已确认"

---

## 参见

- [Unicode→r5映射分析](../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md) - 错误案例集合
- [语言表数据发现](../04_DATA_DISCOVERY/LANGUAGE_TABLE.md) - 数据观察案例
- [未解决问题](./REMAINING_WORK.md) - 当前待解决问题
