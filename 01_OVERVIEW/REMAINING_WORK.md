# 未解决问题

**状态**: 📋 进行中
**最后更新**: 2026-01-29

---

## ⚠️ 重要更正 (2026-01-29) - 独立验证结果

### ✅ Unicode → r5 映射已通过 Capstone 验证

**验证方法**: 使用 Capstone 反汇编引擎进行独立验证

**已确认的代码位置**:
```assembly
0x02D4E6: asrs r5, r7, #2    ; r5 = r7 >> 2 (r7 = Unicode)
```

**验证结果**: ✅ 已确认

**详细报告**: [SOLUTION_VERIFICATION_2026-01-29.md](./SOLUTION_VERIFICATION_2026-01-29.md)

### ❌ 文档错误更正

**错误 1: 0x2D680 是死代码** (文档中声称是查找表访问点)
- **文档声称**: 0x02D688: `ldr r6, [r0, #0x14]` 是查找表访问
- **实际验证**: 0x2D680-0x2D68E 是不可达的死代码
- **搜索结果**: 整个固件中 0 条引用到 0x2DA84

**错误 2: 特殊编码条件** (文档中声称是 Bit 7 测试)
- **文档声称**: Bit 7 of metadata determines encoding type
- **实际验证**: r4 值决定编码类型 (r4 == 0x08 → 标准, r4 != 0x08 → 特殊)

**错误 3: 像素地址计算**
- **文档声称**: 沨 (U+6CA8) 像素地址是 0x466772
- **验证结果**: 标准编码路径像素地址是 0x106CA8
- **正确公式**: `pixel_ptr = 0x100000 + (Unicode >> 2) * 4`

---

### 问题 2.1: 0x2D680 死代码确认 ✅ **已解决**

**状态**: ✅ **已通过反编译验证为死代码**

**验证结果**:
- 搜索跳转到 0x2D680 的指令 → **0 结果**
- 0x2D68E: `pop {..., pc}` 是函数返回点
- 该函数未被任何代码调用

**分析**:
```assembly
0x2D680: lsrs r0, r5, #5    ; 当 r5=0x1B2A 时，r0=0xD1
0x2D688: ldr r6, [r0, #0x14]  ; 访问地址 0x21（固件头部）
```

**结论**: 0x2D680-0x2D68E 是死代码，不参与主渲染流程。

---

## 假设验证研究总结 (2026-01-29)

### 研究概述

经过系统性的假设验证，测试了 7 个不同假设来寻找 Unicode → r5 映射机制。

### 假设验证完整结果

| 假设 | 结果 | 证据等级 | 说明 |
|------|------|----------|------|
| **假设1**: 函数指针表/跳转表 | ❌ 不正确 | ✅ 代码证据 | 0x02FA00 跳转表不包含渲染函数地址 |
| **假设2**: Unicode 范围检测 | ❌ 不正确 | ✅ 代码证据 | 9 个 `CMP r5,#0xE9` 但无 Unicode 范围边界 |
| **假设3**: 资源 ID/哈希机制 | ❓ 未测试 | - | - |
| **假设4**: 预编码字符数据 | ⚠️ 部分 | ⚠️ 数据存在 | 字符串表是 UTF-16 BE UI 字符串 |
| **假设5**: 中间层渲染队列 | ❓ 未测试 | - | - |
| **假设6**: Rockchip SDK 机制 | ✅ 部分 | ✅ 数据存在 | 确认 SDK 1.0，0x45BB11F0 是虚拟地址 |
| **假设7**: 0x13E024 映射指令 | ❌ 不正确 | ✅ 代码证据 | r2 追踪显示与 Unicode 无关 |

### 搜索统计

| 搜索方法 | 搜索范围 | 结果 | 说明 |
|----------|----------|------|------|
| BL 到渲染函数 | 0x10000-0x500000 | 0 条 | 无直接调用者 |
| 函数指针表 | 0x10000-0x500000 | 0 条 | 无直接指针 |
| 跳转表分析 | 0x02FA00-0x038000 | 1022 个 | 多为数据，非代码 |
| SUBS #0x5D 指令 | 0x10000-0x500000 | 76 个 | 全部分析，无映射功能 |
| CMP r5,#0xE9 | 0x2D000-0x2E000 | 9 个 | 已确认用途 |
| 字符串表引用 | 整个固件 | 0 条 | 无直接引用 |

### 核心发现

#### ✅ 已确认 (通过独立验证)

1. **Unicode → r5 映射函数** ✅ **已确认 (2026-01-29)**
   - **代码位置**: `0x02D4E6: asrs r5, r7, #2`
   - **映射公式**: `r5 = Unicode >> 2`
   - **验证方法**: Capstone 反汇编
   - **测试字符**: 沨 (U+6CA8) → r5 = 0x1B2A ✅

2. **像素地址计算机制** ❌ **未解决 - 公式验证失败**
   - **公式**: `pixel_ptr = 0x100000 + (Unicode >> 2) * 4`
   - **示例**: 沨 (U+6CA8) → 0x106CA8 ❌
   - **问题**: 0x106CA8 的数据 `80 FB 98 02...` **不匹配**实际像素
   - **实际地址**: 0x466772 的数据 `00 40 F8 27...` **完美匹配** sample_texts/沨.txt
   - **结论**: 公式指向的 0x100000 区域**不是**实际渲染使用的像素数据

3. **特殊编码入口点** ✅ **已确认 (2026-01-29)**
   - **路径**: 0x02DB2C → 0x02DB4E → 0x02DC22
   - **条件**: r4 值决定编码类型
     - r4 == 0x08 → 标准编码 (15列)
     - r4 != 0x08 → 特殊编码 (14列)
   - **验证**: Capstone 反汇编确认分支指令

4. **特殊编码查找公式** ✅ **已确认 (2026-01-29)**
   - **代码**: `0x02DC3E: ldr r6, [r0, #0x14]` 其中 r0 = r5 * 2
   - **公式**: `metadata_ptr = [base + (Unicode >> 2) * 2 + 0x14]`
   - **❓ 未解决**: base 地址的值

5. **0x2D680 死代码确认** ✅ **已确认 (2026-01-29)**
   - **代码**: `0x2DA80: b #0x2d3e8` (无条件跳转)
   - **结果**: 0x2DA84-0x2DA8E 是不可达的死代码
   - **搜索**: 0 条引用到 0x2DA84

3. **渲染函数内部逻辑** (0x2DA62-0x2DC00)
   - r5 从 r4 提取: `r5 = (r4 << 4) >> 16`
   - r6 从 r4 提取: `r6 = (r4 << 4) >> 29`
   - 0xE9 阈值检查: `r5 < 233` vs `r5 >= 233`

4. **Rockchip SDK 确认**
   - 固件头部: "Rockchip RKnano SDK 1.0"
   - 0x45BB11F0 可能是 SDK 虚拟地址编码

5. **字符串表特性**
   - 位置: 0x79B084
   - 编码: UTF-16 BE
   - 内容: "Music Playback" 等 UI 字符串
   - 无直接代码引用

#### ❌ 已证伪的错误假设

| 错误假设 | 正确答案 | 证据 |
|----------|----------|------|
| `U+6CA8 → r5=0x0FDE` | `U+6CA8 → r5=0x1B2A` | 反编译验证 |
| `subs r0, #0x5d` 映射 Unicode | `asrs r5, r7, #2` | 代码追踪 |
| `offset()` 函数公式 | `r5 = Unicode >> 2` | 数据拟合 vs 代码证据 |
| `r6 = 0x100000 + r5 × 4` 计算代码 | r6 通过 LDM 加载 | 未找到计算代码 |

#### ❌ 未找到核心组件

1. **Unicode → r4 参数的映射代码** (可能不需要，因为已找到 Unicode → r5)
2. **渲染函数的调用者**
3. **0x13E024 的实际功能** (已确认与 Unicode 映射无关)

---

## 分析方法论变更 ⚠️ 重要

之前的分析存在问题：**过度依赖数据观察，缺少代码证据追踪**。

### 错误做法
```
发现数据 → 观察模式 → 推导公式 → 搜索"匹配"指令 → 假设即证明 ❌
```

### 正确做法
```
已知代码点 → 追踪数据流 → 确认每一步 → 只文档化能证明的东西 ✅
```

### 证据等级
| 等级 | 描述 | 标记 | 示例 |
|------|------|------|------|
| 代码确认 | 有完整证据链 | ✅ 已确认 | r6 通过 LDM 加载 |
| 指令存在 | 找到指令但功能未知 | ⚠️ 指令存在 | `subs r0, #0x5d` @ 0x13E024 |
| 数据存在 | 找到数据但用途未知 | ⚠️ 数据存在 | 语言表 @ 0x778000 |
| 数据观察 | 从数据反推的模式 | ⚠️ 从数据反推 | U+6CA8 → r5=0x0FDE |
| 理论假设 | 未验证的理论 | ❓ 假设 | offset() 函数公式 |
| 已证伪 | 有证据证明不正确 | ❌ 已证伪 | `r6 = 0x100000 + r5 × 4` |

**详见**: [方法论经验教训](./METHODOLOGY_LESSONS.md)

---

---

## 概述：从 Unicode 到渲染的完整流程

```
Unicode 输入
    ↓
阶段 1: Unicode → r5 映射
    ↓
阶段 2: r5 → r6 (像素数据指针)
    ↓
阶段 3: 编码类型判定 (Bit 7 测试)
    ↓
阶段 4: 像素数据加载
    ↓
阶段 5: 渲染到显示缓冲区
```

---

## 阶段 1: Unicode → 像素数据地址映射

### ⚠️ 当前状态 (2026-01-29)

**状态**: 数据结构已确认，地址计算机制部分理解

#### ✅ 已确认：像素数据结构

**结构**: 6 字节 metadata + 32 字节像素 = 38 字节/字符

**验证** (沨 U+6CA8 @ 0x466772):
```
0x46676C: 22 04 21 04 90 FC  <-- Metadata (6 bytes)
0x466772: 00 40 F8 27...     <-- Pixel data (32 bytes)
```

像素数据 `00 40 F8 27...` 与从 `sample_texts/沨.txt` 编码的数据**完全匹配**。

#### ✅ 已确认：Unicode 步进

**步进**: 33 字节/Unicode code point（注意：不是 38！）

这意味着字符数据是稀疏存储的（每 Unicode code point 对应 33 字节，但每个字符实际占用 38 字节）。

**验证** (氵部连续字符):
```
沨 U+6CA8 @ 0x466772
沪 U+6CAA @ 0x4667B4
Difference: 0x42 = 66 bytes = 2 × 33 ✓
```

#### ✅ 已确认：区域公式（仅氵部）

**0x46xxxx 范围（氵部 U+6C70-U+6CF0）**:
```
addr = 0x46603A + (Unicode - 0x6C70) × 33
```

验证：
```
沨 U+6CA8:
  addr = 0x46603A + (0x6CA8 - 0x6C70) × 33
       = 0x46603A + 0x438
       = 0x466772 ✓
```

#### ❓ 未解决：地址计算代码位置

**问题**: 公式 `addr = base + (Unicode - first) × 33` 在代码的哪里计算？

**搜索结果**:
- ❌ 未找到包含 0x46xxxx 地址的数据表
- ❌ 未找到执行 `× 33` 计算的代码
- ❌ r6 寄存器（像素数据指针）的来源未追踪到

#### 🔴 高优先级问题

1. **r6 寄存器来源**: `0x2DB58: ldrh r2, [r6, #6]` 从 r6+6 加载像素，但 r6 如何被设置？
2. **多区域基地址**: 0x44xxxx, 0x46xxxx, 0x4Axxxx, 0x4Cxxxx 各自有不同的基地址，选择规则？
3. **地址计算机制**: 是查找表还是计算？如果是计算，代码在哪里？

---

### ❌ 已证伪的错误假设（历史记录）

以下假设已被反编译验证证伪：

| 错误假设 | 正确答案 | 为什么错误 |
|----------|----------|-----------|
| `U+6CA8 → r5=0x0FDE` | `U+6CA8 → r5=0x1B2A` | 从暴力搜索反推，不是代码计算 |
| `高字节: 0x6C → 0x0F (差值 0x5D)` | `r5 = Unicode >> 2` | 数据拟合，无代码证据 |
| `offset(u_lo) = 复杂公式` | `r5 = Unicode >> 2` | 数据拟合，无代码证据 |
| `subs r0, #0x5d` 映射指令 | `asrs r5, r7, #2` | r2 追踪显示与 Unicode 无关 |

**相关文档**: [UNICODE_TO_R5_DISCOVERY.md](../03_CODE_ANALYSIS/UNICODE_TO_R5_DISCOVERY.md)

---

## 🔴 剩余核心问题 (2026-01-29 批判性验证后)

### ⚠️ 函数指针表验证: 部分确认 (2026-01-29)

**用户假设**: Entry 44-52 包含 CJK 处理函数指针

**验证结果**:
```
✓ 0x089000: ldr r7, [pc, #0x3d0]  (有效代码)
✓ 0x089000: ldrh r0, [r6, #0x32]   (类似 CJK 模式)
? 0x088F00: 代码结构不一致
✗ Entry 9: 包含随机数据，不像函数指针
```

**结论**:
- ✓ 部分确认: 0x089000-0x089600 区域包含有效代码
- ✗ 假设问题: Unicode 高字节映射机制未找到
- ❓ 未解决: 氵部字符 (U+6Cxx) 使用哪个处理函数？

---

### 🔴 优先级 1: r6 计算源头的追踪 (2026-01-29)

**问题**: r6 = 0x466746 是如何计算的？

**已验证**:
- 步进: 33 字节/Unicode code point ✓
- 重叠存储: 44字节偏移 > 33字节步进 ✓
- r6 来源: `[sp + 0xB4]` ✓

**验证 0x02DDDC (调度器假设)**:
```
0x02DDDC: push {r3, r6, lr}  ✓ 函数入口
未找到写入 [sp + 0xB4] 的 STR 指令 ✗
```

**新发现: 0xE9 阈值矛盾**:
```
0x2DD38: cmp r5, #0xe9  (r5 = Unicode >> 2)
氵 U+6C70: r5 = 6940 >> 0xE9 ✗
```

**结论**: 0xE9 不是区分 CJK 的标准

---

### 🔴 优先级 1: r6 计算源头的追踪 (2026-01-29 更新)

**问题**: r6 = 0x466746 是如何计算的？

**已验证**:
- 步进: 33 字节/Unicode code point ✓
- 重叠存储: 44字节偏移 > 33字节步进 ✓
- r6 来源: `[sp + 0xB4]` ✓

**验证 0xE9 阈值假设**:
```
✓ 确认: 0xE9 (233) 是二元分流器
  - r5 < 0xE9: ASCII/Latin-1 路径 (U+0000 - U+03A3)
  - r5 >= 0xE9: CJK 路径 (U+03A4+ 包括所有 CJK 字符)

验证: 氵 U+6C70: r5 = 6940 >> 0xE9 ✓ 走 CJK 路径
```

**双分支点发现**:
```
位置 1: 0x2DD38: cmp r5, #0xe9
       0x2DD3A: bne.w #0xef928  <- (解码可能错误)

位置 2: 0x02DAB4: cmp r5, #0xe9
       0x02DAB6: bne.w #0x032A6a  <- (正确的 CJK 跳转)
```

**追踪 r1 (渲染上下文指针)**:
```
0x2DA84: lsls r1, r6, #0x19  <- r1 = r6 << 25
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  <- 从 r1 加载 r6
```

**验证地址即索引假设**:
```
假设: 处理函数 = 0x08 + HighByte + 00
验证: 0x086C00 (氵部 U+6Cxx)
结果: 包含有效代码，但没有 CJK 模式 (ldrh [r6, #offset])
结论: ✗ 假设不成立，需要其他映射机制
```

**待解决**:
1. 谁写入 `[sp + 0xB4]` 的像素指针？
2. Unicode 高字节如何映射到处理函数？
3. r6 = 0x466746 的完整计算公式？

---

### 🔴 优先级 1: Unicode 映射机制突破 (2026-01-29)

**✓ 确认: Entry 108 对应 U+6Cxx (氵部)**

```assembly
Entry 108 @ 0x0806C0:
  [+0x00] 0x1C3C -> 0x081C3C ✓ 有效代码
  [+0x02] 0x5C7C -> 0x085C7C ✓ 有效代码
  [+0x04] 0xA0C0 -> 0x08A0C0 ✓ 有效代码
```

**验证 0x081C3C 处理函数**:
```assembly
0x081C3C: ldrh r4, [r6, #2]  ← 包含 CJK 模式!
0x081C3E: subs r1, #0x49
0x081C40: adds r6, #0x48  ← r6 += 72
0x081C42: lsls r0, r5, #1
0x081C44: ble #0x81c36
0x081C46: b #0x82244       ← 跳转到其他代码
```

**深度分析 0x081C3C**:
- 函数非常短（约 10 条指令）
- 没有找到基址加载 (LDR [PC, ...])
- 没有找到 MUL 或 (x << 5) + x 模式
- `ldrh r4, [r6, #2]` 可能是在查表
- `adds r6, #0x48` (r6 += 72) 调整 r6 指针

**❌ 未验证的假设**:
- ✗ 基址硬编码在 0x081C3C 内部
- ✗ MUL/LSL #5 计算模式
- ✗ 33字节步进的直接计算

**新发现**:
- 0x081C10 也有相同的 `ldrh r4, [r6, #2]` 模式

---

### 🔴 0x02DDDC 调度器验证 (2026-01-29)

**用户假设**: 0x02DDDC 是真正计算 r6 的调度器

**验证结果**:
```assembly
0x02DDDC: push {r3, r6, lr}        <- 调度器入口
0x02DDDE: ldr r7, [pc, #0x3c0]     <- 加载常量
0x02DDE2: lsls r0, r5, #5         <- r0 = r5 << 5 (x32)
0x02DDE6: adds r0, r4, r0          <- r0 = r4 + r0
0x02DDEE: ldrh r2, [r0, #0x1a]    <- 从 r0+0x1A 加载
0x02DDF2: strh r2, [r3, #8]       <- 存储
```

**关键发现**:
1. ✓ 确认 `LSLS r5, #5` (x32) 指令存在
2. ✓ 发现 `ADDS r0, r4, r0` 指令（加法）
3. ✓ 发现 LDRH 加载指令（查表？）
4. ✗ 未找到完整的 r0 = r0 + r5 (x*33) 模式

**0x02D270 地址计算区域**:
```assembly
0x2D270: lsrs r1, r4, #0xc
0x2D272: lsls r0, r4, #4
0x2D274: lsls r0, r6, #0xf
0x2D276: ldrb r0, [r7, r3]
```

**46 10 模式发现**:
- 0x02D270-0x02D370 区域包含重复的 `46 10` 模式
- 格式: `f00ef873220121054610`
- 变体: `22012105`, `22012106`, `22012107`...
- 可能是地址表或编码的指针列表

**结论**:
- ✓ 0x02DDDC 确实是调度器，包含地址计算逻辑
- ⚠️ 0x02D270 可能包含地址查找表
- ✗ 基址 0x46603A 未在固件中找到（可能通过计算得出）

---

### ✅ base + (index << 5) 模式验证 (2026-01-29)

**发现的第二个调度器**: 0x039A2E

```assembly
0x039A2E: lsls r2, r0, #5   ; r2 = r0 << 5 (x32)
0x039A30: adds r7, r7, r2   ; r7 = r7 + r2
```

**计算公式**:
```
r7 = r7 + (r0 << 5)
   = base + (index << 5)
   = base + (index × 32)
```

**两个调度器的对比**:

| 调度器 | 公式 | 用途 |
|--------|------|------|
| 0x02DDDC | `r0 = r4 + (r5 << 5)` + 0x1A offset | 像素数据指针查找 |
| 0x039A2E | `r7 = r7 + (r0 << 5)` | 类似的表查找 |

**关键发现**:
1. ✓ 两个调度器都使用相同的 `base + (index << 5)` 模式
2. ✓ 步长是 32 字节 (不是 33)
3. ? 基址来源仍然未知

**与 33 字节步长的关系**:
- 代码使用 `<< 5` (×32) 而不是 ×33
- 可能的解释：
  1. 数据实际步长是 32 字节
  2. 或者 33 字节是通过其他机制实现的

---

### ⚠️ 像素地址计算机制验证 (2026-01-29)

**验证方法**: 搜索像素地址 0x466772 (沨) 和基地址 0x46603A

**搜索结果**:
- ✗ 未找到 0x466772 直接存储
- ✗ 未找到 0x46603A 直接存储
- ✗ 未找到移位后的版本 (0x2333B9)

**关键结论**: **像素数据地址是通过计算得出，不是查找表**

**计算公式** (已验证):
```
像素地址 = 基地址 + (Unicode - 起始Unicode) × 33

氵部 (U+6C70-U+6CF0):
  裸基地址 = 0x466020
  有效基地址 = 0x46603A (0x466020 + 0x1A)
  像素地址 = 0x466020 + (Unicode - 0x6C70) × 33 + 0x1A

验证: 沨 U+6CA8
  = 0x46603A + (0x6CA8 - 0x6C70) × 33
  = 0x46603A + 0x738
  = 0x466772 ✓
```

**未解决的关键问题**:
1. ✅ **基地址 0x466020 来源已部分确认** (2026-01-29 验证)
   - **裸基地址**: 0x466020
   - **有效基地址**: 0x46603A (0x466020 + 0x1A)
   - ✅ 通过像素数据模式搜索验证通过
   - ❌ 0x466020 未在固件中直接存储（可能是计算得出）
   - 可能计算: `0x460000 + (0x6C << 8) - 0xBE0` = 0x466020

2. ⚠️ **×33 计算机制待验证**
   - 用户假设: `r4 + (r5 << 5)` = `×33` (如果 r4 == r5)
   - 代码分析: r4 和 r5 在 0x02DDDC 中有不同用途
   - 反汇编显示: `ldrh r4, [r3, r4]` vs `movs r2, r5`
   - 需要更完整的追踪确认

3. ❓ **Entry 值与基地址的关系**
   - Entry 108 (0x0806C0) 对应 U+6Cxx
   - Entry 108 包含函数指针 0x1C3C → 0x081C3C ✓
   - 其他值 (0x5C7C, 0xA0C0 等) 的用途未确定
   - 可能用于其他计算（如基地址计算）

---

### ✅ 用户假设验证结果 (2026-01-29)

**假设 1: `r4 + (r5 << 5)` = `×33` (修正版)**
- 用户修正: `r4 = Base + Index` (预先计算)
- 公式: `(Base + Index) + (Index << 5)` = `Base + Index × 33`
- 数学验证: ✅ **公式正确**
  ```
  0x466058 + 0x700 = 0x466758 ✓
  (Base + 56) + (56 << 5) = Base + 56 × 33
  ```
- 代码验证: ⚠️ **待确认** r4 在 0x02DDDC 中是否等于 `Base + Index`

**假设 2: 基地址是 0x466020**
- 验证方法: 搜索像素数据模式 `00 40 F8 27`
- 验证结果: ✅ **确认基地址是 0x466020**
- 计算验证: `0x466020 + 56 × 33 + 0x1A = 0x466772` ✓

**基地址计算公式** (用户提出):
- `Base = 0x460000 + (HighByte << 8) - 0xBE0`
- 验证: `0x460000 + 0x6C00 - 0xBE0 = 0x466020` ✓
- 0xBE0 常量在固件中找到 54 个，但未找到作为立即数使用的指令

**×33 计算机制验证** (2026-01-29):
```
数学公式: (Base + Index) + (Index << 5) = Base + Index × 33
验证通过: (0x466020 + 56) + (56 << 5) = 0x466758 ✓
```

**代码实现分析**:
- 0x02DDDC 函数接收 r4 作为参数（预先计算）
- 0x02DDE2: `lsls r0, r5, #5` -> r0 = Index × 32
- 0x02DDE6: `adds r0, r4, r0` -> r0 = r4 + (Index × 32)
- **待确认**: r4 在调用 0x02DDDC 之前是否被设置为 `Base + Index`

**代码追踪结果**:
- 0x02DDDC 立即跳转到 0x2DE3C
- r4 是从调用者传递的参数
- 找到 `str r4, [sp, #0x3e4]` @ 0x02D212（栈写入）
- 0x2DE3C 包含像素操作指令 (`ldrh`, `ldm`)

**用户假设验证** (2026-01-29):
1. **0xBE0 = 95 × 32**: ✓ 计算正确
   - 95 = 可打印 ASCII 字符数
   - 32 = 符号表条目大小
   - 但边界数据 (0x465440) 不像 ASCII 字符序列

2. **r4 从栈加载**: ⚠️ 部分确认
   - 找到 `str r4, [sp, #0x3e4]` @ 0x02D212
   - 距离 0x02DDDC 有 3018 字节
   - 需要确认是否是调用链的一部分

3. **0x2DE3C 是像素填充循环**: ✓ 部分确认
   - 包含 `ldrh r7, [r7, #0x24]` 和 `ldrh r4, [r3, r4]`
   - 使用 r0 进行存储操作 (`strb r7, [r0, #1]`)

**假设 3: 0x1A 是结构体偏移**
- 验证结果: ✅ 0x466020 + 0x1A = 0x46603A
- 用途: 跳过元数据，指向像素数据
- 两个位置可能是不同的代码路径或循环迭代
0x081C40: adds r6, #0x48
```

**结论**: Entry 108 确实包含 U+6Cxx 的处理函数指针 ✓

**❌ 未找到的计算模式**:
- (x << 5) + x (x * 33) 模式 ✗ 未找到
- MUL/MLA 指令 ✗ 未找到
- STR [rX, #0x0C] (写入 r6) ✗ 未找到
- Flash 基址加载 (0x44xxxx) ✗ 未找到

**待解决**:
1. r6 = 0x466746 的计算公式是什么？
2. 33 字节步进如何实现（查找表还是计算）？
3. 基地址 0x46xxxx 如何确定？
```
0x2DA84: lsls r1, r6, #0x19  <- r1 = r6 << 25
0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}  <- 从 r1 加载 r6
```

**验证地址即索引假设**:
```
假设: 处理函数 = 0x08 + HighByte + 00
验证: 0x086C00 (氵部 U+6Cxx)
结果: 包含有效代码，但没有 CJK 模式 (ldrh [r6, #offset])
结论: ✗ 假设不成立，需要其他映射机制
```

**待解决**:
1. 谁写入 `[sp + 0xB4]` 的像素指针？
2. Unicode 高字节如何映射到处理函数？
3. r6 = 0x466746 的完整计算公式？

---

### 🟡 优先级 2: 栈结构设置 (已降级)

**问题**: 谁写入 `[sp + 0xB4]` 的像素指针？

**状态**: 🟡 优先级降低

**理由**:
- r6 是从父函数传入的参数
- 写入位置在调用者，不是当前函数
- 需要先找到调度器函数

**研究方向**:
- 分析 0x02DDDC 附近的调度逻辑
- 检查函数指针调用模式
- 字符区域边界如何确定？
- 是否使用查找表？

---

### 优先级 3: 特殊编码查找表基地址 (已降级)

**问题**: 特殊编码路径使用的查找表基地址是什么？

**状态**: 🟡 中优先级 (REVSH 证明此路径可能为死代码)

**已确认的公式**:
```assembly
; 0x02DC3E: ldr r6, [r0, #0x14]
; 其中 r0 = r5 * 2 = (Unicode >> 2) * 2
metadata_ptr = [base + (Unicode >> 2) * 2 + 0x14]
```

**⚠️ 注意**: 0x02DC22 路径已通过 REVSH 矛盾证明为死代码

---

### 优先级 4: r4 值的确定机制 (已降级)

**问题**: r4 的值是如何确定的？

**已知**:
- r4 控制编码类型选择
- r4 == 0x08 → 标准编码 (15列)
- r4 != 0x08 → 特殊编码 (14列)

**测试位置**:
```assembly
0x02DB10: lsls r0, r4, #4    ; r0 = r4 << 4
0x02DB12: cmp r0, #0x80       ; 比较 r0 与 0x80
0x02DB2C: bne #0x2db4e        ; 如果 r0 != 0x80, 分支到特殊编码
```

**状态**: ❓ r4 初始值来源未知

### 优先级 3: 特殊编码元数据格式

**问题**: 14列编码的元数据结构与15列有何不同？

**已知**:
- 标准编码: metadata @ [r6 + 6]
- 特殊编码: metadata @ [lookup_result + offset]

**状态**: ❓ 需要找到特殊编码查找表后才能分析

---

### 🎯 CJK 渲染路径突破 (2026-01-29)

**状态**: ✅ **重大突破** - 发现真正的 CJK 渲染路径

#### 验证结果

**CJK 路径入口点**: `0x02DAB6: bne.w #0x032A6A`

```assembly
0x02DAB4: cmp r5, #0xe9
0x02DAB6: bne.w #0x032A6a    ; 如果 r5 != 0xE9，跳转到 CJK 路径
```

**分支逻辑**:
- r5 == 0xE9: fall through (标准 ASCII)
- r5 != 0xE9: jump to 0x032A6A (CJK 字符)

**验证示例**:
- 沨 (U+6CA8): r5 = 0x6CA8 >> 2 = 0x1B2A
- 0x1B2A != 0xE9，跳转到 0x032A6A ✅

#### CJK 渲染代码结构

**位置**: 0x032A6C - 0x032AF0

**关键指令**:
```assembly
0x032A6E: ldr  r1, [r7, #8]      ; 从渲染上下文加载
0x032A7A: pop  {r0, r4, r5, r6, r7} ; 从栈恢复寄存器
0x032A94: ldm  r5, {r0, r1, r2, r5, r6, r7} ; 从栈加载
0x032AB2: cmp  r5, #0xe9         ; 再次检查阈值
0x032ABA: ldrh r0, [r6, #0x2c]  ; 像素数据访问 (offset 0x2C = 44)
0x032AC0: bxns r8              ; 返回
```

#### 关键发现

1. **像素数据偏移**: CJK 路径使用 **0x2C (44字节)** 偏移，不是 6 字节
2. **0x882aa8 是死代码**: 无限循环 `movs r0, r0`
3. **0x34bfe 不是分支目标**: 实际目标是 0x032A6A

#### 44字节头部结构验证 ✅

**验证数据**:
```
沨 U+6CA8:
  r6 = 0x466746 (结构体基址)
  像素数据 = r6 + 0x2C = 0x466772
  验证: firmware[0x466746 + 0x2C] == firmware[0x466772] ✅
```

**步进确认**: **33 字节/Unicode code point**
```
汅 U+6C70 -> r6 = 0x46600E
沤 U+6CA4 -> r6 = 0x4666C2 (差值: 1716 = 52 * 33)
沦 U+6CA6 -> r6 = 0x466704 (差值: 66 = 2 * 33)
沨 U+6CA8 -> r6 = 0x466746 (差值: 66 = 2 * 33)
沪 U+6CAA -> r6 = 0x466788 (差值: 66 = 2 * 33)
```

**数据流追踪**:
```assembly
0x2DA2A: add  r5, sp, #0xa4     ; r5 = sp + 0xA4
...
0x032A7A: pop  {r0, r4, r5, r6, r7}   ; 从栈恢复 r5
0x032A94: ldm  r5, {r0, r1, r2, r5, r6, r7}  ; r6 = [原r5 + 16]
0x032ABA: ldrh r0, [r6, #0x2c]  ; 像素数据访问
```

**结论**: `r6 = [sp + 0xB4]`，栈偏移 0xB4 存储像素数据指针

**相关文档**: [数据流分析](../03_CODE_ANALYSIS/DATA_FLOW_SUMMARY.md)

---

### 问题 1.1: Unicode → r5 映射函数位置 ✅ 已解决

> **注意**: 此问题已解决，上方"已解决"部分包含完整验证结果。

**相关文档**: [Unicode→r5映射分析](../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)

---

### 问题 1.2: offset() 函数 ✅ 已证伪（不需要）

**状态**: ✅ **已证伪 - 不存在此函数**

**结论**: "offset() 函数"是基于数据拟合推导的错误概念。

**正确的映射**: `r5 = Unicode >> 2` (简单的移位操作，不需要复杂的 offset 函数)

---

### 问题 1.3: 偏移表用途 ⚠️ 数据存在，用途未知

**状态**: ⚠️ 找到了数据表，但未找到使用代码

**偏移表 @ 0x14AD6**:
- 16 个 16 位大端序值
- 包含 0x5CCA, 0x5CC9, 0x5CCE 等值
- **未找到访问此表的代码**

**验证数据存在**:
```python
import struct
firmware = open('HIFIEC10_Fixed.bin', 'rb').read()
for i in range(16):
    addr = 0x14AD6 + i * 2
    val = struct.unpack('>H', firmware[addr:addr+2])[0]
    print(f"[{i:2d}] 0x{addr:05X}: 0x{val:04X}")
```

**待解决**:
- 确认此表是否真的用于 Unicode 映射
- 找到访问此表的代码
- 如果未被使用，确认其真实用途

**相关文档**: [Unicode查找表](../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)

---

### 问题 1.4: 其他 Unicode 范围的处理 🟢 低优先级

**当前状态**: ❓ 固件中未找到明显的表

**待解决**: 是否存在 offset 查表？

**相关文档**: [Unicode查找表](../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)

---

### ✅ 问题 1.5: 渲染函数调用机制 ✅ 已验证 (2026-01-29)

**验证方法**: 交叉引用搜索 + Capstone 反汇编

**验证结果**:

1. **0x02DB58 不是函数入口点** ✅
   - 0 次对 0x02DB58 的直接引用
   - 是 FUN_02d500_main_render 的一部分
   - 通过代码流程到达 (fall-through)

2. **0x02D500 函数入口点** ✅
   - 无标准的 PUSH 序言
   - 以 `stm r0!, {r1, r2}` 开始
   - 0 次对 0x02D500 的直接引用

3. **调用链分析**:
   ```
   [Unknown caller] → 0x02D500 → ... → 0x02DB58
   ```

4. **0x02D518: asrs r5, r6, #2** ✅
   - 这是 Unicode >> 2 转换
   - r6 应该包含 Unicode 值
   - 需要追踪 r6 的来源

**结论**: 0x02DB58 不是独立函数，而是 FUN_02d500_main_render 内部的像素加载指令。

**相关文档**:
- [独立验证结果](./SOLUTION_VERIFICATION_2026-01-29.md)

#### 选择器结构完整解析

在 0x2D9D8-0x2D9FC 发现多路径选择器:

| 地址 | 指令 | 目标 | 条件 |
|------|------|------|------|
| 0x2D9D8 | `cbnz r1, #0x2da26` | 0x2DA26 | r1 ≠ 0 |
| 0x2D9EA | `bvs #0x2da42` | 0x2DA42 | Overflow set |
| 0x2D9F0 | `bne #0x2da48` | 0x2DA48 | Not equal |
| 0x2D9F4 | `bmi #0x2da4c` | 0x2DA4C | Negative |
| 0x2D9F6 | `bpl #0x2da4e` | 0x2DA4E | Positive |
| 0x2D9FC | `bvc #0x2da54` | 0x2DA54 | Overflow clear |

#### 已确认的调用链

```
[未知调用者] → 0x2D05C → 0x2D850 → [选择器] → 0x2DA40 → 0x2DA62
```

**更正**: 文档之前声称 0x2D05C → 0x2D84E，实际是 0x2D05C → 0x2D850

#### 剩余问题

| 问题 | 状态 | 说明 |
|------|------|------|
| 谁调用 0x2D05C | 🔴 未找到 | 可能使用计算跳转 (BX/POP {pc}) |
| r1 参数来源 | ✅ 已确认 | `movs r1, #0x7` 在 0x2D834 |
| r7 数据来源 | ✅ 已确认 | LDR r7 从 0x2DC74 加载预编码数据 |
| Unicode → r7 | ✅ 已解决 | 使用预编码表，非实时转换 |

**相关文档**: [R7 渲染上下文](../03_CODE_ANALYSIS/REGISTERS/R7_RENDER_CONTEXT.md), [渲染流程分析](../03_CODE_ANALYSIS/INLINE_RENDERING.md)

---

### 🔴 问题 1.6: 0x2D05C 调用者搜索 (2026-01-29)

**当前状态**: 🔴 未找到调用者 - 可能为死代码

#### 研究概述

为了理解完整的渲染调用链，对包含 0x2D05C 的函数进行了全面的调用者搜索。

#### 函数结构分析

**0x2D03B 函数** (包含 0x2D05C):

```assembly
0x2D03B: push {r3, r4, r5, r6, r7, lr}  ; 函数入口
0x2D03D: ldr r4, [pc, #0xe0]         ; 加载常量池数据
0x2D03F: ldr r3, [r4]                ;
0x2D041: cmp r0, #0x60                ; 检查 r0 参数
0x2D045: pop {r3, pc}                 ; 如果 r0 < 0x96，早期返回
0x2D047-0x2D05C: [继续执行]        ; 如果 r0 >= 0x96
0x2D05C: b #0x2d850                   ; 跳转到渲染设置
```

**函数参数**: r0 (r0 >= 0x96 时到达 0x2D05C)

#### 全面搜索结果

| 搜索方法 | 搜索范围 | 结果 | 说明 |
|----------|----------|------|------|
| 函数指针 (0x2D05C) | 整个 33MB 固件 | **0 匹配** | 无静态指针 |
| 函数指针 (0x2D03C) | 整个 33MB 固件 | **0 匹配** | Thumb 模式 |
| BL/BLX 到 0x2D05C | 0x10000-0x500000 | **0 条** | 无直接调用 |
| BL/BLX 到 0x2D03B | 0x10000-0x500000 | **0 条** | 无直接调用 |
| B 指令到 0x2D05C | 0x10000-0x500000 | **0 条** | 无跳转 |
| B 指令到 0x2D03B | 0x10000-0x500000 | **0 条** | 无跳转 |
| TBB/TBH 表分支 | 0x2D000-0x2D03B | **0 条** | 无表分支 |
| 中断向量表 | 向量 0-7 | **0 条** | 无向量指向 |
| BX/BLX 间接跳转 | 0x10000-0x500000 | 5528 条 | 无法静态确定目标 |

#### 最可能的结论：死代码 (Dead Code)

**证据**:
1. 整个 33MB 固件中无任何指向此函数的引用
2. 无直接的 BL/BLX 调用
3. 无函数指针表包含此地址
4. 无中断向量指向此函数
5. 无跳转表或 switch 语句包含此函数

**可能原因**:
- 固件包含多硬件版本的代码
- 为其他型号或版本预留的未使用代码
- 编译器优化未删除的死代码
- 条件编译导致此函数在当前版本中不被调用

#### 剩余研究方向

| 优先级 | 任务 | 方法 | 状态 |
|--------|------|------|------|
| 🟡 中 | 分析 r0 参数语义 | 搜索 r0 >= 0x96 的设置 | 未开始 |
| 🟢 低 | 扩大搜索范围 | 检查 0x500000 之后的代码 | 未开始 |

---

### 问题 1.4: 其他 Unicode 范围的处理 🟢 低优先级

**当前状态**: ❓ 需要更多样本

**待解决**: offset() 函数是否适用于所有 Unicode 范围？

**相关文档**: [Unicode查找表](../04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)

---

## 阶段 2: 像素数据指针 (r6) 追踪

### 🔴 问题 2.1: r6 寄存器来源追踪 (2026-01-29)

**状态**: 🔴 未找到计算代码

#### 已确认的像素加载

```assembly
0x2DB58: ldrh r2, [r6, #6]  ; 从 r6+6 加载像素（跳过6字节metadata）
```

#### 代码追踪结果

**r6 相关指令**:
- `0x2DA64: pop {r3, r5, r6, r7, pc}` - 从栈恢复 r6
- `0x2DA8E: ldm r1!, {r3, r4, r5, r6, r7}` - 从内存加载 r6（但此路径后立即返回）
- `0x2DB14: push {r0, r3, r4, r5, r6, r7}` - 保存 r6

**关键发现**: 在 0x2D000-0x2DB14 范围内**未找到设置 r6 的指令**

#### 地址公式验证

对于氵部字符 (U+6C70-U+6CF0):
```
addr = 0x46603A + (Unicode - 0x6C70) × 33
```

验证通过（沨 U+6CA8 → 0x466772 ✓）

**但问题**: 执行此计算的代码尚未定位。

#### 🔴 核心问题

1. r6 是如何被计算的？
2. 是否存在查找表（未在固件中找到 0x46xxxx 地址）？
3. 代码是否在未搜索的区域？

**相关文档**:
- [R6 像素数据指针](../03_CODE_ANALYSIS/REGISTERS/R6_PIXEL_DATA_POINTER.md)
- [R6 LDM 死代码验证](../06_FAILED_HYPOTHESES/R6_LDM_DEAD_CODE_VERIFICATION.md)

---

## 阶段 1.5: Ghidra 数据流分析 (2026-01-29) 🆕 新发现

### 问题 1.5.1: r5 加载点分析 ⚠️ 部分解决

**状态**: ⚠️ 找到加载点，但数据结构未完全理解

**新发现** (通过 Ghidra 数据流分析):
```assembly
0x2DB90: ldr r5, [0x2DD14]  ; 从 0x2DD14 加载到 r5
```

**0x2DD14 的数据内容**:
```
0x2DD14: F0 11 BB 45 48 06 78 00 28 01 F0 4F 00 00 BF 18
```

作为 32 位指针解读: `0x45BB11F0` (小端序)

**待解决**:
- 0x45BB11F0 是指针还是其他数据？
- 如果是索引表，如何使用？
- 与 Unicode 的映射关系？

**相关文档**: [语言表数据发现](../04_DATA_DISCOVERY/LANGUAGE_TABLE.md)

---

### 问题 1.5.2: 渲染函数数据表分析 ⚠️ 新发现

**状态**: ⚠️ 找到数据表区域，结构未分析

**新发现的 ADR 指令** (在 `func_pixel_load_0x2DB58` 内):
```assembly
0x2DB72: adr r0, #0x3d8    ; r0 = 0x2DF4C
0x2DB7C: adr r0, #0x3d8    ; r0 = 0x2DF58
0x2DB92: adr r0, #0x3d4    ; r0 = 0x2DF68
0x2DBA0: adr r1, #0x3d8    ; r1 = 0x2DF7C
0x2DBAE: adr r0, #0x3d8    ; r0 = 0x2DF84
```

**指向的数据区域**:
- 0x2DF4C-0x2DF84 (约 56 字节)
- 可能是配置表、查找表或映射表

**其他数据加载点**:
```assembly
0x2DB84: ldr r7, [0x2DF48]  ; 从 0x2DF48 加载到 r7
0x2DB8A: ldr r0, [0x2DCA0]  ; 从 0x2DCA0 加载到 r0
```

**待解决**:
- 分析这些数据区域的结构
- 理解它们与字符串渲染的关系
- 追踪数据流到字符串表 (0x79B084)

---

### 问题 1.5.3: UTF-16 字符串处理 ⚠️ 新发现

**状态**: ⚠️ 找到更多候选指令

**新发现的 LDRH 指令**:
```assembly
0x2DB58: ldrh r2, [r6, #6]  ; 像素数据加载 (已知)
0x2DB64: ldrh r0, [r7, #6]  ; UTF-16 候选 (新发现)
0x2FCF4: ldrh r6, [r7, #0xe] ; UTF-16 候选 (已知)
```

**从 1 个增加到 3 个** LDRH UTF-16 候选指令

**待解决**:
- 确认哪些指令真正处理 UTF-16 字符串
- 追踪这些指令的数据流

---

### 问题 1.5.4: 字符串表访问机制 ⚠️ 已确认

**状态**: ⚠️ 确认无直接引用

**Ghidra 直接引用搜索结果**:
| 区域 | 地址范围 | 直接引用 |
|------|----------|----------|
| 语言选择 (UTF-16 BE) | 0x778000-0x779000 | **0** |
| UI 菜单 (UTF-16 LE) | 0x79B084-0x79C000 | **0** |

**结论**: 字符串表不是通过直接地址引用访问的。

**可能的访问机制**:
1. 间接计算: `base + index × scale`
2. 资源 ID/哈希查找
3. 运行时动态加载
4. 函数指针表

---

## 阶段 3: 编码类型判定

### 问题 3.1: 编码类型判定机制 ✅ 已确认 (2026-01-29 独立验证)

**状态**: ✅ 代码已验证

**验证的代码路径**:
```assembly
0x02DB10: lsls r0, r4, #4    ; r0 = r4 << 4
0x02DB12: cmp r0, #0x80       ; 比较 r0 与 0x80
0x02DB2C: bne #0x2db4e        ; 如果 r0 != 0x80, 分支到特殊编码
0x02DB4E: b #0x2dc22          ; 特殊编码入口点
```

**判定逻辑**:
- 如果 r4 == 0x08: 标准编码 (15列)，走 fall-through 路径
- 如果 r4 != 0x08: 特殊编码 (14列)，走 0x02DB4E 分支

**⚠️ 文档更正**: 之前声称是"Bit 7 of metadata"决定编码类型，实际是 r4 值决定。

**❓ 未解决**: r4 的初始值是如何确定的？

**相关文档**:
- [独立验证结果](./SOLUTION_VERIFICATION_2026-01-29.md)
- [R4 符号表指针](../03_CODE_ANALYSIS/REGISTERS/R4_SYMBOL_TABLE.md)

---

### 问题 3.2: 符号表数据的实际用途 ⚠️ 部分理解

**当前状态**: ⚠️ 部分理解

**已知信息**:
- 符号表结构已确认: 偶数=0xCD, 奇数=递增值
- 符号表地址: r4 = r5 × 32
- ldrsb 加载的值在两条路径中都被立即覆盖
- **最可能用途**: 设置 CPU 标志位 (N 标志)

**待解决**:
- 符号表作为动态存储的用途 (str r0, [r4, #4])
- 为什么某些字符有有效符号表数据，其他字符是全零？

**相关文档**: [R4 符号表指针](../03_CODE_ANALYSIS/REGISTERS/R4_SYMBOL_TABLE.md)

---

### 问题 3.3: 14 列编码的像素布局 ❌ 重新研究中

**状态**: ❌ 需要基于代码证据重新分析

**⚠️ 方法论警告**: 之前的分析错误地使用了暴力搜索结果作为"证明"，违反了核心方法论。

**已确认的代码证据**:

1. **编码判定机制** (Capstone 反汇编):
   ```
   0x2DB10: lsls r0, r4, #4      ; r0 = r4 << 4
   0x2DB12: cmp  r0, #0x80       ; 测试 r0 的 Bit 7
   0x2DB2C: bne  #0x2db4e        ; 如果 Bit 7 = 1，跳转
   ```
   - 这是 ✅ 已确认的代码证据

2. **14列路径**:
   - 0x2DB4E: `b 0x2dc22` - 跳转到死代码
   - 这是 ✅ 已确认的代码证据

**未从代码确认的"发现"** (⚠️ 这些都是基于暴力搜索的观察，不是代码证明):

- ❌ 像素数据位置公式 `r6 + 6 = 0x100000 + r5 × 4 + 6`
- ❌ 像素数据格式 "16位 Little-Endian 值"
- ❌ 像素布局 "直接取低14位" 或 "REVSH 后取低14位"
- ❌ 暴力搜索找到的位置 0x466730 等

**待解决**:
- 从代码入口点追踪 r6 寄存器的计算过程
- 确认像素数据的实际加载和使用方式
- 理解 14 列编码的实际渲染机制

**相关文档**: [14列编码像素布局](../04_DATA_DISCOVERY/14COL_PIXEL_LAYOUT.md) (⚠️ 内容需要修订)

---

## 阶段 4: 像素数据加载

### ✅ 已确认: 像素数据格式 (2026-01-29)

**状态**: ✅ 已通过实际数据验证

#### 像素数据结构

```
+0:  Metadata (6 bytes)
+6:  Pixel Data (32 bytes = 16 行 × 2 字节/行)
```

**验证** (沨 U+6CA8 @ 0x466772):
```
0x46676C: 22 04 21 04 90 FC  <-- Metadata (6 bytes)
0x466772: 00 40 F8 27...     <-- Pixel data (32 bytes)
```

像素数据 `00 40 F8 27 08 24 28 04 28 8E 48 4D 48 55 88 14...` 与从 `sample_texts/沨.txt` 编码的数据**完全匹配**。

#### 代码证据

```assembly
0x2DB58: ldrh r2, [r6, #6]  ; 从 r6+6 加载像素（跳过6字节metadata）
```

这条指令确认了 metadata 占用 6 字节。

#### Unicode 步进

**步进**: 33 字节/Unicode code point（注意：不是 38！）

这意味着字符数据是稀疏存储的：
- 每个字符结构 = 38 字节（6 + 32）
- 但 Unicode 步进 = 33 字节
- 差值 5 字节可能表示某种共享或稀疏存储机制

**验证** (氵部连续字符):
```
沨 U+6CA8 @ 0x466772
沪 U+6CAA @ 0x4667B4
Difference: 66 bytes = 2 × 33 ✓
```

---

### 问题 4.1: r2 寄存器用途 ⚠️ 部分理解

**当前状态**: ⚠️ 部分理解

**已知信息**:
- r2 作为函数参数传入
- r2 = r0 (保存计算结果) 用于 bit 7 测试
- subs r2, r7, 7: 从渲染上下文基址减去 7

**待解决**:
- subs r2, r7, 7 的目的 (为什么是 7？)
- r2 作为函数参数的精确含义

**相关文档**: [R2 参数](../03_CODE_ANALYSIS/REGISTERS/R2_PARAMETER.md)

---

### 问题 4.2: r3 寄存器用途 ⚠️ 部分理解

**当前状态**: ⚠️ 部分理解

**已知信息**:
- r3 作为函数参数传入
- lsls r3, r3, #0x10: 16 位左移 (行计数)
- strh r3, [r7, #0xe]: 存储到 r7+0xe

**待解决**:
- r3 的初始值是什么？
- 移位操作目的 (左移 16 位、右移 2 位)
- r7+0xe 存储位置的作用

**相关文档**: [R3 行索引](../03_CODE_ANALYSIS/REGISTERS/R3_ROW_INDEX.md)

---

### 问题 4.3: r0 寄存器在初始化阶段的计算目的 ⚠️ 部分理解

**当前状态**: ⚠️ 部分理解

**已知信息**:
- Bit 7 测试机制已确认
- 像素数据加载已确认

**待解决**:
- 初始化阶段的计算目的 (eor/lsrs/lsls 组合的意义)
- 符号扩展加载的实际用途

**相关文档**: [R0 Bit 7 测试](../03_CODE_ANALYSIS/REGISTERS/R0_BIT7_TEST.md)

---

### 问题 5.2: 语言表引用 🟢 低优先级

**当前状态**: ❓ 未找到直接指针

**待解决**:
- 未找到引用语言表的代码
- 未确定语言切换如何影响字体渲染

**相关文档**: [语言表发现](../04_DATA_DISCOVERY/LANGUAGE_TABLE.md)

---

## 阶段 6: 缺失数据

### 问题 6.1: 4 个缺失字符的像素数据 ⚠️ 部分解决

**当前状态**: ⚠️ 位置已找到，但正确提取方法仍需研究

**核心发现**: 所有4个字符的像素数据都存在于固件中！

**已确认的位置**:

| 字符 | Unicode | 位置 | VERIFICATION_DATA |
|------|---------|------|-------------------|
| 沨 | U+6CA8 | **0x466772** | 0x4666AC ✗ |
| 沤 | U+6CA4 | **0x4666EE** | 0x4666EE ✓ |
| 沦 | U+6CA6 | **0x466730** | 0x466730 ✓ |
| 沪 | U+6CAA | **0x4667B4** | 0x4667B4 ✓ |

**重要警告**: `legacy/extract_fonts_correct.py` 的提取方法是**错误的**，会导致图片撕裂。真正的渲染方法需要基于反编译证据确定。

**待解决**:
- 确定真正的像素提取方法（基于反编译证据）
- 理解15列vs 14列编码的实际差异
- 解决撕裂问题的根源

**相关文档**: [4个字符像素数据分析 - 最终结论](../04_DATA_DISCOVERY/MISSING_CHARS_FINAL_ANALYSIS.md)

---

## 按优先级排序 (2026-01-29 更新)

| 优先级 | 问题 | 阶段 | 状态 |
|--------|------|------|------|
| 🔴 高 | 特殊编码查找表基地址 | 3 | ❓ base 地址未知 |
| 🔴 高 | r4 值的确定机制 | 3 | ❓ 来源未知 |
| 🔴 高 | 特殊编码元数据格式 | 3 | ❓ 需要先找查找表 |
| 🟡 中 | 标准编码像素数据地址 | 2 | ✅ 公式已验证 |
| 🟡 中 | 符号表实际用途 | 3 | ⚠️ 部分理解 |
| 🟢 低 | 路径A (r7 ^ 0x28) 用途 | 1 | 需要理解 |

**关键变更**:
- ✅ 标准编码公式已验证: `pixel_ptr = 0x100000 + (Unicode >> 2) * 4`
- ✅ 编码判定机制已验证: r4 值决定编码类型
- 🔴 新增优先级: 特殊编码查找表基地址（核心未解决问题）

---

## ✅ 已确认的事实 (2026-01-29 独立验证)

| 事实 | 验证方法 |
|------|----------|
| **Unicode → r5 映射**: `r5 = Unicode >> 2` @ 0x02D4E6 | Capstone 反汇编 ✅ |
| **标准编码像素地址**: `0x100000 + (Unicode >> 2) * 4` | Capstone + 数据验证 ✅ |
| **编码判定**: r4 值决定编码类型 (0x08=标准, 其他=特殊) | Capstone 反汇编 ✅ |
| **特殊编码入口**: 0x02DB2C → 0x02DB4E → 0x02DC22 | Capstone 反汇编 ✅ |
| **特殊编码查找**: `[r0 + 0x14]` 其中 r0 = r5 * 2 | Capstone 反汇编 ✅ |
| **死代码确认**: 0x2DA80 = B #0x2D3E8 (不可达) | Capstone + 搜索 ✅ |
| **查找表 0x080000**: 128条目 × 16字节, Entry 1 = "Charging" | Capstone + 数据验证 ✅ |
| **像素数据结构**: 6字节metadata + 32字节像素 | 实际数据对比 sample_texts |
| **像素加载**: `ldrh r2, [r6, #6]` @ 0x02DB58 | Capstone 反汇编 |
| **Unicode步进**: 33字节/code point | 多字符地址验证 |
| **路径A指令**: `eor r0, r7, #0x28` @ 0x2DA94 | Capstone 反汇编 |

---

## ❌ 已证伪的错误假设 (2026-01-29 独立验证)

| 错误假设 | 正确答案 |
|----------|----------|
| `U+6CA8 → r5=0x0FDE` (暴力搜索反推) | `U+6CA8 → r5=0x1B2A` (Unicode >> 2) ✅ |
| `r5 = Unicode >> 2` 指向实际像素(0x466772) | 标准编码路径指向 0x106CA8 ✅ |
| **0x2D680 是查找表访问点** | 0x2D680 是**死代码** (0x2DA80 = B #0x2D3E8) ❌ |
| **Bit 7 of metadata 决定编码类型** | **r4 值决定编码类型** (r4 == 0x08 → 标准) ❌ |
| 38字节/字符步进 | 实际是33字节/code point |
| `沨 像素地址 = 0x466772` | 标准编码: 0x106CA8 ✅ (特殊编码地址待确定) |

---

## 研究方向

### 方向 1: 数据流分析
- 从入口追踪所有寄存器到 0x2DB58
- 分析符号表值的实际用途
- 确定显示缓冲区格式

### 方向 2: 字符对比分析
- 对比不同字符的渲染流程
- 分析编码类型选择的实际差异
- 验证 14 列 vs 15 列的实现

你可以使用 angy 进行模拟但是我们没有动态分析工具可用。

---

**参见**:
- [执行摘要](./EXECUTIVE_SUMMARY.md)
- [失败的假设](../06_FAILED_HYPOTHESES/WRONG_ASSUMPTIONS.md)
