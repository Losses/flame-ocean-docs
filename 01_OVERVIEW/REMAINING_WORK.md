# 未解决问题

**状态**: 📋 进行中
**最后更新**: 2026-01-29

---

## 概述：从 Unicode 到渲染的完整流程

```
Unicode 输入
    ↓
阶段 1: Unicode → r5 映射
    ↓
阶段 2: r5 → r6 (像素数据指针)
    ↓
阶段 3: 编码类型判定 (Bit 7 测试)
    ↓
阶段 4: 像素数据加载
    ↓
阶段 5: 渲染到显示缓冲区
```

---

## 阶段 1: Unicode → r5 映射

### 问题 1.1: Unicode → r5 映射函数位置 🔴 高优先级

**当前状态**: ❓ 未找到映射函数位置

**已知信息**:
- 映射关系已确认: U+6CA8 → r5=0x0FDE, 差值=-0x5CCA
- r5 在 0x2DA8E 通过 `ldm r1!, {r3, r4, r5, r6, r7}` 加载
- 高字节映射: r5_hi = u_hi - 0x5D

**待解决**:
- 映射函数在固件中的哪个位置？
- 是否存在完整的 Unicode 查找表？
- offset() 函数的具体实现是什么？

**相关文档**: [Unicode查找表](../04_DATA_DISCOVERY/UNICODE_LOOKUP_TABLE.md)

---

### 问题 1.2: offset() 函数具体实现 🟡 中优先级

**当前状态**: ❓ 部分匹配

**已知信息**:
- 测试过多个公式，均未达到 100% 匹配
- 偏移值范围: 50-55 (0x32-0x37)

**测试过的公式**:
| 公式 | 匹配度 | 说明 |
|------|--------|------|
| `offset = 0x32 + ((u_lo ^ 0xAA) >> 2)` | 1/4 | 仅匹配 0xAA |
| `offset = 0x32 + ((~idx) & 0x0F) >> 1` | 2/4 | 匹配 0xA4, 0xA6 |
| `offset = 0x32 + ((u_lo & 0x0F) ^ 0x0A) >> 1` | 1/4 | 仅匹配 0xAA |

**相关文档**: [Unicode查找表](../04_DATA_DISCOVERY/UNICODE_LOOKUP_TABLE.md)

---

### 问题 1.3: 偏移表位置 🟡 中优先级

**当前状态**: ❓ 固件中未找到明显的表

**待解决**: 是否存在 offset 查表？

**相关文档**: [Unicode查找表](../04_DATA_DISCOVERY/UNICODE_LOOKUP_TABLE.md)

---

### 问题 1.4: 其他 Unicode 范围的处理 🟢 低优先级

**当前状态**: ❓ 需要更多样本

**待解决**: offset() 函数是否适用于所有 Unicode 范围？

**相关文档**: [Unicode查找表](../04_DATA_DISCOVERY/UNICODE_LOOKUP_TABLE.md)

---

## 阶段 2: r5 → r6 (像素数据指针)

### 问题 2.1: r6 寄存器追踪 ✅ 已解决

**状态**: ✅ 完全解决

- r6 = 0x100000 + r5 × 4
- 像素数据从 r6 + 6 开始

**相关文档**: [像素数据位置](../04_DATA_DISCOVERY/PIXEL_DATA.md)

---

## 阶段 3: 编码类型判定

### 问题 3.1: r4 寄存器用途 ✅ 已解决

**状态**: ✅ 完全解决

- r4 = 首字节 >> 4
- 编码判定: r4 >= 8 → 特殊编码(14列), r4 < 8 → 标准编码(15列)

**相关文档**: [R4 符号表指针](../03_CODE_ANALYSIS/REGISTERS/R4_SYMBOL_TABLE.md)

---

### 问题 3.2: 符号表数据的实际用途 ⚠️ 部分理解

**当前状态**: ⚠️ 部分理解

**已知信息**:
- 符号表结构已确认: 偶数=0xCD, 奇数=递增值
- 符号表地址: r4 = r5 × 32
- ldrsb 加载的值在两条路径中都被立即覆盖
- **最可能用途**: 设置 CPU 标志位 (N 标志)

**待解决**:
- 符号表作为动态存储的用途 (str r0, [r4, #4])
- 为什么某些字符有有效符号表数据，其他字符是全零？

**相关文档**: [R4 符号表指针](../03_CODE_ANALYSIS/REGISTERS/R4_SYMBOL_TABLE.md)

---

### 问题 3.3: 14 列编码的像素布局 🟡 中优先级

**当前状态**: ⚠️ 部分理解

**已知信息**:
- 14 列编码从 16 位值的前 14 位提取
- 沦字像素数据分析完成
- 渲染机制: Skip+Swap (跳过第 1 字节，交换 odd/even 顺序)

**待解决**:
- 最高 2 位 (Bit 15-14) 的含义
- 字节交换 (revsh) 的精确影响

**相关文档**: [编码规则](../04_DATA_DISCOVERY/ENCODING_RULES.md)

---

## 阶段 4: 像素数据加载

### 问题 4.1: r2 寄存器用途 ⚠️ 部分理解

**当前状态**: ⚠️ 部分理解

**已知信息**:
- r2 作为函数参数传入
- r2 = r0 (保存计算结果) 用于 bit 7 测试
- subs r2, r7, 7: 从渲染上下文基址减去 7

**待解决**:
- subs r2, r7, 7 的目的 (为什么是 7？)
- r2 作为函数参数的精确含义

**相关文档**: [R2 参数](../03_CODE_ANALYSIS/REGISTERS/R2_PARAMETER.md)

---

### 问题 4.2: r3 寄存器用途 ⚠️ 部分理解

**当前状态**: ⚠️ 部分理解

**已知信息**:
- r3 作为函数参数传入
- lsls r3, r3, #0x10: 16 位左移 (行计数)
- strh r3, [r7, #0xe]: 存储到 r7+0xe

**待解决**:
- r3 的初始值是什么？
- 移位操作目的 (左移 16 位、右移 2 位)
- r7+0xe 存储位置的作用

**相关文档**: [R3 行索引](../03_CODE_ANALYSIS/REGISTERS/R3_ROW_INDEX.md)

---

### 问题 4.3: r0 寄存器在初始化阶段的计算目的 ⚠️ 部分理解

**当前状态**: ⚠️ 部分理解

**已知信息**:
- Bit 7 测试机制已确认
- 像素数据加载已确认

**待解决**:
- 初始化阶段的计算目的 (eor/lsrs/lsls 组合的意义)
- 符号扩展加载的实际用途

**相关文档**: [R0 Bit 7 测试](../03_CODE_ANALYSIS/REGISTERS/R0_BIT7_TEST.md)

---

## 阶段 5: 元数据结构

### 问题 5.1: metadata[2], [4], [5] 的功能 🟡 中优先级

**当前状态**: ⚠️ 已确认不在渲染时读取

**已知信息**:
- 已确认这些字节在渲染时不被读取
- 数据对比分析完成
- 可能的解释: 地址偏移/预处理参数/压缩位域

**待解决**:
- 这些字节的具体用途
- 是否与字体编辑工具相关
- 是否是遗留数据

**相关文档**: [元数据分析](../04_DATA_DISCOVERY/METADATA_ANALYSIS.md)

---

### 问题 5.2: 语言表引用 🟢 低优先级

**当前状态**: ❓ 未找到直接指针

**待解决**:
- 未找到引用语言表的代码
- 未确定语言切换如何影响字体渲染

**相关文档**: [语言表发现](../04_DATA_DISCOVERY/LANGUAGE_TABLE.md)

---

## 阶段 6: 缺失数据

### 问题 6.1: 4 个缺失字符的像素数据 🟡 中优先级

**当前状态**: ❓ 未找到实际像素字形数据

**已知信息**:
- 内部索引: 沨=0x0FDE, 沤=0x0FDB, 沦=0x0FDC, 沪=0x0FDA
- 已找到符号表数据
- 未在 Unicode 表中找到

**待解决**:
- 这 4 个字符的像素数据存储在哪里？
- 为什么未在 Unicode 表中找到？

**相关文档**: [调试用字符表](../04_DATA_DISCOVERY/DEBUG_CHARACTER_TABLE.md)

---

## 按优先级排序

| 优先级 | 问题 | 阶段 |
|--------|------|------|
| 🔴 高 | Unicode → r5 映射函数位置 | 1 |
| 🔴 高 | 4 个缺失字符的像素数据 | 6 |
| 🟡 中 | offset() 函数具体实现 | 1 |
| 🟡 中 | 符号表作为动态存储的用途 | 3 |
| 🟡 中 | 14 列编码的像素布局 | 3 |
| 🟡 中 | metadata[2], [4], [5] 的功能 | 5 |
| 🟡 中 | r2 寄存器用途 | 4 |
| 🟡 中 | r3 寄存器用途 | 4 |
| 🟢 低 | 语言表引用 | 5 |
| 🟢 低 | 其他 Unicode 范围的处理 | 1 |
| 🟢 低 | r0 初始化计算目的 | 4 |

---

## 研究方向

### 方向 1: 动态分析
- 使用硬件模拟/调试器追踪执行
- 断点在 0x2D3C6 和 0x2DB58
- 追踪完整的渲染流程

### 方向 2: 数据流分析
- 从入口追踪所有寄存器到 0x2DB58
- 分析符号表值的实际用途
- 确定显示缓冲区格式

### 方向 3: 字符对比分析
- 对比不同字符的渲染流程
- 分析编码类型选择的实际差异
- 验证 14 列 vs 15 列的实现

---

**参见**:
- [执行摘要](./EXECUTIVE_SUMMARY.md)
- [失败的假设](../06_FAILED_HYPOTHESES/WRONG_ASSUMPTIONS.md)
