# 剩余工作与下一步

**状态**: 📋 进行中
**最后更新**: 2026-01-28

---

## 短期目标

### 1. 理解符号表的完整用途 🟡 中优先级

**当前状态**:
- ✅ 符号表结构已确认: 偶数=0xCD, 奇数=递增值
- ✅ 符号表位置: @ (r5 << 5)
- ❓ 0xCD/0xDE... 模式的实际用途

**待解决**:
- 符号字节如何影响像素渲染？
- 是列宽调整还是像素变换参数？

**相关文档**: [元数据分析](./METADATA_ANALYSIS.md)

---

### 2. 定位 4 个缺失字符的像素数据 🟡 中优先级

**当前状态**:
- ✅ 已知内部索引: 沨=0x0FDE, 沤=0x0FDB, 沦=0x0FDC, 沪=0x0FDA
- ✅ 已找到符号表数据
- ❓ 未找到实际像素字形数据

**待解决**:
- 这 4 个字符的像素数据存储在哪里？
- 为什么未在 Unicode 表中找到？

**相关文档**: [调试用字符表](./DEBUG_CHARACTER_TABLE.md)

---

### 3. 完整的像素变换公式 🟡 中优先级

**当前状态**:
- ✅ 符号表用于 ldrsb 指令
- ✅ 编码判定机制已理解
- ❌ 未理解完整的像素变换公式

**待解决**:
- 符号字节如何影响像素渲染？
- 列处理循环的完整逻辑？

**相关文档**: [内联渲染逻辑](../03_CODE_ANALYSIS/INLINE_RENDERING.md)

---

## 长期目标

### 1. 实现 100% 准确的字体提取

**当前状态**:
- ✅ 理解了编码判定 (Bit 7 测试)
- ✅ 理解了符号表结构
- ✅ 理解了像素数据位置
- ❌ 未理解完整的像素变换公式

**待解决**:
- 符号表的完整用途
- 14 列编码的精确实现
- 完整的像素变换公式

---

### 2. 解决 Unicode 映射函数位置

**当前状态**:
- ✅ 已知映射关系: U+6CA8 → r5=0x0FDE, 差值=-0x5CCA
- ✅ r5 在 0x2DA8E 通过 `ldm r1!, {r3, r4, r5, r6, r7}` 加载
- ❓ 未找到映射表/函数位置

**待解决**:
- 映射函数在固件中的哪个位置？
- 是否存在完整的 Unicode 查找表？

**相关文档**: [Unicode查找表](./UNICODE_LOOKUP_TABLE.md)

---

### 3. 理解元数据的完整结构

**当前状态**:
- ✅ metadata[0] Bit 7-4: 编码类型标志
- ✅ metadata[0] Bit 3-0: 不被使用
- ❓ metadata[2], [4], [5] 的功能未知

**待解决**:
- metadata[2] 的功能是什么？
- metadata[4] 的功能是什么？
- metadata[5] 的功能是什么？

**相关文档**: [元数据分析](./METADATA_ANALYSIS.md)

---

## 分析建议

### 优先级排序

| 优先级 | 任务 | 预期难度 |
|--------|------|----------|
| 🔴 高 | 理解符号表用途 | 中 |
| 🔴 高 | 找到 4 个缺失字符的像素数据 | 高 |
| 🟡 中 | Unicode 映射函数位置 | 中 |
| 🟡 中 | 元数据完整结构 | 低 |
| 🟢 低 | 实现字体提取脚本 | 低 |

---

## 研究方向

### 方向 1: 动态分析

- 使用硬件模拟/调试器追踪执行
- 断点在 0x2D3C6 和 0x2DB58
- 追踪完整的渲染流程

### 方向 2: 数据流分析

- 从入口追踪所有寄存器到 0x2DB58
- 分析符号表值的实际用途
- 确定显示缓冲区格式

### 方向 3: 字符对比分析

- 对比不同字符的渲染流程
- 分析编码类型选择的实际差异
- 验证 14 列 vs 15 列的实现

---

**参见**:
- [执行摘要](../01_OVERVIEW/EXECUTIVE_SUMMARY.md)
- [失败的假设](../06_FAILED_HYPOTHESES/WRONG_ASSUMPTIONS.md)
