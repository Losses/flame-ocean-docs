# ECHO MINI V3.1.0 字体渲染分析文档

**固件**: HIFIEC10.IMG / HIFIEC10_Fixed.bin
**架构**: ARM Cortex-M (Rockchip RKnano)
**大小**: 33 MB (0x2000004 字节)
**最后更新**: 2026-01-30

---

## 📖 新手入门：RKnano 字体渲染机制速览

如果要用一句话概括这个系统的字体渲染逻辑，那就是：**这是一个为了节省空间和提高速度，将「静态预编译数据」与「动态计算逻辑」混合使用的双轨制系统。**

我们可以将整个渲染过程想象成一个**图书馆管理员（CPU）**去仓库里找一本书（字符图像）并把它展示在柜台（屏幕）上的过程。

### 第一步：拿到「索书号」 (Unicode → 内部索引)

当系统想要显示一个汉字（比如「沨」，Unicode 编码 U+6CA8）时，管理员并不能直接用这个编码去仓库找，因为仓库里的书不是按 Unicode 排列的。

1. **动态计算路径（普通书）**：对于大多数文本字符，管理员使用一个简单的公式将 Unicode 转换成内部的索引号（r5 寄存器）。
   - 公式：**索引 (r5) = Unicode / 4**（即右移 2 位）
   - 证据：我们在代码 `0x02D4E6` 处找到了指令 `asrs r5, r7, #2`
   - 这意味着系统将字符按 4 个一组进行索引管理

2. **预编译路径（图标与 UI）**：对于界面上的图标或固定状态文字（如电池图标、UI 元素），系统使用的是一套预先写好的小抄（预编码表）。这些数据在出厂时就已经写死在固件里了（位于 `0x2DC70` 区域），不需要实时计算

### 第二步：定位「书架」 (内存地址计算)

拿到索引号 r5 后，管理员需要知道这本书具体在哪个架子上（内存地址 r6）。这也是我们逆向分析中最困难的部分，因为系统似乎有两个仓库：

| 仓库 | 地址 | 描述 |
|------|------|------|
| **仓库 A (RAM)** | `0x100000` | 标准的、原始的字体数据 |
| **仓库 B (Flash)** | `0x440000 - 0x4C0000` | 实际用于显示的数据（暴力搜索找到） |

**关键机制**：管理员并不是从零开始算地址，而是通过一个**「查找表」**。系统会先根据索引号去查一个目录（位于 `0x080000`），目录会告诉管理员该去哪个函数处理这个字符，进而锁定数据的基地址。

### 第三步：打开「书盒」 (数据头部解析)

找到数据地址（r6）后，管理员发现每个字符都包在一个盒子里。**重点来了**：不能直接打开盒子就读，必须先跳过包装纸。

- **跳过元数据**：代码中有一条铁律 `ldrh r2, [r6, #6]`。这意味着每个字符数据的前 6 个字节是元数据（Header），真正的像素图像从第 7 个字节开始。
- **读取说明书（编码判定）**：管理员会看元数据的第一个字节（metadata），根据它的数值决定怎么读书。这是导致「字体撕裂」问题的根源。

### 第四步：阅读内容 (两种编码格式)

**这就是为什么有些字显示正常，有些字会「壞掉」的原因**。系统有两种阅读模式，取决于元数据的高 4 位：

| 模式 | 条件 | 行为 |
|------|------|------|
| **标准模式 (15列)** | 元数据高 4 位 < 8（字节值 < 0x80） | 管理员认为这个字宽 15 个像素点，这是大多数汉字的标准格式 |
| **特殊模式 (14列)** | 元数据高 4 位 >= 8（字节值 >= 0x80） | 管理员认为这个字比较窄，只有 14 个像素宽，系统会执行「字节交换」（revsh 指令）操作 |

**新手误区警示**：之前我们以为所有的「壞字」是因为地址算错了。其实不是，是因为系统错误地判断了编码模式，或者我们在提取字体时强行用 15 列的规则去读 14 列的数据，导致图像错位（撕裂）。

### 第五步：多语言菜单系统 (额外发现)

除了单个汉字的渲染，我们还发现这个系统具备强大的多语言能力：

- 它内部藏着简体中文、繁体中文、英文、日文、韩文甚至丹麦语的完整菜单字符串
- 这些字符串不是随意存放的，而是像军队一样整齐排列的数组，每个条目固定占用 **258 字节 (0x102)**
- 中文用大端序 (Big Endian)，英文用小端序 (Little Endian)

---

### 总结：为什么字体会「壞掉」？

想像一下，你有一本书，规定「单页是文字，双页是图片」。但如果你看书的时候搞错了规则，把双页当文字读，内容就会变成乱码。

RKnano 系统的字体渲染就是这样：
1. 它算出字符在哪里（r5 → r6）
2. 它读取头部的标记（metadata）
3. 如果标记判断错误，或者字库数据本身的标记与实际像素宽度不匹配（例如标记说是 14 列，实际数据却按 15 列存储），屏幕上显示出来的字就会像被撕裂的照片一样错位

我们之前的逆向工作，就是从一堆乱码中，找出了这个隐藏的「14列 vs 15列」的开关规则，并确认了死代码（如 `0x2DC22`）是不需要理会的陷阱。

---

## 快速导航：从零到渲染完整流程

本文档库按照分析流程组织，从发现问题到完全理解渲染机制。按顺序阅读即可掌握整个系统。

---

### 第一阶段：理解问题

如果你想了解**原始问题是什么**，或者**为什么字体提取会出错**：

1. **[问题描述](./01_OVERVIEW/PROBLEM_STATEMENT.md)** - 用户报告的字体问题
   - 小号字体：所有带 `+U` 后缀的字符都是坏字
   - 大号字体：特定文件损坏
   - 观察到的模式：好、坏、好、坏交替出现

2. **[执行摘要](./01_OVERVIEW/EXECUTIVE_SUMMARY.md)** - 核心发现摘要
   - 像素数据位置: `0x100000 + r5 × 4`
   - 编码判定: `metadata[0] >> 4 >= 8`
   - 两条渲染路径的关系

---

### 第二阶段：系统架构

如果你想了解**固件的内存布局**和**数据结构**：

1. **[内存布局图](./02_ARCHITECTURE/MEMORY_MAP.md)** - 固件地址映射
   ```
   0x000000 - 0x460:     Boot Header
   0x100000:              字体数据基址
   0x14AD6:               偏移表
   0x778000:              语言表 (日本語、繁體中文... UTF-16 BE)
   ```

2. **[数据结构定义](./02_ARCHITECTURE/DATA_STRUCTURES.md)** - 关键数据结构
   ```c
   struct character_entry {
       uint16_t pixel_data[16];     // 16 行像素数据 (每行 2 字节)
       uint16_t metadata[16];       // 16 行元数据 (每行 2 字节)
   };
   // 总计: 16 行 × 4 字节 = 64 字节/字符
   // 位置: 0x100000 + char_idx × 64
   ```

3. **[字符串表发现](./04_DATA_DISCOVERY/LANGUAGE_TABLE.md)** - UTF-16 字符串表
   ```
   语言选择 @ 0x778000: 日本語、繁體中文
   UI菜单 @ 0x79B084-0x79C000: 16个英文UI字符串 (Music Playback, Equalizer, Tools...)
   ```
   ⚠️ **注意**: 详见[代码引用搜索记录](./04_DATA_DISCOVERY/LANGUAGE_TABLE.md#第三部分代码引用搜索的详细记录-重要) - 尝试了8种方法未找到访问代码

4. **[寄存器参考](./02_ARCHITECTURE/REGISTER_REFERENCE.md)** - 渲染过程中使用的寄存器
   | 寄存器 | 用途 | 查看文档 |
   |--------|------|----------|
   | r5 | Unicode → 内部索引 | [Unicode→r5映射](./04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md) |
   | r6 | 像素数据指针 ⚠️ 计算公式未找到 | [R6像素数据指针](./03_CODE_ANALYSIS/REGISTERS/R6_PIXEL_DATA_POINTER.md) |
   | r7 | 渲染上下文 / 基址指针 | [数据结构定义](./02_ARCHITECTURE/DATA_STRUCTURES.md) |
   | r4 | 首字节高4位 / 符号表指针 | [内联渲染逻辑](./03_CODE_ANALYSIS/INLINE_RENDERING.md) |
   | r0, r1, r2, r3 | 临时寄存器和参数 | [指令级追踪](./03_CODE_ANALYSIS/INSTRUCTION_TRACE.md) |

5. **[渲染管线总览](./02_ARCHITECTURE/RENDERING_PIPELINE.md)** - 完整渲染流程
   ```
   Unicode → r5映射 → r6计算 → 编码判定 → 像素加载 → 显示缓冲区
   ```

---

### 第三阶段：从 Unicode 到字符数据

如果你想了解**如何从 Unicode 找到字符数据**：

1. **[Unicode→r5映射](./04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md)** → 映射关系
   - 转换代码未找到
   - 观察到的数据模式: U+6CA8 (沨) → r5=0x0FDE
   - 找到 `subs r0, #0x5d` @ 0x13E024，但未确认与 Unicode 的关系

2. **[调试用字符表](./04_DATA_DISCOVERY/DEBUG_CHARACTER_TABLE.md)** → 31个已知字符映射
   - 0x44xxxx 范围: 寸、出、岑、岌、岈
   - 0x46xxxx 范围: 氵部系列 (26个字符)

---

### 第四阶段：代码路径与寄存器分析

如果你想了解**渲染代码如何工作**：

**代码路径**:
1. **[标准路径分析](./03_CODE_ANALYSIS/PATH_0x2DB58_STANDARD.md)** - 主渲染路径
2. **[0x13365E 函数分析](./03_CODE_ANALYSIS/FUNCTION_0x13365E.md)** - 孤立函数 (未被调用)
3. **[特殊路径分析](./03_CODE_ANALYSIS/PATH_0x2DC22_SPECIAL.md)** - 死代码路径
4. **[内联渲染逻辑](./03_CODE_ANALYSIS/INLINE_RENDERING.md)** - 内联代码分析

---

### 🔴 第五阶段：关键缺口分析（最新）

**⚠️ 重要发现** (2026-01-29): 存在数据验证公式与代码证据之间的关键缺口

1. **[关键缺口分析](./05_CURRENT_STATUS/CRITICAL_GAP_ANALYSIS.md)** - **🔴 必读**
   - **已验证公式** (数据证据 ✅):
     - `r5 = Unicode >> 2` - 代码证据位于 0x02D4E6
     - `pixel_addr = 0x100000 + r5 * 4` - 数据验证通过 (沨/婔/福 字符)
   - **缺失代码** (代码证据 ❌):
     - 未找到实现 `pixel_addr = 0x100000 + r5 * 4` 的代码
     - 未找到访问 0x100000 区域的代码
     - 未找到包含 0x106CA8 等像素地址的指针表
   - **可能解释**:
     - 硬件内存映射机制
     - 未分析的代码区域
     - 间接访问机制
     - 运行时代码生成

2. **[假设验证报告](./01_OVERVIEW/HYPOTHESIS_VERIFICATION.md)** - 三种假设的验证结果
   - ✅ 假设 1: `r5 = Unicode >> 2` - **验证正确**
   - ✅ 假设 2: `pixel_addr = 0x100000 + r5 * 4` - **验证正确**
   - ❌ 假设 3: DMA 复制理论 - **证伪**

**寄存器详细分析**:
> **📁 REGISTERS 目录**: [docs/03_CODE_ANALYSIS/REGISTERS/](./03_CODE_ANALYSIS/REGISTERS/) - 包含所有寄存器的完整分析文档

| 寄存器 | 用途 | 文档 |
|--------|------|------|
| r0 | Bit 7 测试、数据加载 | [R0_BIT7_TEST.md](./03_CODE_ANALYSIS/REGISTERS/R0_BIT7_TEST.md) |
| r2 | 函数参数、Bit 7 测试载体 | [R2_PARAMETER.md](./03_CODE_ANALYSIS/REGISTERS/R2_PARAMETER.md) |
| r3 | 行索引、偏移量 | [R3_ROW_INDEX.md](./03_CODE_ANALYSIS/REGISTERS/R3_ROW_INDEX.md) |
| r4 | 编码判定、符号表指针 | [R4_SYMBOL_TABLE.md](./03_CODE_ANALYSIS/REGISTERS/R4_SYMBOL_TABLE.md) |
| **r5** | **字符内部索引** | [R5_CHARACTER_INDEX.md](./03_CODE_ANALYSIS/REGISTERS/R5_CHARACTER_INDEX.md) |
| **r6** | **像素数据指针 ⚠️** | [R6_PIXEL_DATA_POINTER.md](./03_CODE_ANALYSIS/REGISTERS/R6_PIXEL_DATA_POINTER.md) ⚠️ **需更正**: 之前分析基于死代码，实际使用 r4 << 16 |
| **r7** | **渲染上下文基址** | [R7_RENDER_CONTEXT.md](./03_CODE_ANALYSIS/REGISTERS/R7_RENDER_CONTEXT.md) |

10. **[指令级追踪](./03_CODE_ANALYSIS/INSTRUCTION_TRACE.md)** - 综合追踪

---

### 第五阶段：数据发现

如果你想了解**像素数据在哪里**和**编码规则**：

1. **[像素数据位置](./04_DATA_DISCOVERY/PIXEL_DATA_LOCATION.md)** ✅ **已验证** (2026-01-29 更新)
   ```
   符号表基址: 0x100000
   每字符: 64 字节 (16 行 × 4 字节/行)
   像素数据: 每行前 2 字节
   寻址: 字符 N = 0x100000 + N × 64
   ```

2. **[编码规则](./04_DATA_DISCOVERY/ENCODING_RULES.md)** - 标准 vs 特殊编码
   - 标准 (15列): `metadata[0] >> 4 < 8`
   - 特殊 (14列): `metadata[0] >> 4 >= 8`

3. **[14列编码像素布局](./04_DATA_DISCOVERY/14COL_PIXEL_LAYOUT.md)** ✅ **新增**
   - 基于固件逆向工程的完整分析
   - Capstone 反汇编证据
   - 像素提取方法（含沦字数据分析）

3. **[4个字符像素数据分析](./04_DATA_DISCOVERY/MISSING_CHARS_FINAL_ANALYSIS.md)** ✅ **已解决**
   - 沨、沤、沦、沪的像素数据位置和验证
   - 正确的像素提取方法（odd/even交换，14列）
   - 数据有效性验证（100%准确率）

4. **[元数据分析](./04_DATA_DISCOVERY/METADATA_ANALYSIS.md)** - 元数据结构
   - Bit 7-4: 编码类型标志
   - Bit 3-0: 不被使用

---

### 第六阶段：验证与调试

如果你想**验证自己的分析**或**调试字体提取**：

1. **[验证数据](./05_VERIFICATION/VERIFICATION_DATA.md)** - 测试样本和已知字符映射
   - 用户提供的测试样本 (好/坏字符)
   - 31 个调试用字符映射数据
   - 扫描公式验证结果
   - Unicode 到 r5 映射验证

---

### 第七阶段：工具使用

如果你想**使用工具进行分析**：

1. **[分析方法论](./01_OVERVIEW/METHODOLOGY.md)** - 工具和步骤
   - rizin/radare2, capstone, Ghidra
   - Python 包使用指南 (Capstone, rzpipe, r2pipe, angr, pyhidra, ghidra-bridge)
   - 完整的代码示例和实际输出

2. **[分析脚本索引](./07_TOOLS_AND_SCRIPTS/ANALYSIS_SCRIPTS.md)** - Python 脚本
   - 03-fixer.py, angr_symbolic_analysis.py 等

3. **[调试指南](./07_TOOLS_AND_SCRIPTS/DEBUGGING_GUIDE.md)** - 常用调试命令

---

### 第八阶段：失败的尝试

如果你想**避免重复踩坑**：

1. **[错误假设记录](./06_FAILED_HYPOTHESES/WRONG_ASSUMPTIONS.md)** - 已证伪的假设
   - ❌ 错位读取假设 (14.3% 匹配率)
   - ❌ 0x96 标记假设
   - ❌ 0x80 偏移问题
   - ❌ "行交错"字体格式假设 (2026-01-29) - 基于猜测而非汇编代码证据

2. **[废弃代码路径](./06_FAILED_HYPOTHESES/DEAD_CODE_PATHS.md)** - 0x2DC22 死代码分析

---

## 核心发现速查

### 已确认的机制

| 发现 | 公式/位置 | 状态 |
|------|----------|------|
| **Unicode → r5 映射** | `r5 = Unicode >> 2` @ 0x02D4E6 | ✅ 已验证 (2026-01-29) |
| **×33 计算机制** | `(Base + Index) + (Index << 5)` @ 0x02DDE2/0x02DDE6 | ✅ 已验证 (2026-01-30) |
| **多入口点机制** | `0x02DDE4: bgt #0x2ddd8` 条件分支 | ✅ 已验证 (2026-01-30) |
| **动态调度机制** | 283 条 BX 间接跳转指令 | ✅ 已确认 (2026-01-30) |
| **基地址计算公式** | `Base = 0x460000 + (HighByte << 8) - 0xBE0` | ✅ 数学验证 (2026-01-30) |
| **0xBE0 偏移** | `95 × 32 = 3040 = 0xBE0` | ✅ 计算确认 (2026-01-30) |
| **栈帧传递机制** | 写入: 0x02D212, 读取: 0x02D95E, 差异: 0x14 | ✅ 已确认 (2026-01-30) |
| **像素渲染循环** | `0x02DE46: ldrh r7, [r7, #0x24]` | ✅ 已确认 (2026-01-30) |
| **像素地址公式** | `0x100000 + (Unicode >> 2) * 4` | ✅ 已验证 (2026-01-29) |
| 像素数据加载 | `ldrh r2, [r6, #6]` @ 0x2DB58 | ✅ 已确认 |
| 编码判定 | `metadata[0] >> 4 >= 8` | ✅ 已确认 |
| **0x2D680 死代码确认** | 调用者搜索: 0 条引用 | ✅ 已确认 (2026-01-29) |
| ~~Unicode 映射~~ | ~~观察到 U+6CA8 → r5=0x0FDE~~ | ❌ **已更正** (2026-01-29) |
| 主渲染路径 | 0x2DB58 | ✅ 已确认 |
| 0x2DC22 路径 | 死代码，不执行 | ✅ 已确认 |

### 验证报告 (2026-01-29)

**独立验证报告**: [SOLUTION_VERIFICATION_2026-01-29.md](./01_OVERVIEW/SOLUTION_VERIFICATION_2026-01-29.md)
- ✅ Unicode → r5 映射代码已通过 Capstone 验证
- ✅ 像素地址公式已通过 5 个测试字符验证
- ✅ 0x2D680 确认为死代码（无调用者）
- ❌ 之前的 `U+6CA8 → r5=0x0FDE` 假设错误
- ❌ 之前的 `offset(u_lo)` 复杂公式错误

| 发现 | 公式/位置 | 状态 |
|------|----------|------|
| 像素数据加载 | `ldrh r2, [r6, #6]` @ 0x2DB58 | ✅ 已确认 |
| 编码判定 | `metadata[0] >> 4 >= 8` | ✅ 已确认 |
| Unicode 映射 | 观察到 U+6CA8 → r5=0x0FDE | ⚠️ 仅数据观察 |
| **真实渲染路径** | **`r1 = r4 << 16` @ 0x2D3E8** | ✅ **已确认 (2026-01-29 更正)** |
| **0x2D680 函数** | **死代码，无调用者** | ✅ 已确认 (2026-01-29) |
| ~~r6 LDM 加载~~ | ~~`ldm r1!, {r3,r4,r5,r6,r7}` @ 0x02DA8E~~ | ❌ **已证伪 (2026-01-29)**: 位于死代码区域 |
| ~~r6 << 25~~ | ~~`lsls r1, r6, #0x19` @ 0x2DA84~~ | ❌ **已证伪 (2026-01-29)**: 位于死代码区域 |
| 主渲染路径 | 0x2DB58 | ✅ 已确认 |
| 0x2DC22 路径 | 死代码，不执行 | ✅ 已确认 |

### 假设验证研究 (2026-01-29)

| 假设 | 结果 | 证据等级 |
|------|------|----------|
| 假设1: 函数指针表 | ❌ 不正确 | ✅ 代码证据 |
| 假设2: Unicode 范围检测 | ❌ 不正确 | ✅ 代码证据 |
| 假设4: 预编码字符数据 | ⚠️ 部分 | ⚠️ 数据存在 |
| 假设6: Rockchip SDK 机制 | ✅ 部分 | ✅ 数据存在 |
| 假设7: 0x13E024 映射指令 | ❌ 不正确 | ✅ 代码证据 |

**详细分析**: [UNICODE_TO_R5_MAPPING.md](./04_DATA_DISCOVERY/UNICODE_TO_R5_MAPPING.md#第六部分假设验证研究-2026-01-29)

**结论**: 经过 7 个假设的全面验证，**Unicode → r5 映射代码仍未找到**。

---

### 核心算法

**像素地址计算** (0x02DDDC):
```assembly
0x02DDE2: lsls r0, r5, #5      ; r0 = Index × 32
0x02DDE6: adds r0, r4, r0       ; r0 = Base + Index × 33
```

**执行流程**:
```
数据准备 (0x02D212) → 调度计算 (0x02DDDC) → 像素渲染 (0x2DE3C)
```

---

## 分析方法论 ⚠️ 重要

本项目的分析过程中发现了方法论问题，详细记录在 **[方法论经验教训](./01_OVERVIEW/METHODOLOGY_LESSONS.md)**。

### 核心原则

**从已知代码点开始，追踪数据流，只文档化能证明的东西。**

### 证据等级

| 等级 | 描述 | 示例 |
|------|------|------|
| ✅ 已确认 | 有完整代码证据链 | `0x100000 + r5 × 4` |
| ⚠️ 指令存在 | 找到指令但功能未知 | `subs r0, #0x5d` @ 0x13E024 |
| ⚠️ 数据存在 | 找到数据但用途未知 | 语言表 @ 0x778000 |
| ⚠️ 从数据反推 | 从像素位置反推的模式 | U+6CA8 → r5=0x0FDE |
| ❓ 假设 | 未验证的理论 | offset() 函数公式 |

### 常见错误

- ❌ 把"看起来像"等同于"确实是"
- ❌ 从数据拟合推导"公式"
- ❌ 假设代码功能而不追踪数据流
- ✅ 从已知代码点开始追踪
- ✅ 确认每一步的数据流
- ✅ 诚实地区分观察、假设和证明

---

## 原始文档归档

以下大文档已被拆分到此结构中：

- `@FONT_RENDERING_ANALYSIS.md` → 分布在多个章节
- `0x2DC22_PATH_ANALYSIS.md` → `03_CODE_ANALYSIS/PATH_0x2DC22_SPECIAL.md`
- `INLINE_RENDERING_ANALYSIS.md` → `03_CODE_ANALYSIS/INLINE_RENDERING.md`
- `PIXEL_DATA_DISCOVERY.md` → `04_DATA_DISCOVERY/`
- `legacy/MAPPING_REPORT_2026-01-28.md` → `04_DATA_DISCOVERY/DEBUG_CHARACTER_TABLE.md`

### 已整合的验证报告 (2026-01-29)

`SOLUTION_VERIFICATION_2026-01-29.md` 的内容已整合到以下文档：

- **相关问题5_CHARACTER_INDEX.md** - Unicode → r5 映射验证 (`r5 = Unicode >> 2` @ 0x02D4E6)
- **PIXEL_DATA_LOCATION.md** - 像素地址公式验证 (5 个测试字符)
- **DEAD_CODE_PATHS.md** - 0x2D680 死代码确认
- **相关问题RONG_ASSUMPTIONS.md** - 之前的错误假设 (U+6CA8 → r5=0x0FDE 等)
- **相关问题XECUTIVE_SUMMARY.md** - 核心发现更新
- **相关问题ENDERING_PIPELINE.md** - 渲染管线更新
