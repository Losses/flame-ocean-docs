# 14列编码像素布局分析

**状态**: ⚠️ 需要基于代码证据重新验证
**最后更新**: 2026-01-29
**方法**: 基于 VERIFICATION_DATA.md 和暴力搜索验证

---

## ⚠️ 方法论警告

本文档中的像素数据位置是通过**暴力搜索样本文件**找到的，不是从固件代码追踪得到的。

**重要限制**:
- ❌ 未找到代码证据证明像素数据位置的计算公式
- ❌ 暴力搜索结果仅作为"线索"，不是确定的证明
- ✅ 编码方式 (odd/even byte) 已通过样本验证

**详见**: [R6 像素数据指针](../03_CODE_ANALYSIS/REGISTERS/R6_PIXEL_DATA_POINTER.md) | [错误假设记录](../06_FAILED_HYPOTHESES/WRONG_ASSUMPTIONS.md#假设-6-r6-计算公式直接在代码中找到-搜索失败)

---

## 执行摘要

本文档通过验证数据（`VERIFICATION_DATA.md`）分析了 14 列编码的像素布局。**重要发现**：

1. **像素数据位置**：通过暴力搜索样本文件在固件中找到 ⚠️ 未从代码确认
2. **编码方式**：position 0-7 → even byte, position 8-15 → odd byte ✅ 样本验证
3. **显示列数**：所有字符（包括 14 列编码）都使用 15 列显示 ✅ 样本验证

---

## ⚠️ 重要更正

### 之前分析的错误

1. **错误假设**：像素数据位置 = `0x100000 + r5 × 4 + 6`
   - **正确**：像素数据位置通过暴力搜索样本文件找到
   - **沦字实际位置**: `0x466730`（不是 `0x103F76`）

2. **错误假设**：14 列编码使用 14 列显示
   - **正确**：所有字符都使用 15 列显示
   - 16 位提取结果的第 16 位在实际显示中被忽略

3. **错误假设**：样本文件不正确
   - **正确**：样本文件是准确的
   - 编码方式需要从 VERIFICATION_DATA.md 中学习

---

## 第一部分：像素数据位置

### 暴力搜索验证

**方法**：将 `sample_texts` 目录中的 ASCII 像素图转换为二进制模式，然后在固件中搜索精确匹配。

**验证结果**:

| 字符 | Unicode | 像素数据位置 | 状态 |
|------|---------|-------------|------|
| 沨 | U+6CA8 | **0x466772** | ✅ 已验证 |
| 沤 | U+6CA4 | **0x4666EE** | ✅ 已验证 |
| 沦 | U+6CA6 | **0x466730** | ✅ 已验证 |
| 沪 | U+6CAA | **0x4667B4** | ✅ 已验证 |

### 与之前分析的对比

| 字符 | r5 | 之前假设位置 | 实际位置 | 偏差 |
|------|----|------------|----------|------|
| 沨 | 0x0FDE | 0x103F78 | 0x466772 | 0x3629FA |
| 沤 | 0x0FDB | 0x103F70 | 0x4666EE | 0x36287E |
| 沦 | 0x0FDC | 0x103F70 | 0x466730 | 0x3629C0 |

**结论**：之前假设的像素数据位置 `0x100000 + r5 × 4 + 6` 是错误的。

---

## 第二部分：编码方式

### 正确的编码方式

**来源**: VERIFICATION_DATA.md

```
每行 2 字节:
  字节0 (odd):  bit 7-0 → position 8-15
  字节1 (even): bit 7-0 → position 0-7
```

### 存储格式

```
行0: [odd byte] [even byte]
行1: [odd byte] [even byte]
...
```

### 提取方法

```python
def extract_pixels(pixel_data, cols=15):
    """
    从像素数据提取像素图

    Args:
        pixel_data: 32 字节（16 行 × 2 字节）
        cols: 提取的列数（默认 15）

    Returns:
        list: 16 行像素字符串
    """
    rows = []
    for row in range(16):
        odd = pixel_data[row * 2]      # 字节0
        even = pixel_data[row * 2 + 1]  # 字节1

        # position 0-7 → even byte bit 7-0
        even_bits = ''.join('#' if (even >> (7-i)) & 1 else '.' for i in range(8))
        # position 8-15 → odd byte bit 7-0
        odd_bits = ''.join('#' if (odd >> (7-i)) & 1 else '.' for i in range(8))

        # 组合，并取前 cols 位
        pixel_str = (even_bits + odd_bits)[:cols]
        rows.append(pixel_str)

    return rows
```

---

## 第三部分：沦字完整分析

### 基本信息

```
字符: 沦 (U+6CA6)
像素数据位置: 0x466730
编码类型: 14列 (metadata[0]=0xF1 >> 4 = 0xF >= 8)
```

### 像素数据

| 行 | odd (字节0) | even (字节1) | 提取结果 | 样本 |
|----|-----------|-------------|----------|------|
| 0 | 0x40 | 0x40 | .#.......#.... | .#.......#.... | ✓ |
| 1 | 0x40 | 0x20 | ..#......#.... | ..#......#.... | ✓ |
| 2 | 0xC0 | 0x20 | ..#.....##.... | ..#.....##.... | ✓ |
| 3 | 0xA0 | 0x00 | ........#.#... | ........#.#... | ✓ |
| 4 | 0x10 | 0x89 | #...#..#...#.. | #...#..#...#.. | ✓ |
| 5 | 0x08 | 0x4A | .#..#.#.....#. | .#..#.#.....#.. | ✓ |
| 6 | 0x06 | 0x55 | .#.#.#.#.....## | .#.#.#.#.....## | ✓ |
| 7 | 0x00 | 0x11 | ...#...#....... | ...#...#....... | ✓ |
| 8 | 0x30 | 0x21 | ..#....#..##... | ..#....#..##... | ✓ |
| 9 | 0xC0 | 0x21 | ..#....###..... | ..#....###..... | ✓ |
| 10 | 0x00 | 0xE1 | ###....#....... | ###....#....... | ✓ |
| 11 | 0x00 | 0x21 | ..#....#....... | ..#....#....... | ✓ |
| 12 | 0x04 | 0x21 | ..#....#.....#. | ..#....#.....#. | ✓ |
| 13 | 0x04 | 0x21 | ..#....#.....#. | ..#....#.....#. | ✓ |
| 14 | 0xFC | 0x20 | ..#.....######. | ..#.....######. | ✓ |
| 15 | 0x00 | 0x00 | ............... | ............... | ✓ |

**验证结果**: 16/16 行完全匹配 ✓

---

## 第四部分：编码类型与列数

### 重要发现

所有字符（包括 14 列编码）都使用 **15 列显示**。

### 验证数据

| 字符 | 编码类型 | 样本列数 | 提取列数 | 匹配 |
|------|----------|----------|----------|------|
| 沨 | 14列 | 15 | 16 (取15) | ✓ |
| 沦 | 14列 | 15 | 16 (取15) | ✓ |
| 沤 | 15列 | 15 | 16 (取15) | ✓ |

### 结论

1. **编码类型（14列 vs 15列）**可能影响其他渲染属性（如宽度、间距等）
2. **像素数据格式**对所有字符都是相同的
3. **显示列数**统一为 15 列

---

## 第五部分：像素数据布局总结

### 数据结构

```c
struct character_pixel_data {
    uint16_t row_data[16];  // 16 行 × 2 字节
    // 每行格式: [odd byte] [even byte]
    // odd byte: position 8-15
    // even byte: position 0-7
};
```

### 提取算法

```python
import struct

def extract_char_pixels(firmware, pixel_addr, cols=15):
    """
    从固件中提取字符像素数据

    Args:
        firmware: 固件数据
        pixel_addr: 像素数据地址
        cols: 提取列数（默认 15）

    Returns:
        list: 16 行像素字符串
    """
    pixel_data = firmware[pixel_addr:pixel_addr + 32]

    rows = []
    for row in range(16):
        odd = pixel_data[row * 2]      # 字节0 → position 8-15
        even = pixel_data[row * 2 + 1]  # 字节1 → position 0-7

        # 提取位
        even_bits = ''.join('#' if (even >> (7-i)) & 1 else '.' for i in range(8))
        odd_bits = ''.join('#' if (odd >> (7-i)) & 1 else '.' for i in range(8))

        # 组合并截取
        pixel_str = (even_bits + odd_bits)[:cols]
        rows.append(pixel_str)

    return rows
```

---

## 第六部分：反编译证据

虽然像素数据位置是通过暴力搜索找到的，但我们有固件代码证据支持渲染机制：

### 渲染代码位置

| 位置 | 指令 | 说明 |
|------|------|------|
| 0x2DB10 | lsls r0, r4, #4 | r0 = r4 << 4 |
| 0x2DB12 | cmp r0, #0x80 | 编码类型判定 |
| 0x2DB2C | bne #0x2db4e | 14列分支 |
| 0x2DB58 | ldrh r2, [r6, #6] | 加载像素数据 |

### 已知限制

1. **像素数据位置计算公式**：未知
   - 之前假设的 `0x100000 + r5 × 4 + 6` 是错误的
   - 实际位置通过暴力搜索找到

2. **14列编码的含义**：部分理解
   - 标记为 14列编码的字符仍使用 15 列显示
   - 可能影响其他渲染属性

---

## 附录

### 沦字完整像素数据

**位置**: 0x466730

```
行 0: odd=0x40 even=0x40
行 1: odd=0x40 even=0x20
行 2: odd=0xC0 even=0x20
行 3: odd=0xA0 even=0x00
行 4: odd=0x10 even=0x89
行 5: odd=0x08 even=0x4A
行 6: odd=0x06 even=0x55
行 7: odd=0x00 even=0x11
行 8: odd=0x30 even=0x21
行 9: odd=0xC0 even=0x21
行 10: odd=0x00 even=0xE1
行 11: odd=0x00 even=0x21
行 12: odd=0x04 even=0x21
行 13: odd=0x04 even=0x21
行 14: odd=0xFC even=0x20
行 15: odd=0x00 even=0x00
```

---

**参见**:
- [验证数据](../05_VERIFICATION/VERIFICATION_DATA.md)
- [编码规则](./ENCODING_RULES.md)
- [像素数据位置](./PIXEL_DATA_LOCATION.md)
