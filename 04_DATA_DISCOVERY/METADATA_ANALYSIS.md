# 元数据分析

**状态**: ⚠️ 部分已知
**最后更新**: 2026-01-28

---

## 元数据字节位置功能

| 位置 | 已知功能 | 状态 |
|------|----------|------|
| [0] | Bit 7-4: 编码类型标志 | ✅ 已解决 |
| [0] | Bit 3-0: 未知（不被使用） | ✅ 已确认 |
| [1], [3] | 像素数据的一部分 | ✅ 已确认 |
| [2], [4], [5] | 未知 | ❓ 待分析 |

---

## metadata[0] 完整分析

### Bit 7-4: 编码类型标志 ✅

```
encoding = (metadata[0] >> 4) >= 0x8 ? 特殊编码 : 标准编码
```

| metadata[0] 高4位 | 编码类型 | 列数 |
|------------------|----------|------|
| 0x0-0x7 | 标准 | 15 |
| 0x8-0xF | 特殊 | 14 |

### Bit 3-0: 不被使用 ✅

**关键发现**: metadata[0] Bit 3-0 **不被渲染代码使用**。

| 字符 | Unicode | 编码类型 | metadata[0] | Bit 3-0 |
|------|---------|----------|-------------|---------|
| 沨 | U+6CA8 | 标准 (15列) | 0x39 | 9 |
| 沤 | U+6CA4 | 标准 (15列) | 0x29 | 9 |
| 沦 | U+6CA6 | 特殊 (14列) | 0xF1 | 1 |
| 沪 | U+6CAA | 标准 (15列) | 0x20 | 0 |

**观察**: Bit 3-0 值 (9, 9, 1, 0) 与列数 (15/14) 无直接对应关系。

---

## 元数据完整对比

```
沨 (U+6CA8, 标准编码):
  metadata[0-5] = 39 96 40 88 47 70
  Bit 7-4 = 3 → 标准编码
  Bit 3-0 = 9 → 未知

沤 (U+6CA4, 标准编码):
  metadata[0-5] = 29 96 dc 03 f1 c1
  Bit 7-4 = 2 → 标准编码
  Bit 3-0 = 9 → 未知

沦 (U+6CA6, 特殊编码):
  metadata[0-5] = f1 c1 01 96 40 c8
  Bit 7-4 = 15 → 特殊编码
  Bit 3-0 = 1 → 未知

沪 (U+6CAA, 标准编码):
  metadata[0-5] = 20 00 47 70 29 96
  Bit 7-4 = 2 → 标准编码
  Bit 3-0 = 0 → 未知
```

---

## 重要发现

### metadata[0-5] 不被渲染代码直接访问 ✅

**发现**: 搜索整个渲染函数，唯一访问 r6 的指令是 `ldrh r2, [r6, #6]`。

这跳过了全部 6 字节 metadata。

**结论**: metadata[2], [4], [5] 在渲染时不被读取。

### 渲染上下文设置位置 ✅

```
0x2D040: str r0, [r5, #4]  ; 这可能是设置渲染上下文[+4]的位置
```

---

## 未解决的问题

| 问题 | 优先级 | 状态 |
|------|--------|------|
| metadata[2] 的功能 | 🟡 中 | ❓ 待分析 |
| metadata[4] 的功能 | 🟡 中 | ❓ 待分析 |
| metadata[5] 的功能 | 🟡 中 | ❓ 待分析 |

---

**参见**:
- [编码规则](./ENCODING_RULES.md)
- [数据结构定义](../02_ARCHITECTURE/DATA_STRUCTURES.md)
