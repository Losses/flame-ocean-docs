# Unicode → r5 映射分析报告

**状态**: ❌ 转换代码未找到 | **最后更新**: 2026-01-29

---

## 执行摘要

**目标**: 通过逆向工程找到固件中实现 Unicode → r5 转换的代码。

**结论**:
- ❌ **转换代码未找到**: 经过 10+ 种搜索方法，未找到完整的 Unicode → r5 转换代码
- ⚠️ **观察到数据模式**: 从像素数据位置反推的映射关系
- ⚠️ **匹配的指令**: 找到了执行减 0x5D 操作的指令，但无法确认其与 Unicode 转换的关系

**重要**: 本文档中的"高位/低位"划分是**从观察数据推导出来的假设**，不是从固件代码中确认的事实。

---

## 第一部分：观察到的数据模式

### 1.1 从像素数据位置反推的映射关系

| 字符 | Unicode | Unicode (HEX) | r5 值 | r5 (HEX) | 差值 |
|------|---------|---------------|-------|-----------|------|
| 沤   | U+6CA4  | 0x6CA4        | 0x0FDB| 0x0FDB   | -0x5CC9 |
| 沦   | U+6CA6  | 0x6CA6        | 0x0FDC| 0x0FDC   | -0x5CCA |
| 沨   | U+6CA8  | 0x6CA8        | 0x0FDE| 0x0FDE   | -0x5CCA |
| 沪   | U+6CAA  | 0x6CAA        | 0x0FDA| 0x0FDA   | -0x5CCE |

### 1.2 数据模式分析

将 16 位值拆分为高/低字节后发现：

| 字符 | u_hi | u_lo | r5_hi | r5_lo | 高字节差值 | 低字节偏移 |
|------|------|------|-------|-------|-----------|-----------|
| 沤   | 0x6C | 0xA4 | 0x0F  | 0xDB  | +0x5D     | +0x37     |
| 沦   | 0x6C | 0xA6 | 0x0F  | 0xDC  | +0x5D     | +0x36     |
| 沨   | 0x6C | 0xA8 | 0x0F  | 0xDE  | +0x5D     | +0x36     |
| 沪   | 0x6C | 0xAA | 0x0F  | 0xDA  | +0x5D     | +0x30     |

**观察到的模式**:
- 高字节: 0x6C → 0x0F，差值恒定 0x5D
- 低字节: 0xA4-A8-AA → 0xDB/DC/DE/DA，偏移不固定

**注意**: 这是**从数据观察推导出来的模式**，不是从固件代码反编译得到的。

---

## ⚠️ 方法论问题：U+6CA8 例子循环论证 (2026-01-29 批判)

### 问题分析

本文档和其他相关文档中使用 **U+6CA8 (沨) → r5=0x0FDE** 作为一个典型例子，但这个例子存在严重的循环论证问题。

### 数据来源链

```
用户问题报告: "沨字显示错误"
    ↓
屏幕像素描点: 从设备屏幕描出沨字的像素图
    ↓
暴力搜索: 在固件中搜索匹配的像素模式
    ↓
找到位置: 0x466772 (VERIFICATION_DATA.md:119)
    ↓
推导 r5: 假设 r5=0x0FDE (从数据反推)
    ↓
数据拟合: U+6CA8 - 0x5CCA = 0x0FDE
    ↓
❌ 用这个"公式"去"验证"代码
```

### 循环论证问题

| 步骤 | 内容 | 问题 |
|------|------|------|
| 1 | 观察 U+6CA8 的像素数据在 0x466772 | ✅ 事实 |
| 2 | 假设 0x466772 与 r5=0x0FDE 相关 | ❓ 未验证 |
| 3 | 计算 U+6CA8 - r5 = 0x5CCA | ⚠️ 数据拟合 |
| 4 | 在代码中搜索 `subs r0, #0x5d` | ⚠️ 只找到 0x5D，不是 0x5CCA |
| 5 | 声称"验证成功" | ❌ 循环论证 |

### 关键问题

1. **0x0FDE 是什么？**
   - 不是代码中的值
   - 是从暴力搜索位置 0x466772 反推的
   - 没有代码证据表明 r5 等于这个值

2. **0x5CCA 从哪来？**
   - 不是代码中的常量
   - 是 U+6CA8 - 0x0FDE 的差值
   - 在代码中只找到了 `subs r0, #0x5d`，没有 `subs r0, #0x5cca`

3. **0x5D vs 0x5CCA**
   - 找到的指令：`subs r0, #0x5d` (减 93)
   - 数据拟合：U+6CA8 - 0x5CCA = 0x0FDE
   - 0x5D ≠ 0x5CCA (差了 0x5C6D = 23685)
   - 无法确认 `subs r0, #0x5d` 与 Unicode 转换的关系

### 正确的方法

```
❌ 错误做法:
观察数据 → 拟合公式 → 搜索匹配指令 → "验证"公式

✅ 正确做法:
代码入口点 → 追踪数据流 → 确认每一步 → 只记录能证明的
```

### 建议的修改

| 场景 | 当前做法 | 建议做法 |
|------|----------|----------|
| 文档示例 | "U+6CA8 → r5=0x0FDE" | "当 r5=0x0FDE 时..." (不假设来源) |
| 代码分析 | 用数据拟合去"验证"代码 | 从代码证据推导数据结构 |
| 验证方法 | 暴力搜索位置反推 | 从入口点追踪完整数据流 |

---

## 第二部分：找到的代码

### 2.1 已确认的代码位置

| 地址 | 指令 | 功能 | 验证方法 |
|------|------|------|----------|
| 0x2DA8E | `ldm r1!, {r3, r4, r5, r6, r7}` | r5 加载: r5 = [r1+8] | Capstone 反汇编 |
| 0x2DB58 | `ldrh r2, [r6, #6]` | 像素加载: 像素 = [r6+6] | Capstone 反汇编 |
| 0x2DB74 | `lsls r4, r5, #5` | 符号表地址: r4 = r5 × 32 | Capstone 反汇编 |

### 2.2 找到但未确认功能的代码

| 地址 | 指令 | 观察到的模式 | 确认状态 |
|------|------|-------------|----------|
| 0x13E024 | `subs r0, #0x5d` | 执行减 0x5D 操作 | ❌ 未确认与 Unicode 的关系 |
| 0x14AD6 | 数据表 | 包含 0x5CCA 等值 | ❌ 未找到访问代码 |
| 0x5EB88F | 数据表 | UTF-16BE 字符序列 | ❌ 未找到访问代码 |

**关于 0x13E024 的 `subs r0, #0x5d`**:

这个指令执行了与观察到的数据模式相匹配的操作（减 0x5D），但**无法确认**：
- r0 在此位置的值是什么
- 此指令是否在处理 Unicode 字符
- 此指令与 r5 的计算有何关系

---

## 第三部分：搜索方法汇总

所有以下搜索方法均**未找到** Unicode → r5 转换代码：

| 搜索方法 | 目标 | 结果 |
|----------|------|------|
| 常量搜索 | 0x5D, 0xA0, 0x5CCA, 0x32 | 0 条匹配 |
| SUB #0xA0 | `sub rX, rY, #0xa0` | 0 条 |
| ADD #0x32 | `add rX, #0x32` | 0 条 |
| LSL r5,#2 | `lsls rX, r5, #2` | 0 条 |
| CMP #0xA0 | `cmp rX, #0xa0` | 1 条 (无关) |
| LDRB | 查表指令 | 极少 (非目标区域) |
| LDM r5 | 加载 r5 | 17 条 (整个固件) |
| 数据引用 | 访问 0x14AD6 | 未找到 |
| 数据流追踪 | 从 r5 反向追踪 | 链中断 |
| Ghidra 反编译 | 自动分析 | 未找到 |

**总计**: 10+ 种搜索方法，0 个成功找到完整转换代码。

---

## 第四部分：失败的假设

### 4.1 0x116290 区域的误判

最初发现的连续 ADD 指令序列 (0x116296-0x1162A2) 被误认为是 offset 跳转表：
```assembly
0x116296: adds r0, #0x31
0x116298: adds r1, #0x32  ← 匹配 沨的 offset
0x11629A: adds r2, #0x33
```

**验证结果**: 原始字节是 ASCII 字符串 ("10", "12", "34"...),**不是 ARM 代码**。

### 4.2 数据拟合公式的失败

以下公式是通过数据拟合推导的，**未在固件代码中找到实现**：

```
offset(u_lo) = 0x32 + (((10 - (u_lo - 0xA0)) ^ adj) >> 1)
adj_table = [0x0C, 0x0C, 0x0A, 0x00]
```

**搜索特征全部失败**:
- 未找到 SUB #0xA0
- 未找到 SUB #10
- 未找到 LSRS #1
- 未找到相关 EOR
- 未找到 ADD #0x32

---

## 第五部分：已确认的固件结构

### 5.1 固件信息

- **格式**: Rockchip 固件，带特定头部
- **大小**: 33,554,436 字节
- **内存映射**: 整个二进制映射为单个 RAM 块 (0x00000000 - 0x02000003)
- **代码识别**: 使用 Capstone 反汇编，文件偏移量即地址

### 5.2 像素地址计算（已确认）

```
像素地址 = 0x100000 + r5 × 4
```

这是从代码 0x2DB58 `ldrh r2, [r6, #6]` 和 r6 的计算确认的。

### 5.3 符号表系统（已确认）

```assembly
0x0002DAD4:  movs   r4, r5         ; r4 = r5
0x0002DB74:  lsls   r4, r5, #5     ; r4 = r5 * 32
```

每个字符的符号表占用 32 字节。

---

## 第六部分：假设验证研究 (2026-01-29)

### 研究概述

经过系统性的假设验证，我们测试了 7 个不同的假设来寻找 Unicode → r5 映射机制。

### 假设验证结果

| 假设 | 结果 | 关键证据 |
|------|------|----------|
| **假设1**: 函数指针表/跳转表 | ❌ 不正确 | 0x02FA00 跳转表不包含渲染函数地址 0x2DA62 |
| **假设2**: Unicode 范围检测 + 条件分发 | ❌ 不正确 | 找到 9 个 `CMP r5,#0xE9` 但无 Unicode 范围边界检测 |
| **假设3**: 资源 ID/哈希查找机制 | ❓ 未测试 | - |
| **假设4**: 预编码字符数据 + 索引映射 | ⚠️ 部分正确 | 字符串表 (0x79B084) 是 UTF-16 BE 编码的 UI 字符串；Unicode - r5 差值约为 0x5CCA |
| **假设5**: 中间层渲染队列/缓冲区 | ❓ 未测试 | - |
| **假设6**: Rockchip SDK 特定机制 | ✅ 部分正确 | 确认是 Rockchip RKnano SDK 1.0；0x45BB11F0 可能是 SDK 特定的虚拟地址编码 |
| **假设7**: 0x13E024 SUBS #0x5D 映射指令 | ❌ 不正确 | r2 寄存器追踪显示与 Unicode 映射无关 |

---

### 7.1 0x13E024 深度分析 (2026-01-29)

#### 分析背景

之前发现 76 个 `SUBS #0x5D` 指令，其中 0x13E024 被认为是可能的 Unicode 高字节映射指令：
```
假设: u_hi - 0x5D = r5_hi
验证: 0x6C - 0x5D = 0x0F ✓
```

#### 寄存器追踪结果

**r2 寄存器变化轨迹**:
```
0x13DFB6: movs r2, #0x28        ; r2 = 0x28 (40)
0x13DFC2: subs r2, r3, r4      ; r2 = r3 - r4
0x13DFC4: subs r2, r3, r0      ; r2 = r3 - r0
0x13DFC8: asrs r7, r2, #0x1c   ; r7 = r2 >> 28
0x13DFCA: asrs r3, r2, #0x1c   ; r3 = r2 >> 28
0x13E00C: strb r2, [r3, #0x1a] ; 存储 r2
0x13E01C: lsrs r0, r2, #8      ; r0 = r2 >> 8 ⚠️
0x13E024: subs r0, #0x5d       ; r0 = r0 - 0x5D ❌
```

#### 关键发现

**0x13E024 的 SUBS #0x5D 不是用于 Unicode 映射**，原因：

1. **r2 的值不是 Unicode 高字节**
   - r2 被初始化为 0x28 (40)
   - r2 经历多次算术操作：r3 - r4, r3 - r0
   - r2 最终值与 Unicode 无关

2. **lsrs r0, r2, #8 不是提取 Unicode 高字节**
   - 指令是 `r0 = r2 >> 8`
   - 不是 `r0 = unicode >> 8`
   - r2 的值来自算术运算，不是字符加载

3. **代码上下文不支持 Unicode 处理**
   - r1 在 0x13DFFA 被 ADR 重定位到局部缓冲区
   - `0x13DFFA: adr r1, #0x134` → r1 指向局部缓冲区
   - `0x13DFFE: ldrh r7, [r1, #0x20]` → 从局部缓冲区加载
   - 不是从原始 Unicode 字符串位置

#### 结论

**0x13E024 的 SUBS #0x5D 有其他用途**，与 Unicode → r5 映射无关。

真正的映射代码可能在其他位置，或使用不同的机制。

---

## 第七部分：剩余问题

| 问题 | 优先级 | 状态 |
|------|--------|------|
| Unicode → r5 转换代码位置 | 🔴 高 | ❌ 未找到 |
| 0x13E024 指令的实际功能 | 🔴 高 | ❓ 未知 |
| 是否使用查表实现 | 🟡 中 | ❓ 未知 |
| 偏移表用途 | 🟡 中 | ❓ 未知 |
| 其他 Unicode 范围 | 🟢 低 | ❓ 需更多样本 |

---

## 第七部分：建议的后续方向

1. **动态分析**: 使用 JTAG/调试器在运行时追踪数据流
2. **IDA Pro**: 使用更专业的嵌入式逆向工具进行符号执行
3. **数据流追踪**: 从 Unicode 输入点开始追踪，而非从 r5 反向追踪
4. **扩大样本**: 测试更多 Unicode 字符以建立更完整的映射表
5. **接受未知**: 承认静态分析的局限性

---

## 附录：使用的分析脚本

1. `trace_unicode_to_r5.py` - 数据流追踪
2. `search_cmp_a0.py` - CMP #0xA0 搜索
3. `search_formula_patterns_v2.py` - 公式模式搜索
4. `search_ldr.py` - LDR 指令搜索
5. `analyze_dataflow_ghidra.py` - Ghidra 数据流分析
6. `explore_ghidra_analysis.py` - Ghidra 探索脚本

---

## 参见

- [像素数据位置](./PIXEL_DATA_LOCATION.md)
- [编码规则](./ENCODING_RULES.md)
- [调试用字符表](./DEBUG_CHARACTER_TABLE.md)
- [寄存器参考](../03_CODE_ANALYSIS/REGISTERS/REGISTER_REFERENCE.md)
- [未解决问题](../01_OVERVIEW/REMAINING_WORK.md)

---

**分析工具**: Capstone, Ghidra 11.4.2
**固件**: HIFIEC10_Fixed.bin (33,554,436 字节)
**架构**: ARM Cortex-M (Thumb 模式)
