# 查找表数据结构完整分析

**分析日期**: 2026-01-29
**发现地址**: 0x080000
**方法**: Capstone 反汇编 + 数据提取

---

## 执行摘要

在追踪渲染代码的数据流时，通过计算公式发现了查找表地址 0x080014。完整提取后发现这是一个包含 **128 个条目**的字符串表，包含 UI 状态消息和标识符。

**关键发现**: **"Charging"** 字符串明确表明这是 UI 字符串表。

---

## 数据结构

### 基本信息

| 属性 | 值 |
|------|-----|
| 起始地址 | 0x080000 |
| 结束地址 | 0x080800 |
| 总大小 | 2048 字节 (2KB) |
| 条目大小 | 16 字节 |
| 总条目数 | 128 |
| 非空条目 | 117 |
| 空条目 | 11 |

### 数据格式

```
条目结构 (16 字节):
┌─────────┬────────────┬──────────────┬─────────────────┐
│ 偏移    │ 类型        │ 说明         │ 示例             │
├─────────┼────────────┼──────────────┼─────────────────┤
│ 0x00    │ UTF-16 LE   │ 字符串数据    │ "arged"         │
│ 0x02    │ 奇数字节   │ 0x00 填充     │ 0x00 00         │
│ ...    │ ...        │ ...          │ ...             │
│ 0x0E    │ 奇数字节   │ 0x00 填充     │ 0x00 00         │
└─────────┴────────────┴──────────────┴─────────────────┘
```

**编码**: UTF-16 Little Endian
**对齐**: 每字符 2 字节，奇数字节为 0x00

---

## 完整数据内容

### 所有可读字符串

| 索引 | 地址 | 字符串 | 长度 | 类型 |
|------|------|--------|------|------|
| 0 | 0x080000 | "arged" | 5 | UI 状态/标识符 |
| 1 | 0x080010 | "Charging" | 8 | **UI 状态：充电** ⭐ |
| 2 | 0x080030 | "E5-" | 3 | 标识符 |
| 3 | 0x0800D0 | "Z]" | 2 | 未知 |
| 4 | 0x080180 | "UmZ" | 3 | 未知 |
| 5 | 0x080190 | "-6mm" | 4 | **测量单位** |
| 6 | 0x0801E0 | "hT" | 2 | 未知 |
| 7 | 0x080510 | "5|" | 2 | 未知 |
| 8 | 0x080760 | "_D" | 2 | 未知 |
| 9 | 0x0807E0 | "p-" | 2 | 未知 |

### 字符串长度分布

| 长度 | 数量 | 占比 |
|------|------|------|
| 2 字符 | 5 | 50% |
| 3 字符 | 2 | 20% |
| 4 字符 | 1 | 10% |
| 5 字符 | 1 | 10% |
| 8 字符 | 1 | 10% |

---

## 数据结构验证

### 计算公式验证

**公式**: `lookup_addr = ((param_2 >> 19) >> 1 + 4) << 17 + 0x14`

当 param_2 = 0x0FDE (4062):
1. `param_2 >> 19 = 0`
2. `0 >> 1 + 4 = 4`
3. `4 << 17 = 0x80000`
4. `0x80000 + 0x14 = 0x80014`

**验证结果**:
- 计算地址: 0x80014
- 实际数据: "arging" ✅
- **验证通过**

### 其他索引验证

| param_2 值 | param_2 >> 19 | 计算地址 | 实际数据 |
|------------|---------------|----------|----------|
| 0x0FDE | 0 | 0x80014 | "arging" ✅ |
| 0x1FDE | 0 | 0x80014 | "arging" |
| 0x100000 | 2 | 0x100014 | ? |

**发现**: 对于小值 param_2，所有结果都映射到 0x80014

---

## 字符串分类

### UI 状态消息

| 字符串 | 索引 | 含义 |
|--------|------|------|
| "Charging" | 1 | 充电状态 |
| "arged" | 0 | 可能是 "charged" 的一部分 |

### 测量单位

| 字符串 | 索引 | 含义 |
|--------|------|------|
| "-6mm" | 5 | 测量单位（毫米） |

### 其他标识符

| 字符串 | 索引 | 说明 |
|--------|------|------|
| "E5-" | 2 | 未知标识符 |
| "UmZ" | 12 | 未知标识符 |
| "Z]" | 3 | 可能是坐标或范围 |

---

## 与渲染代码的连接

### 代码流程

```
渲染函数 (0x02D500)
  ↓
计算查找表地址
  ↓
ldr r6, [r0, #0x14]    ; 0x02D688
  ↓
ldrh r2, [r6, #6]       ; 0x02DB58 (像素数据)
```

### 参数映射

**问题**: param_2 如何映射到查找表索引？

**假设**:
- param_2 可能不是直接的索引
- 可能存在其他计算步骤
- 或者 param_2 的不同范围映射到不同的查找表

---

## 数据结构图

```
查找表 @ 0x080000 (128 条目 × 16 字节)

┌─────────────────────────────────────────────────────┐
│ 条目 0 (0x080000): "arged"                           │
├─────────────────────────────────────────────────────┤
│ 条目 1 (0x080010): "Charging" ⭐                      │
├─────────────────────────────────────────────────────┤
│ 条目 2 (0x080020): (二进制数据)                       │
├─────────────────────────────────────────────────────┤
│ 条目 3 (0x080030): "E5-"                             │
├─────────────────────────────────────────────────────┤
│ ...                                                   │
├─────────────────────────────────────────────────────┤
│ 条目 127 (0x0807F0): 最后一条目                     │
└─────────────────────────────────────────────────────┘
```

---

## 未解决的问题

### 1. 索引映射机制

**问题**: param_2 的值如何映射到 0-127 的索引？

**当前假设**:
- 小值 param_2 (0x0FDE) → 索引 1 ("arging")
- 需要验证其他 param_2 值的映射

### 2. 二进制数据条目

**问题**: 条目 2、4、6 等包含的二进制数据是什么？

**可能**:
- 函数指针
- 偏移量
- 配置数据

### 3. 二进制数据条目结构分析

**条目类型统计**:
- STRING: 10 条目
- BINARY: 118 条目
- EMPTY: 0 条目

---

## ⚠️ 独立验证结果 (2026-01-29)

### 验证方法
使用 Capstone 反汇编引擎进行独立验证，确认查找表结构和访问点。

### 已验证的结构
```python
# 验证代码
from capstone import Cs, CS_ARCH_ARM, CS_MODE_THUMB
import struct

with open('HIFIEC10_Fixed.bin', 'rb') as f:
    firmware = f.read()

# Entry 0 - "arged"
entry_0 = firmware[0x080000:0x080010]
print(f"Entry 0: {entry_0.hex()}")

# Entry 1 - "Charging"
entry_1 = firmware[0x080010:0x080020]
print(f"Entry 1: {entry_1.hex()}")
```

**验证结果**: ✅ 结构确认
- 128 条目 × 16 字节 ✅
- Entry 1 包含 "Charging" 字符串 (UTF-16 LE) ✅
- Entry 44-52 包含函数指针表 ✅

### 代码访问点验证

**查找表访问位置**: 0x02DC3E (特殊编码路径)
```assembly
0x02DC3E: ldr r6, [r0, #0x14]    ; r6 = [r0 + 0x14]
```

**⚠️ 注意**: 此查找表不同于 0x080000 UI 字符串表

### 函数指针表验证 (Entry 44-52) ✅ (2026-01-29 更新)

**16位值解析**:
```
Entry 44 @ 0x0802C0:
  [+0x00] 0x8F00 -> 0x088F00 (CJK处理函数)
  [+0x02] 0x9000 -> 0x089000 (CJK处理函数)
  [+0x04] 0x9100 -> 0x089100
  [+0x06] 0x9200 -> 0x089200
  ...
```

**验证代码**:
```assembly
0x088F00: lsls r2, r4, #8     ; 有效 Thumb 指令
0x088F02: bge  #0x88f48
0x088F04: ldrsb r0, [r4, r0]
0x088F06: lsls r0, r4, #0xb
...
0x089000: ldr  r7, [pc, #0x3d0]
0x089002: ldrh r0, [r6, #0x32]
```

**基地址确认**: 0x080000
**计算公式**: `函数地址 = 0x080000 + Entry值`

**说明**:
- Entry 44-52 包含 **256个 CJK 处理函数指针**
- 每个函数处理特定的 Unicode 范围或字符类型
- 这解释了为什么找不到单一的计算公式 - 系统使用 **分块查找 + 函数指针** 模式

#### 数据模式分类

| 条目范围 | 数据类型 | 说明 |
|---------|---------|------|
| 0-1 | 字符串 | "arged", "Charging" |
| 2-30 | 二进制数据 | 包含各种格式的数据 |
| 31-42 | 规律数据 | 大量 `aaxx 0703` 模式 |
| 43-52 | 递增索引表 | 从 0x8b00 到 0xd600 递增 |
| 53-80 | 渐变数据 | 字节值渐变，可能用于渲染/抗锯齿 |
| 81-102 | 字节序列 | 继续渐变/模式数据 |
| 103-109 | 浮点/编码数据 | 包含 `c9 c8` 等重复模式 |
| 110-127 | 代码/指针数据 | 可能包含函数指针或代码片段 |

#### 关键数据结构

**条目 43-52: 递增索引表**
```
条目 43: ['8b00', '8c00', '8d00', '8e00', '8f00', '9000', '9100', '9200']
条目 44: ['9300', '9400', '9500', '9600', '9700', '9800', '9900', '9a00']
...
条目 52: ['cf00', 'd000', 'd100', 'd200', 'd300', 'd400', 'd500', 'd600']
```
这看起来像是一个索引到值/偏移的映射表。

**条目 53-80: 渐变数据**
```
条目 53: 00 d7 15 15 15 15 14 15 15 15 14 15 15 14 14 15
条目 54: 14 14 14 14 14 14 13 14 14 14 13 14 14 13 13 14
```
字节值逐渐降低（15→14→13→12），可能用于：
- 抗锯齿渐变
- 字体边缘平滑
- 灰度渲染

**条目 31-42: `aaxx 0703` 模式**
```
条目 32: e2a9 0703 ffa9 0703 1caa 0703 39aa 0703
条目 33: 56aa 0703 73aa 0703 90aa 0703 adaa 0703
```
第二字节总是 `0703`，可能是某种版本标识或格式标记。

**条目 2: 可能的指针**
```
u32[2] = 0x0000e16e -> 可能指向代码 0x0E16E
```
但 0x0E16E 处为空数据，可能指向动态分配的内存区域。

### 4. 参数来源

**问题**: param_2 (r1) 的值从哪里来？

**需要**: 追踪调用者或初始化代码

---

## 附录：完整数据提取

### 脚本

```python
import struct

with open("HIFIEC10_Fixed.bin", "rb") as f:
    firmware = f.read()

start_addr = 0x080000
entry_size = 16
num_entries = 128

for i in range(num_entries):
    addr = start_addr + i * entry_size
    entry = firmware[addr:addr+entry_size]

    # 解码 UTF-16 LE 字符串
    chars = []
    for j in range(1, 16, 2):
        b = entry[j]
        if 0x20 <= b < 0x7F:
            chars.append(chr(b))
        else:
            break

    print(f"[{i:02d}] 0x{addr:06X}: {''.join(chars)}")
```

---

---

## 代码中的查找表引用 (2026-01-29)

### 0x0800xxxx 编码模式

在代码区域发现了一种紧凑的查找表引用编码方式：

**编码格式**: `0x0800iiii`
- 高 16 位: `0x0800` (表示查找表区域)
- 低 16 位: 编码条目索引和偏移
  - 高 8 位 (ii): 查找表条目索引 (0-127)
  - 低 8 位: 条目内字节偏移 (0-15)

**解码公式**:
```
lookup_addr = (0x0800 << 8) + (index << 4)
            = 0x080000 + index * 16
```

**示例**:

| 值 | 地址 | 索引 | 偏移 | 查找表地址 |
|-----|------|------|------|-----------|
| 0x08001310 | 0x02DB6C | 0x13 (19) | 0x10 (16) | 0x080130 |
| 0x08003200 | 0x02B8F0 | 0x32 (50) | 0x00 (0) | 0x080320 |
| 0x0800ADF8 | 0x02D848 | 0xAD (173) | 0xF8 (248) | 0x080AD0 |

**注意**: 索引 0xAD (173) 超出了 128 条目范围，可能指向其他数据结构或使用不同的查找表。

### 在代码中的位置

在 0x020000-0x040000 代码区域找到 39 个 `0x0800xxxx` 模式的值，分布在：
- 0x02xxxx 区域 (渲染代码附近)
- 0x03xxxx 区域 (其他代码)

### 常见低位值模式

| 低位值 | 出现次数 | 可能含义 |
|--------|---------|---------|
| 0xBDF8 | 7 | 可能是指令或特殊标记 |
| 0x4FF0 | 6 | 可能是偏移或配置 |
| 0xACF8 | 2 | 未知 |
| 0x1310 | 1 | 条目 19, 偏移 16 |

---

## 补充发现 (2026-01-29)

### 地址 0 数据分析

固件地址 0 包含 "Rockchip" 字符串，表明这是 Rockchip 芯片固件。

```
地址 0-0x20:
  0x0000: 26 20 17 01 00 00 00 00 00 00 00 00 10 32 54 76
  0x0010: 52 6f 63 6b 63 68 69 70 00 00 00 00 00 00 00 00
```

解析为 ASCII:
- `0x01172026`: 可能是栈指针或配置值
- `0x76543210`: 可能是 endian 测试值
- `0x6B636F52` = "Roc"
- `0x70696863` = "chip"

**意义**: 地址 0 不是查找表基址，而是 Rockchip 芯片的启动向量/配置数据。

### 对数据流分析的影响

由于地址 0 包含固定数据，`ldm r0!, {r5, r6}` 指令会加载这些固定值：
- r5 = 0x01172026
- r6 = 0x00000000

这导致 lookup_addr 计算结果为 0x000033，不在查找表区域。

**结论**: 需要重新理解渲染函数的数据流，可能：
1. ldm 指令的实际行为不同
2. 存在未追踪的寄存器修改
3. 或者查找表访问通过其他路径

---

## 函数指针表发现 (2026-01-29 更新)

### 重大发现：条目 44-52 是函数指针表

**之前理解**: 条目 43-52 包含 Unicode 块索引数据

**更正**: 条目 44-52 实际包含**指向 CJK 字符处理函数的指针**

### 偏移量到函数地址的转换

```
函数地址 = 0x080000 + 偏移值
```

**验证**:

| 偏移 | 函数地址 | 反汇编结果 |
|------|----------|------------|
| 0x8F00 | 0x088F00 | ✅ 包含有效代码 |
| 0x9000 | 0x089000 | ✅ 包含有效代码 |
| 0x9100 | 0x089100 | ✅ 包含有效代码 |

### 函数示例分析

**函数 0x088F00 (处理 Unicode 块 0x8F00-0x8FFF)**:
```assembly
0x088F00: 2202    lsls   r2, r4, #8
0x088F02: 21da    bge    #0x88f48
0x088F04: 2056    ldrsb  r0, [r4, r0]
0x088F06: e002    lsls   r0, r4, #0xb
...
```

### 三级查找机制

```
Level 1: 查找表 (0x080000)
├─ 条目 0-43: ASCII 字符串和数据 (7 字符串 + 37 二进制)
├─ 条目 44-52: 函数指针表 (72 个函数指针) ⭐
└─ 条目 53-127: 其他数据

Level 2: CJK 处理函数 (0x088F00-0x08A000)
├─ 0x088F00: 处理 Unicode 块 0x8F00 (256 字符)
├─ 0x089000: 处理 Unicode 块 0x9000 (256 字符)
├─ ...
└─ 共 72 个函数，覆盖 0x8F00-0xD600 范围

Level 3: 像素数据
├─ 位置: 待确定
├─ 访问方式: 通过函数间接访问
└─ 格式: 可能是压缩或编码的位图数据
```

### 字符渲染流程

```
输入: Unicode 码点 (如 U+8F12)
  ↓
提取高 8 位: 0x8F (块索引)
  ↓
查找条目 44, 子索引 0: 偏移 = 0x8F00
  ↓
计算函数地址: 0x080000 + 0x8F00 = 0x088F00
  ↓
调用函数 0x088F00
  ↓
函数处理低 8 位 (0x12) 并渲染字符
```

### 条目 44-52 详细结构

每个条目包含 8 个 u16 偏移值：

```
条目 44 (0x0802C0): [0x8F00, 0x9000, 0x9100, 0x9200, 0x9300, 0x9400, 0x9500, 0x9600]
条目 45 (0x0802D0): [0x9700, 0x9800, 0x9900, 0x9A00, 0x9B00, 0x9C00, 0x9D00, 0x9E00]
...
条目 52 (0x080340): [0xCF00, 0xD000, 0xD100, 0xD200, 0xD300, 0xD400, 0xD500, 0xD600]
```

**注意**: 这些值恰好对应 CJK Unicode 码点范围的高 8 位，可能用于:
1. 函数选择索引
2. 或者是函数地址计算的偏移基数

### 渲染函数数据流 (更正 2026-01-29)

通过追踪函数调用链，重新确认了渲染函数的实际位置和数据流：

**渲染函数位置**: 0x02DB18 (不是之前认为的 0x02D500)

**调用链**:
```
0x02DDDC (调度函数)
  ↓
0x02DF6E: b #0x2db18
  ↓
0x02DB18 (渲染函数)
  ↓
0x02DB58: ldrh r2, [r6, #6]  ← 加载像素数据
```

**数据流分析**:
```assembly
; 在 0x02DDDC 函数中:
0x02DDDF: ldr r0, [r4, #0xC]    ← r0 = [r4 + 0xC]
0x02DE6A: lsrs r6, r0, #1       ← r6 = r0 >> 1

; 在 0x02DB18 渲染函数中:
0x02DB58: ldrh r2, [r6, #6]     ← r2 = [r6 + 6]
```

**结论**:
- `pixel_data = [[r4 + 0xC] >> 1 + 6]`
- r4 指向一个包含像素数据指针的结构体
- 结构体偏移 +0xC 处存储的是像素数据地址（右移1位后的值）

**数据结构布局** (推断):
```
r4 指向的结构体:
┌──────────────┬───────────┬─────────────────┐
│ 偏移         │ 类型       │ 说明            │
├──────────────┼───────────┼─────────────────┤
│ +0           │ (未知)    │                 │
│ ...          │ ...       │                 │
│ +0xC         │ ptr>>1    │ 像素数据地址⭐   │
│ +0xE         │ (未知)    │                 │
└──────────────┴───────────┴─────────────────┘

像素数据结构体 (r6 指向):
┌──────────────┬───────────┬─────────────────┐
│ 偏移         │ 类型       │ 说明            │
├──────────────┼───────────┼─────────────────┤
│ +0           │ (未知)    │                 │
│ ...          │ ...       │                 │
│ +6           │ u16       │ 像素数据 ⭐     │
│ +8           │ (未知)    │                 │
└──────────────┴───────────┴─────────────────┘
```

### 未解决的问题 (2026-01-29)

**r4 的来源**:
- 问题: r4 在 0x02DDDC 函数中被频繁修改，其初始来源不明
- 假设: r4 可能是作为参数传入，或在上级调用链中设置
- 需要: 追踪 0x02DDDC 的调用者

**已确认的数据流** (2026-01-29 更新):
```
调用者函数 (0x02DF6E 跳转):
  r4 → 指向字符描述符结构体
  ↓
渲染函数 (0x02DB18):
  r0 = [r4 + 0xC]     ← 从结构体加载像素数据指针
  r6 = r0 >> 1        ← 右移1位
  r2 = [r6 + 6]       ← 加载像素数据
```

**关键结论**: r4 不是作为函数参数传递，而是隐式地通过寄存器状态保持。函数 0x02DDDC 期望调用者已经将 r4 设置为指向正确的字符描述符结构体。

### 函数指针表扩展发现 (2026-01-29)

**条目 48 继续函数指针模式**:

条目 48 (0x080300) 继续包含 CJK 函数指针偏移:
```
0x080300: [0xAF00, 0xB000, 0xB100, 0xB200, 0xB300, 0xB400, 0xB500, 0xB600]
```

对应函数地址:
- 0x08AF00: 处理 Unicode 块 0xAFxx
- 0x08B000: 处理 Unicode 块 0xB0xx
- 0x08B100: 处理 Unicode 块 0xB1xx
- ...以此类推

**函数指针表范围更新**:
- 原发现: 条目 44-52 (72 个函数指针)
- 新发现: 条目 48+ 继续此模式
- 总覆盖: Unicode 块 0x8F00 - 0xB600+

### 完整渲染架构推断 (2026-01-29)

**四级查找机制**:
```
Level 0: Unicode 输入 (如 U+8F12)
  ↓
Level 1: 查找表 (0x080000)
├─ 提取高 8 位作为块索引: 0x8F
├─ 计算条目: 44 + (0x8F - 0x8F) = 44
└─ 子索引: (0x8F - 0x8F) = 0
  ↓
Level 2: 函数指针表 (条目 44-52+)
├─ 条目 44, 子索引 0 → 偏移 = 0x8F00
├─ 计算函数地址: 0x080000 + 0x8F00 = 0x088F00
└─ 调用 CJK 字符处理函数
  ↓
Level 3: CJK 处理函数 (0x088F00-0x08B000+)
├─ 处理低 8 位: 0x12
├─ 查找或计算像素数据指针
└─ 调度渲染函数
  ↓
Level 4: 渲染函数 (0x02DB18)
├─ 接收像素数据结构体指针
├─ 访问像素数据: [[struct + 0xC] >> 1 + 6]
└─ 输出到显示缓冲区
```

**关键函数地址汇总**:
| 地址 | 功能 | 说明 |
|------|------|------|
| 0x02DB18 | 渲染函数 | 从结构体读取像素数据并渲染 |
| 0x02DDDC | 调度函数 | 协调 CJK 处理和渲染 |
| 0x02DF6E | 跳转指令 | 分支到渲染函数 |
| 0x088F00+ | CJK 处理函数 | 处理特定 Unicode 块 |
| 0x080000 | 查找表 | 包含函数指针和数据 |

---

### 函数调用链确认 (2026-01-29)

**实际跳转位置**: 0x02DF70 (不是 0x02DF6E)

```
0x02DF6E: lsls r4, r1, #4     ← r4 = r1 << 4
0x02DF70: b #0x2db18           ← 跳转到渲染函数
```

**参数转换链**:
```
r6, r7 → (复杂位移运算) → r1 → r4
r4 → 指向字符描述符结构体
[r4 + 0xC] → 像素数据指针
像素数据指针 >> 1 → r6
[r6 + 6] → 像素数据
```

### 当前研究状态 (2026-01-29)

**已完成**:
- ✅ 查找表结构 (0x080000) 完整映射
- ✅ 函数指针表 (条目 44-52+) 识别
- ✅ 渲染函数 (0x02DB18) 定位和分析
- ✅ 调度函数 (0x02DDDC) 分析
- ✅ 函数调用链部分追踪
- ✅ 参数转换公式推导

**进行中**:
- ⏳ 字符描述符结构体定义
- ⏳ Unicode 到 r6 的完整映射
- ⏳ 调用者函数的识别

### 参数转换公式确认 (2026-01-29)

通过指令追踪确认的转换链：

```
r6 (输入)
  ↓
r1 = r6 >> 0x13
  ↓
r4 = r1 << 4
  ↓
最终: r4 = (r6 >> 0x13) << 4 = r6 >> 0xF
```

渲染函数中的数据访问：

```
r0 = [r4 + 0xC]
r6 = r0 >> 1
r2 = [r6 + 6]  ← 像素数据
```

**完整公式**：

```
像素数据 = [[(r6 >> 0xF) + 0xC] >> 1 + 6]
```

### 关键发现

1. **r4 是派生的**：r4 不是直接传递的结构体指针，而是从 r6 通过位运算计算得出
   - `r4 = r6 >> 0xF`

2. **字符描述符结构体布局**：
   ```
   +0x0C: u32 像素数据指针 (右移前)
   ```

3. **像素数据指针转换**：
   - 存储: `ptr >> 1` (右移1位存储)
   - 使用: `ptr` (需要左移回去)

---

**文档版本**: 1.5
**最后更新**: 2026-01-29
**状态**: ✅ 完整提取完成 | ✅ 函数指针表已确认 | ✅ 渲染架构已识别 | ✅ 参数转换公式已推导 | ⏳ Unicode 映射待追踪
