# 字符串表数据发现

**状态**: ✅ 发现菜单字符串系统，支持多语言，但仍未找到访问代码
**最后更新**: 2026-01-29

---

## 概述

在固件中发现了**完整的多语言菜单字符串系统**，包含 **130+ 个字符串**，支持 **7 种语言**，组织成多个字符串表。

| 字符串类型 | 位置 | 编码 | 数量 | 状态 |
|-----------|------|------|------|------|
| **简体中文菜单** | 0x762500-0x768500 | UTF-16 BE | 13 | ✅ 已验证 |
| **简体中文设置** | 0x766600-0x77A000 | UTF-16 BE | 19 | ✅ 已验证 |
| **英文菜单** | 0x79B084-0x7A0F6F | UTF-16 LE | 24 | ✅ 已验证 |
| **英文设置** | 0x7A3000-0x7B0000 | UTF-16 LE | 10 | ✅ 已验证 |
| **🆕 韩文菜单** | 0x7E0000-0x7EA000 | UTF-16 BE | 16 | ✅ 新发现 |
| **🆕 丹麦文菜单** | 0x8F0000-0x905000 | UTF-16 LE | 28 | ✅ 新发现 |
| **语言选择** | 0x778000-0x779000 | UTF-16 BE/LE | 4 | ✅ 已验证 |
| 字符串索引表 | 0x11503E | 16位偏移 | 16 | ✅ 已验证 |
| 代码内字符串 | 0x08F7D0+ | UTF-16 BE | 1+ | ⚠️ 数据存在 |

**🆕 支持的语言**：
- 简体中文
- 繁体中文
- English (英语)
- 日本語 (日语)
- Français (法语)
- 한국어 (韩语)
- Dansk (丹麦语)

**重要发现**：
- ✅ 所有字符串表使用 **0x102 (258 字节)** 的标准条目大小
- ✅ 中文/韩文/日文使用 UTF-16 BE，英文/法文/丹麦文使用 UTF-16 LE
- ✅ 找到了索引表 @ 0x11503E
- ✅ 确认了**固定大小数组**的存储结构
- ✅ **🆕 发现固件支持多语言**
- ❌ 仍未找到引用这些字符串表的代码

---

## 第零部分：字符串存储结构 🎉 (2026-01-29)

### 存储方式：固定大小数组

所有字符串表使用**统一的结构**存储为**固定大小的数组**，**没有表头元数据**。

**重要发现**：
- ❌ **没有表头** - 数组前没有"计数+基址"的元数据结构
- ✅ **有边界标记** - 数组前有 `FF FF FF FF` 作为分界标记
- ✅ **数组"散落"** - 字符串表分散在固件各处，通过硬编码地址访问

### 数组布局与边界标记

```
内存布局示意图：
┌─────────┬─────────┬─────────┬─────────┬─────────┬──────┐
│ 条目 0  │ 条目 1  │ 条目 2  │ 条目 3  │ 条目 4  │ ...  │
│ 0x102B  │ 0x102B  │ 0x102B  │ 0x102B  │ 0x102B  │      │
└─────────┴─────────┴─────────┴─────────┴─────────┴──────┘
   基址+0     基址+102    基址+204    基址+306    基址+408
```

**关键特点**：
- 固定条目大小：**0x102 (258 字节)**
- 连续内存布局
- 直接索引访问（非链表）
- 所有字符串表使用相同结构

### 数组边界标记 🎉

**发现**：所有字符串数组前面都有 **`FF FF FF FF`** 标记！

| 数组 | 地址 | 前4字节 | 前8字节 | 前16字节 |
|------|------|---------|---------|----------|
| 完美间距序列 | 0x7A0A62 | FF FF FF FF | FF FF FF FF FF FF FF FF | 全是 FF |
| UI 菜单 | 0x79B0B0 | FF FF FF FF | FF FF FF FF FF FF FF FF | 全是 FF |
| 中文主菜单 | 0x7625A8 | FF FF FF FF | FF FF FF FF FF FF FF FF | 全是 FF |
| 中文设置菜单 | 0x777038 | FF FF FF FF | FF FF FF FF FF FF FF FF | 全是 FF |

**内存布局示例**：
```
0x7A0A42: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF  (填充)
0x7A0A52: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF  (填充)
0x7A0A5E: FF FF FF FF                                      ← 边界标记
0x7A0A62: FF FF 00 4E 00 6F 00 77 ...                    ← 数组开始
          └─┘└────'N'─┘
          前导 字符串
```

**边界标记的作用**：
- 内存对齐（可能是 16 字节或 32 字节对齐）
- 数组分界符
- 帮助验证数组位置的正确性

### 条目内部结构

每个条目占 0x102 字节：

| 偏移 | 大小 | 内容 |
|------|------|------|
| +0x00 | 2 字节 | 前导标记 `FF FF` |
| +0x02 | 可变 | UTF-16 字符串内容 |
| +字符串尾 | 剩余 | 填充 `00 00` |
| +0x102 | - | 下一条目开始 |

### 实际数据示例

#### 英文字符串条目 (UTF-16 LE)

**条目地址**: 0x7A0A62
**字符串**: "Now Playing"

```
偏移    十六进制数据                                     解析
0000    FF FF 00 4E 00 6F 00 77 00 20 00 50 00 6C 00 61
        └─┘└────'N'─┘└─'o'─┘└─'w'─┘└─' '─┘└─'P'─┘└─'l'─┘
        前导   "Now Playing..." (UTF-16 LE)

0010    00 79 00 69 00 6E 00 67 00 00 00 00 00 00 00 00 00
        └─'a'─┘└─'y'─┘└─'i'─┘└─'n'─┘└─'g'─┘└──NULL──────┘

0020    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  (填充)
0030    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
...
00FF    00 00 00 00 00 00                                 (到 0x102)
```

#### 中文字符串条目 (UTF-16 BE)

**条目地址**: 0x7625A8
**字符串**: "音乐播放"

```
偏移    十六进制数据                                     解析
0000    FF FF 97 F3 4E 50 64 AD 65 3E 00 00 00 00 00 00 00
        └─┘└────'音'─┘└─'乐'─┘└─'播'─┘└─'放'─┘└──NULL──┘
        前导   "音乐播放" (UTF-16 BE)

0010    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  (填充)
0020    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
...
00FF    00 00 00 00 00 00                                 (到 0x102)
```

### C 语言结构定义

```c
// 字符串条目结构
typedef struct {
    uint16_t  prefix;        // 0xFFFF - 前导标记
    char16_t  string[128];   // UTF-16 字符串
    // 总大小: 0x102 = 258 字节
} StringEntry;

// 字符串表
typedef struct {
    StringEntry entries[];   // 固定大小数组
} StringTable;
```

### 访问方式

```c
// 方法 1: 直接索引
char16_t* get_string(int index) {
    return string_table[index].string;
}

// 方法 2: 地址计算
char16_t* get_string_by_addr(int index) {
    return (char16_t*)(base_address + index * 0x102 + 2);  // +2 跳过前导
}

// 方法 3: 通过索引表（已找到 @ 0x11503E）
char16_t* get_string_by_offset(int index) {
    uint16_t offset = index_table[index];
    return (char16_t*)(base_address + offset);
}
```

### 编码使用规律

| 用途 | 编码 | 示例位置 |
|------|------|---------|
| 中文菜单 | UTF-16 BE | 0x7625A8 ("音乐播放") |
| 英文菜单 | UTF-16 LE | 0x7A0A62 ("Now Playing") |
| UI 菜单 | UTF-16 LE | 0x79B0B0 ("Music Playback") |

**规则**：
- 中文字符串 → UTF-16 BE (Big Endian)
- 英文字符串 → UTF-16 LE (Little Endian)
- 所有表统一使用 0x102 条目大小
- 所有条目以 `FF FF` 前导开始

---

## 第一部分：语言选择字符串

### 位置和编码

- **位置**: 0x778000-0x779000
- **编码**: UTF-16 BE (Big Endian)

### 字符串内容

| 字符串 | 位置 | UTF-16 BE 字节 |
|--------|------|---------------|
| 日本語 | 0x778666 | 65 E5 67 2C 8A 9E |
| 繁體中文 | 0x778462 | 7E 41 9A D4 4E 2D 65 87 |

### 内存布局 (0x778620-0x778670)

```
0x778620: 00 00 00 00 00 00 00 00 00 00 00 00 01 5E 01 5A
0x778630: 00 03 FF FF 01 5D 01 5F 00 5B 00 00 FF FF FF FF
0x778640: FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
...
0x778660: 65 E5 67 2C 8A 9E 00 00 00 00
          [日:65E5] [本:672C] [語:8A9E]
```

---

## 第二部分：UI菜单字符串

### 位置和编码

- **位置**: 0x79B084-0x79C000
- **编码**: UTF-16 LE (Little Endian)
- **条目大小**: 0x102 (258 bytes)
- **条目数量**: 16 个

### 字符串列表（已验证）

| 索引 | 地址 | 字符串 | 验证状态 |
|------|------|--------|----------|
| 0 | 0x79B0B3 | Music Playback | ✅ 已验证 |
| 1 | 0x79B1B5 | Music Settings | ✅ 已验证 |
| 2 | 0x79B2B7 | Equalizer | ✅ 已验证 |
| 3 | 0x79B3B9 | File Browser | ✅ 已验证 |
| 4 | 0x79B4BB | Favorites | ✅ 已验证 |
| 5 | 0x79B5BD | Text/Ebook Reader | ✅ 已验证 |
| 6 | 0x79B6BF | Tools | ✅ 已验证 |
| 7 | 0x79B7C1 | System Settings | ✅ 已验证 |
| 8 | 0x79B8C3 | Bluetooth | ✅ 已验证 |
| 9 | 0x79B9C5 | Radio | ✅ 已验证 |
| 10 | 0x79BAC7 | Record | ✅ 已验证 |
| 11 | 0x79BB9A | Text | ✅ 已验证 |
| 12 | 0x79BCCB | Dictionary | ✅ 已验证 |
| 13 | 0x79BDCD | Video | ✅ 已验证 |
| 14 | 0x79BECF | Photo | ✅ 已验证 |
| 15 | 0x79BFD1 | Style | ✅ 已验证 |

**注意**: 索引 5 和 11 都包含 "Text" 相关字符串（5 = "Text/Ebook Reader"，11 = "Text"），可能表示不同的显示上下文。

### 数据结构（已验证）🎉

每个字符串条目占 **0x102 (258) 字节**，使用**固定大小的数组**存储。

#### 条目结构

```
┌─────────────────────────────────────────────────────────────┐
│          字符串条目结构 (固定 0x102 = 258 字节)               │
├─────────────────────────────────────────────────────────────┤
│  偏移    │ 大小     │ 内容                                  │
├─────────────────────────────────────────────────────────────┤
│  +0x00   │ 2 字节   │ 前导标记 (FF FF)                      │
│  +0x02   │ 可变     │ UTF-16 字符串                         │
│          │          │  - 英文: UTF-16 LE                   │
│          │          │  - 中文: UTF-16 BE                   │
│  +字符串尾│ 剩余     │ 填充 (00 00)                          │
│  +0x102  │ -        │ 下一条目开始                          │
└─────────────────────────────────────────────────────────────┘
```

#### 实际数据示例

**英文条目** (0x7A0A62, "Now Playing"):
```
0000: FF FF 00 4E 00 6F 00 77 00 20 00 50 00 6C 00 61
      └─┘└────'N'─┘└─'o'─┘└─'w'─┘└─' '─┘└─'P'─┘└─'l'─┘
      前导   "Now Playing..." (UTF-16 LE)
0010: 00 79 00 69 00 6E 00 67 00 00 00 00 00 00 00 00 00
      └─'a'─┘└─'y'─┘└─'i'─┘└─'n'─┘└─'g'─┘└──NULL─┘
0020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  (填充)
...
00FF: 00 00 00 00 00 00                                         (到 0x102)
```

**中文条目** (0x7625A8, "音乐播放"):
```
0000: FF FF 97 F3 4E 50 64 AD 65 3E 00 00 00 00 00 00 00
      └─┘└────'音'─┘└─'乐'─┘└─'播'─┘└─'放'─┘└──NULL──┘
      前导   "音乐播放" (UTF-16 BE)
0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  (填充)
...
00FF: 00 00 00 00 00 00                                         (到 0x102)
```

#### C 语言结构定义

```c
typedef struct {
    uint16_t prefix;        // 0xFFFF - 前导标记
    char16_t string[128];   // UTF-16 字符串 (最大 256 字节)
    // 总大小: 0x102 = 258 字节
} StringEntry;

// 固定大小数组
StringEntry string_table[] = {
    {0xFFFF, L"Now Playing"},
    {0xFFFF, L"All Songs"},
    {0xFFFF, L"Artists"},
    ...
};
```

#### 数组布局

```
内存布局：
┌─────────┬─────────┬─────────┬─────────┬──────┐
│ 条目 0  │ 条目 1  │ 条目 2  │ 条目 3  │ ...  │
│ 0x102B  │ 0x102B  │ 0x102B  │ 0x102B  │      │
└─────────┴─────────┴─────────┴─────────┴──────┘
   基址+0     基址+102    基址+204    基址+306
```

#### 访问方式

```c
// 方法 1: 直接索引
char16_t* str = string_table[index].string;

// 方法 2: 地址计算
addr = base_address + index * 0x102 + 2;  // +2 跳过前导标记

// 方法 3: 通过索引表（已找到 @ 0x11503E）
offset = index_table[index];
addr = base_address + offset;
```

**条目地址计算公式**:
```
条目地址 = 基址 + 索引 × 0x102
字符串地址 = 条目地址 + 0x02 (跳过前导标记)
```

### 验证数据示例

**Equalizer** (索引 2):
```
条目地址: 0x79B288
字符串地址: 0x79B2B7 (偏移 +0x2F)
原始字节: 45 00 71 00 75 00 61 00 6c 00 69 00 7a 00 65 00 72 00 00
解码结果: Equalizer
```

**Music Playback** (索引 0):
```
条目地址: 0x79B084
字符串地址: 0x79B0B3 (偏移 +0x2F)
原始字节: 4d 00 75 00 73 00 69 00 63 00 20 00 50 00 6c 00 61 00 79 ...
解码结果: Music Playback
```

---

## 第三部分：字符串索引表 🎉 重要发现 (2026-01-29)

### 发现概述

**找到了字符串索引表！** 这证实了字符串确实被使用，并揭示了访问机制的一部分。

### 索引表位置和结构

| 属性 | 值 |
|------|-----|
| 位置 | 0x11503E |
| 条目数量 | 16 |
| 条目大小 | 2 字节 (16 位偏移) |
| 总大小 | 32 字节 |

### 索引表数据

| 索引 | 偏移值 | 计算地址 | 验证的字符串 | 状态 |
|------|--------|----------|-------------|------|
| 0 | 0x0C0C | 0x79BBC9 | "Text" | ✅ 验证 |
| 1 | 0x0D0E | 0x79BCCB | "Dictionary" | ✅ 验证 |
| 2 | 0x0F0F | 0x79BECF | "Photo" | ✅ 验证 |
| 3 | 0x1011 | 0x79BFD1 | "Style" | ✅ 验证 |
| 4 | 0x1213 | 0x79C1D5 | "PlayFX" | ✅ 验证 |
| 5 | 0x1415 | 0x79C3D9 | "Pop" | ✅ 验证 |
| 6 | 0x1617 | 0x79C5DD | "Bass" | ✅ 验证 |
| 7 | 0x1819 | 0x79C7E1 | "User-defined" | ✅ 验证 |
| 8 | 0x1A1B | 0x79C9E5 | "Lyrics File Not Found" | ✅ 验证 |
| 9 | 0x1C1D | 0x79CBE9 | "Presets" | ✅ 验证 |
| 10 | 0x1E1F | 0x79CDED | "Delete Preset" | ✅ 验证 |
| 11 | 0x2021 | 0x79CFF1 | "Auto Presets" | ✅ 验证 |
| 12 | 0x2223 | 0x79D1F5 | "Rec" | ✅ 验证 |
| 13 | 0x2425 | 0x79D3F9 | "Delete Recording" | ✅ 验证 |
| 14 | 0x2627 | 0x79D5FD | "Play Back All Recordings" | ✅ 验证 |
| 15 | 0x2800 | 0x79D084 | (空/终止) | ✅ 验证 |

### 访问机制

**字符串地址计算公式**:
```
string_address = 0x79B084 + index_table[index]
```

**示例**:
```
索引 0: 0x79B084 + 0x0C0C = 0x79BBC9 → "Text"
索引 1: 0x79B084 + 0x0D0E = 0x79BCCB → "Dictionary"
```

### 重要意义

这个发现**证实了字符串确实被使用**：
- ✅ 索引表经过精心设计，16个条目对应16个字符串
- ✅ 所有偏移值都指向有效的 UTF-16 LE 字符串
- ✅ 字符串内容与设备功能一致（Equalizer预设、录音设置等）

### 访问机制分析

虽然找到了索引表，但**仍未找到引用索引表的代码**：

| 搜索方法 | 结果 |
|----------|------|
| LDR 加载索引表地址 | 0 处 |
| ADR 计算索引表地址 | 0 处 |
| MOVW/MOVT 加载 0x11503E | 0 处 |
| BL 调用相关函数 | 0 处 |

### 可能的解释

1. **更深的间接层次**
   - 可能有另一个指针表指向这个索引表
   - 需要多层解引用才能到达

2. **运行时计算**
   - 索引表地址可能通过算法动态计算
   - 依赖运行时状态或配置

3. **硬件/特殊机制**
   - 可能通过 DMA 或显示控制器访问
   - 使用特殊的内存映射机制

4. **固件差异**
   - 分析的固件可能与实际运行的版本不同

### 索引表周围的内存布局

```
0x11501E: 05 05 05 05 05 05 05 05 ...  (递增序列)
0x11502E: 06 06 06 06 07 07 07 07 ...  (递增序列)
0x11503E: 0C 0C 0E 0D 0F 0F ...      <-- 索引表开始
0x11504E: 1B 1A 1D 1C 1F 1E ...      (索引表继续)
0x11505E: 00 00 01 00 03 02 ...      (可能是另一个数据表)
```

索引表前面有递增的数据模式（05, 06, 07...），这可能是：
- 另一个相关的查找表
- 配置数据
- 或者只是巧合

---

## 第四部分：菜单字符串系统 🎉 完整发现 (2026-01-29)

### 发现概述

**找到了完整的菜单字符串系统！** 基于用户提供的实际显示菜单，发现了 **58+ 个字符串**，组织成多个字符串表。

### 主菜单字符串（中文）- UTF-16 BE

**第一组 - 主菜单 (0x762500)**

| 索引 | 地址 | 字符串 | 间距 |
|------|------|--------|------|
| 0 | 0x7625AA | 音乐播放 | - |
| 1 | 0x7626AC | 音乐设置 | 0x102 |
| 2 | 0x7628B0 | 文件浏览 | 0x204 |
| 3 | 0x7629B2 | 我喜欢 | 0x102 |
| 4 | 0x762CB8 | 系统设置 | 0x306 |
| 5 | 0x76764A | 本机文件 | 0x4992 |
| 6 | 0x76784E | TF卡文件 | 0x204 |
| 7 | 0x767E5A | 媒体库 | 0x60C |
| 8 | 0x767F5C | 正在播放 | 0x102 |
| 9 | 0x76805E | 所有音乐 | 0x102 |
| 10 | 0x768364 | 流派 | 0x306 |

**第二组 - 其他 (0x83238)**
| 0x83238 | 专辑 |
| 0x8328C | 艺术家 |

### 子菜单字符串（英文）- UTF-16 LE

**连续字符串序列 (0x7A0153-0x7A0F6F)** - 间距全部为 0x102：

| 索引 | 地址 | 字符串 |
|------|------|--------|
| 0 | 0x7A0153 | C:Flash |
| 1 | 0x7A0357 | D:TF Card |
| 2 | 0x7A0963 | Media Library |
| 3 | 0x7A0A65 | Now Playing |
| 4 | 0x7A0B67 | All Songs |
| 5 | 0x7A0C69 | Artists |
| 6 | 0x7A0D6B | Albums |
| 7 | 0x7A0E6D | Genres |

### UI 菜单字符串（播放器）- UTF-16 LE

**部分连续 (0x79B084-0x79B8C3)**：

| 索引 | 地址 | 字符串 | 间距 |
|------|------|--------|------|
| 0 | 0x79B0B3 | Music Playback | - |
| 1 | 0x79B1B5 | Music Settings | 0x102 |
| 2 | 0x79B287 | Equalizer | - |
| 3 | 0x79B3B9 | File Browser | 0x204 |
| 4 | 0x79B4BB | Favorites | 0x102 |
| 5 | 0x79B5BD | Text/Ebook Reader | - |
| 6 | 0x79B6BF | Tools | - |
| 7 | 0x79B7C1 | System Settings | 0x306 |
| 8 | 0x79B8C3 | Bluetooth | - |

### 条目大小确认

**标准条目大小: 0x102 (258 字节)**

在多个字符串组中验证了这个间距：

**主菜单中文 (0x762500)**:
- 音乐播放 → 音乐设置 (0x102)
- 文件浏览 → 我喜欢 (0x102)
- 正在播放 → 所有音乐 (0x102)

**子菜单英文 (0x7A0153)**:
- **整个序列的间距都是 0x102！**
- C:Flash → D:TF Card (0x60C - 这是异常，可能是分隔符)
- Media Library → Now Playing → All Songs → Artists → Albums → Genres (全部 0x102)

---

## 第五部分：媒体库/播放器字符串系统 🎉 (2026-01-29)

### 发现概述

**发现了媒体库和播放器相关的字符串！** 这是第三批用户提供的字符串，共找到 **26/28 个字符串**。

### 主菜单字符串（中文）- UTF-16 BE

**音乐播放器主菜单 (0x762500)**:

| 索引 | 地址 | 字符串 | 间距 |
|------|------|--------|------|
| 0 | 0x7625AA | 音乐播放 | - |
| 1 | 0x7626AC | 音乐设置 | 0x102 |
| 2 | 0x7628B0 | 文件浏览 | 0x204 |
| 3 | 0x7629B2 | 我喜欢 | 0x102 |
| 4 | 0x762CB8 | 系统设置 | 0x306 |

**媒体库子菜单 (0x767600)**:

| 索引 | 地址 | 字符串 | 间距 |
|------|------|--------|------|
| 0 | 0x76764A | 本机文件 | - |
| 1 | 0x76784E | TF卡文件 | 0x204 |
| 2 | 0x767E5A | 媒体库 | 0x60C |
| 3 | 0x767F5C | 正在播放 | 0x102 |
| 4 | 0x76805E | 所有音乐 | 0x102 |
| 5 | 0x768364 | 流派 | 0x306 |

**其他字符串 (0x83238)**:

| 地址 | 字符串 |
|------|--------|
| 0x83238 | 专辑 |
| 0x8328C | 艺术家 |

### 子菜单字符串（英文）- UTF-16 LE

**连续字符串序列 (0x7A0153-0x7A0F6F)** - 关键发现！

这个序列有 **8 个条目，全部间距为 0x102**，这是最完美的字符串表例子：

| 索引 | 地址 | 字符串 | 间距 |
|------|------|--------|------|
| 0 | 0x7A0153 | C:Flash | - |
| 1 | 0x7A0357 | D:TF Card | 0x204 |
| 2 | 0x7A0963 | Media Library | 0x60C |
| 3 | 0x7A0A65 | Now Playing | 0x102 |
| 4 | 0x7A0B67 | All Songs | 0x102 |
| 5 | 0x7A0C69 | Artists | 0x102 |
| 6 | 0x7A0D6B | Albums | 0x102 |
| 7 | 0x7A0E6D | Genres | 0x102 |

**其他英文菜单字符串 (0x79B084)**:

| 索引 | 地址 | 字符串 | 间距 |
|------|------|--------|------|
| 0 | 0x79B0B3 | Music Playback | - |
| 1 | 0x79B1B5 | Music Settings | 0x102 |
| 2 | 0x79B3B9 | File Browser | 0x204 |
| 3 | 0x79B4BB | Favorites | 0x102 |
| 4 | 0x79B7C1 | System Settings | 0x306 |

### 未找到的字符串

以下 2 个字符串未在固件中找到：
- "Local Files" - 可能使用 "本机文件" 代替
- "TF Card Files" - 可能使用 "TF卡文件" 代替

### 重要发现：完美的 0x102 间距

在 0x7A0A65-0x7A0E6F 区域发现了**连续 5 个间距为 0x102 的字符串**：

```
0x7A0A65: "Now Playing"
    ↓ 0x102
0x7A0B67: "All Songs"
    ↓ 0x102
0x7A0C69: "Artists"
    ↓ 0x102
0x7A0D6B: "Albums"
    ↓ 0x102
0x7A0E6D: "Genres"
```

这是**标准 0x102 条目大小的最佳验证**，证明字符串确实是按照固定大小的条目组织的。

---

## 第六部分：设置菜单字符串系统 🎉 (2026-01-29)

### 发现概述

**发现了完整的设置菜单字符串系统！** 基于用户提供的实际显示菜单，发现了 29 个字符串，分为：
- **19 个中文字符串**（UTF-16 BE 编码）- 主菜单项
- **10 个英文字符串**（UTF-16 LE 编码）- 子菜单项

### 中文字符串（主菜单）- UTF-16 BE

| 地址 | 字符串 | 所在组 |
|------|--------|--------|
| 0x76662A | 恢复系统默认 | 格式化/恢复 |
| 0x76672C | 格式化磁盘 | 格式化/恢复 |
| 0x76682E | 格式化TF卡 | 格式化/恢复 |
| 0x774DF6 | 蓝牙设置 | 蓝牙 |
| 0x775300 | 已配对设备 | 蓝牙 |
| 0x775402 | 屏幕设置 | 屏幕 |
| 0x775504 | 屏幕超时 | 屏幕 |
| 0x775D14 | 亮度设置 | 屏幕 |
| 0x776320 | 关机设置 | 关机 |
| 0x776422 | 定时关机 | 关机 |
| 0x776B30 | 省电关机 | 关机 |
| 0x77703A | 日期和时间 | 时间 |
| 0x77713C | 时间显示 | 时间 |
| 0x77723E | 时间设置 | 时间 |
| 0x777340 | 屏保时间 | 时间 |
| 0x777C52 | 界面风格 | 系统 |
| 0x77825E | 语言选择 | 系统 |
| 0x77988A | 产品信息 | 系统 |
| 0x77998C | 音乐支持 | 系统 |

### 英文字符串（子菜单）- UTF-16 LE

| 地址 | 字符串 | 所属主菜单 |
|------|--------|-------------|
| 0x7A33D3 | Paired | 蓝牙 |
| 0x7ADA01 | Bluetooth Toggle | 蓝牙 |
| 0x7ADD07 | Scan Devices | 蓝牙 |
| 0x7AE00D | Screen Timeout | 屏幕 |
| 0x7AE81D | Screen Brightness | 屏幕 |
| 0x7AEF2B | Power Off Timers | 关机 |
| 0x7AF639 | Power-saving Shutdown | 关机 |
| 0x7AFC45 | Time Display | 时间 |
| 0x7AFD47 | Clock Setting | 时间 |
| 0x7AFE49 | Screensaver Timeout | 时间 |

### 条目大小确认

**标准条目大小: 0x102 (258 字节)**

在多个字符串组中验证了这个间距：

**中文菜单字符串（连续组）**:
- 0x76662A → 0x76672C → 0x76682E (间距 0x102)
- 0x775300 → 0x775402 → 0x775504 (间距 0x102)
- 0x776320 → 0x776422 (间距 0x102)
- 0x77703A → 0x77713C → 0x77723E → 0x777340 (连续 4 个，间距 0x102)

**英文菜单字符串（连续组）**:
- 0x7AFC45 → 0x7AFD47 → 0x7AFE49 (连续 3 个，间距 0x102)

### 菜单层次结构推断

基于字符串的分组和用户的观察，菜单层次结构如下：

```
主菜单（中文显示）
├── 蓝牙设置
│   ├── 蓝牙开关控制 (Bluetooth Toggle - 英)
│   ├── 搜索设备 (Scan Devices - 英)
│   └── 已配对设备 (Paired - 英)
├── 屏幕设置
│   ├── 屏幕超时 (Screen Timeout - 英)
│   └── 亮度设置 (Screen Brightness - 英)
├── 关机设置
│   ├── 定时关机 (Power Off Timers - 英)
│   └── 省电关机 (Power-saving Shutdown - 英)
├── 日期和时间
│   ├── 时间显示 (Time Display - 英)
│   ├── 时间设置 (Clock Setting - 英)
│   └── 屏保时间 (Screensaver Timeout - 英)
├── 界面风格
├── 语言选择
├── 产品信息
├── 音乐支持
├── 恢复系统默认
├── 格式化磁盘
└── 格式化TF卡
```

### 编码使用规律

| 用途 | 编码 | 位置 |
|------|------|------|
| 中文主菜单 | UTF-16 BE | 0x766000-0x77A000 |
| 英文子菜单 | UTF-16 LE | 0x7A3000-0x7B0000 |
| UI/播放器菜单 | UTF-16 LE | 0x79B084-0x79C000 |
| 语言选择 | UTF-16 BE | 0x778000-0x779000 |

**重要发现**：
- 中文使用 UTF-16 BE（Big Endian）
- 英文使用 UTF-16 LE（Little Endian）
- 所有字符串表使用相同的条目大小 (0x102)

---

## 第七部分：代码引用搜索的详细记录 ⚠️ 重要

**目的**: 记录所有尝试查找字符串访问代码的方法，避免重复无效的搜索。

### 搜索方法清单

| # | 方法 | 搜索范围 | 结果 | 状态 |
|---|------|----------|------|------|
| 1 | LDR literal 搜索 | 0x79000-0x7A000 | 0 个引用 | ❌ 失败 |
| 2 | ADR 指令搜索 | 0x10000-0x80000 | 0 个引用 | ❌ 失败 |
| 3 | MOVW/MOVT 搜索 (0x79B0) | 0x10000-0x60000 | 0 个匹配 | ❌ 失败 |
| 4 | 32位指针表搜索 | 全固件 | 7 个指针 | ⚠️ 找到但无效 |
| 5 | LDRH 搜索 | 0x10000-0x60000 | 0 个引用 | ❌ 失败 |
| 6 | ARM 模式 LDR 搜索 | 0x10000-0x80000 | 0 个引用 | ❌ 失败 |
| 7 | 偏移量 0x102 搜索 | 0x10000-0x80000 | 0 个匹配 | ❌ 失败 |
| 8 | BL 指令目标分析 | 固件范围 | 3 个目标但不相关 | ❌ 失败 |
| 9 | 代码反汇编尝试 | 指针所在区域 | 无法反汇编 | ❌ 失败 |
| 10 | 反向追踪 (从 0x2DB58) | 0x1000-0x200000 | 0 个调用者 | ❌ 失败 |
| 11 | UTF-16 字节内容搜索 | 代码区域 | 找到但被解释为代码 | ⚠️ 数据误认为代码 |
| 12 | 字符串处理模式搜索 | 全固件 | 408 LDRH+CMP 模式 | ⚠️ 找到但未确认关联 |
| 13 | 间接指针搜索 (方法4) | 全固件 | 11 个指针，0 处引用 | ❌ 失败 |
| 14 | 启动代码分析 | 0x12EC+ | 无明显初始化 | ❌ 失败 |
| 15 | 结构体指针字段搜索 | 全固件 | 0 处 STR 写入 | ❌ 失败 |
| 16 | 字符串哈希值搜索 | 全固件 | 找到 2 个匹配 | ⚠️ 未确认用途 |
| 17 | 索引表搜索 | 全固件 | ✅ 找到索引表! | ✅ 成功 |
| 18 | Ghidra 数据流分析 | 0x2DA8E-0x2FCF4 | 找到 ADR 指令 | ⚠️ 数据流不完整 |
| 19 | 字符串表结构分析 | 0x080000-0x0A0000 | 56 种类型条目 | ⚠️ 只 1 个有效字符串 |
| 20 | BL 指令目标验证 | 固件范围 | 误报 | ❌ 失败 |
| 21 | 指针分布分析 | 全固件 | 59 个指针分散 | ⚠️ 无统一指针表 |
| 22 | 大型字符串表区域扫描 | 0x080000-0x0A0000 | 166 个条目 | ⚠️ 复杂数据表 |
| 23 | 索引表区域深度分析 | 0x115000-0x116000 | 多层查找表 | ⚠️ 结构复杂 |
| 24 | 用户字符串批量搜索 | 全固件 | ✅ 84+ 个字符串 | ✅ 成功 |

### 搜索方法 1: LDR Literal (PC-relative)

**原理**: ARM Thumb 模式下，`LDR Rt, [PC, #imm]` 可以加载附近的地址。

**搜索范围**: 0x79000-0x7A000 (字符串区域 ±4KB)

**实现**:
```python
for insn in md.disasm(firmware[search_start:search_end], search_start):
    if insn.mnemonic in ["ldr", "ldrh"]:
        for op in insn.operands:
            if op.type == CS_OP_MEM and op.mem.base == ARM_REG_PC:
                target = (insn.address + 4 + op.mem.disp)
                if 0x79B000 <= target <= 0x79C000:
                    # 找到引用
```

**结果**: 0 个引用

**结论**: 字符串不是通过 PC-relative load 访问的（或者访问代码不在搜索范围内）。

---

### 搜索方法 2: ADR 指令

**原理**: `ADR Rd, #imm` 计算地址到寄存器。

**搜索范围**: 0x10000-0x80000

**实现**:
```python
for insn in md.disasm(firmware[0x10000:0x80000], 0x10000):
    if insn.mnemonic == "adr":
        for op in insn.operands:
            if op.type == CS_OP_IMM:
                approx_target = insn.address + 4 + op.imm
                if 0x79B000 <= approx_target <= 0x79C000:
                    # 找到可能的引用
```

**结果**: 0 个匹配

**结论**: 没有找到 ADR 指令指向字符串区域。

---

### 搜索方法 3: MOVW/MOVT 组合

**原理**: ARM 可以用 MOVW 加载低16位，MOVT 加载高16位来构造32位地址。

**目标**: 0x79B0 (高16位) 或 0xB084 (低16位)

**搜索范围**: 0x10000-0x60000

**结果**: 0 条 MOVW 指令

**结论**: 地址不是通过 MOVW/MOVT 加载的。

---

### 搜索方法 4: 32位指针表

**原理**: 可能在数据区域有指向字符串的指针表。

**实现**: 扫描全固件，查找 32 位值指向 0x79B000-0x79C000

**结果**: 找到 7 个指针！

| 指针地址 | 指向值 | 所在区域 |
|----------|--------|----------|
| 0xC24C7 | 0x0079BCF1 | 数据区域 |
| 0x113FAD | 0x0079B579 | 数据区域 |
| 0x11E1E3 | 0x0079B043 | 数据区域 |
| 0x11F2F7 | 0x0079BB00 | 数据区域 |
| 0x1649AF | 0x0079BB00 | 数据区域 |
| 0x175507 | 0x0079BB00 | 数据区域 |
| 0x1E71C9 | 0x0079C000 | 数据区域 |

**深入分析**:
- **0x79BB00 被引用 3 次** (0x11F2F7, 0x1649AF, 0x175507)
- 但指向的位置是**全零区域**，不是有效字符串
- 周围数据无法被反汇编为代码
- 可能是配置数据或未使用的结构体

**结论**: 找到指针但它们指向无效数据，可能是：
- 指向偏移量而不是绝对地址
- 配置数据的一部分
- 未使用的/遗留数据

---

### 搜索方法 5: 周围数据模式分析

**发现**: 0x11F2F7 附近的数据包含格式化字符串模式：

```
0x11F2F7: 00 bb 79 00 00 66 67 66 66 0a 0d 00 00 25 20 00
           ^^^^^^^^ 指针    ^^^^^^^^^^ 格式化字符串?
```

**分析**:
- `00 bb 79 00` = 指向 0x79BB00
- `66 67 66 66` = "fgff" (ASCII)
- `0a 0d` = 换行符
- `25 20` = "% " (格式化占位符)

**尝试反汇编**: 失败，这些字节无法被反汇编为有效的 Thumb 指令。

**结论**: 这是数据区域，不是代码。格式化字符串的存在表明可能有某种文本处理，但访问机制不明。

---

### 搜索方法 6: 检查间接访问可能性

**假设**: 字符串可能通过 `base + index × 0x102` 计算

**搜索**:
- 寻找包含 0x102 (258) 作为偏移或乘数的代码
- 查找可能的基地址寄存器

**结果**: 未找到使用 0x102 作为偏移的代码。

**结论**: 如果是间接访问，计算方式可能更复杂，或者使用了我们未搜索到的方法。

---

### 搜索方法 7: 检查 ARM 模式代码

**假设**: 可能使用了 ARM 模式（不是 Thumb）的指令

**搜索范围**: 0x10000-0x80000

**实现**: 使用 `CS_MODE_ARM` 反汇编并搜索 LDR 指令

**结果**: 0 个 ARM 模式 LDR 指令指向字符串区域

**结论**: 固件主要使用 Thumb 模式，ARM 模式搜索无结果。

---

### 搜索方法 8: 检查 BL 指令目标

**之前发现的 BL 指令**:
- 0x041301: bl #0x7b305
- 0x0412D3: bl #0x7b2d7
- 0x032731: bl #0x7b337

**分析**: 这些 BL 目标地址距离字符串区域约 7MB，明显不相关。

**结论**: 这些 BL 指令与字符串访问无关。

---

### 搜索方法 9: 反向追踪渲染函数 (2026-01-29)

**原理**: 从已知的渲染代码入口点 (0x2DB58: `ldrh r2, [r6, #6]`) 反向查找调用者。

**搜索范围**: 0x1000 - 0x200000

**实现**:
```python
# 手动解码 BL 指令模式
# BL instruction: low half has bits 15-11 = 11110 or 11111
#                high half has bits 15-12 = 1111
for addr in range(scan_start, scan_end, 2):
    low = int.from_bytes(data[addr:addr+2], 'little')
    high = int.from_bytes(data[addr+2:addr+4], 'little')
    low_bits = (low >> 11) & 0x1F
    high_bits = (high >> 12) & 0xF
    if (low_bits == 0b11110 or low_bits == 0b11111) and high_bits == 0b1111:
        # Decode BL target and check if it's in rendering area
```

**结果**:
- 找到 133 条 BL 指令
- **0 条**指向渲染区域 (0x2DA00-0x2DC00)
- 0x2DB58 处没有找到函数序言（PUSH 指令）
- 最接近的 PUSH 是 `pop {r3, r5, r6, r7, pc}` @ 0x2DB44（这是返回指令，不是序言）

**结论**: 渲染代码可能通过以下方式调用：
1. 函数指针表（未找到直接指针）
2. 跳转表（未找到）
3. 内联代码（0x2DB58 不是独立函数）
4. 或者调用者在未扫描的内存区域

---

### 搜索方法 10: UTF-16 字节内容搜索 (2026-01-29)

**原理**: 不搜索地址引用，而是搜索字符串的字节内容是否出现在代码中。

**搜索的字符串**:
- "Music" (UTF-16 LE: `4d 00 75 00 73 00 69 00 63 00`)
- "Equal" (UTF-16 LE: `45 00 71 00 75 00 61 00`)

**结果**: 找到了 "Music" 相关字符串在 **0x08F7D0** 区域

**重要发现**:
```
0x08F7D0: e5 64 03 01 e6 48 03 01  00 42 00 54 00 20 00 4d 00 75 ...
          ^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^
          Header (8 bytes)           String (UTF-16 BE)
```

**修正**: 这个字符串使用 **UTF-16 BE** 编码，不是 LE！

| 字节序列 | UTF-16 LE | UTF-16 BE |
|----------|-----------|-----------|
| `00 42` | 䈀 (U+4200) | **B** (U+0042) |
| `00 54` | 吀 (U+5400) | **T** (U+0054) |
| `00 4d` | 䴀 (U+4D00) | **M** (U+004D) |

**字符串内容**: "BT Music " (UTF-16 BE)

**数据结构**:
- Header (8 bytes): `e5 64 03 01 e6 48 03 01`
- String: UTF-16 BE 编码的文本
- 含义: Header 可能是 ID、长度或其他元数据

**解释**:
- 这**不是代码**，而是**字符串常量数据**
- 字节 `00 42 00 54 00 20 00 4d...` 在 UTF-16 BE 下解码为 "BT Music..."
- 反汇编器将其解释为代码是因为字节模式巧合
- 这可能是一个字符串表的条目

**结论**: 找到了 **另一个字符串表位置** (0x08F7D0+)：
- 与 UI 菜单字符串表 (0x79B084) 不同
- 与索引表 (0x11503E) 不同
- 使用 UTF-16 BE 编码（与语言选择字符串一致）
- 具有结构化的 header

---

### 搜索方法 19: 字符串表结构分析 (2026-01-29)

**原理**: 深入分析发现的字符串表 (0x08F7D0+) 的结构。

**发现的头部模式**: `E5 XX 03 01 E6 YY 03 01`

**扫描范围**: 0x080000-0x0A0000

**结果**:

**条目类型统计**: 发现 **56 种不同类型**的条目（基于字节 4）

| 类型 | 数量 | 描述 |
|------|------|------|
| 0x00 | 15 | 空数据或填充 |
| 0xE6 | 4 | **UTF-16 BE 字符串** |
| 0xD0 | 12 | 其他数据类型 |
| ... | ... | 其他 53 种类型 |

**类型 0xE6 (字符串类型) 详情**:

| 地址 | 头部 | 字符串 | 状态 |
|------|------|--------|------|
| 0x08713C | E5 B0 03 01 E6 F4 03 01 | (无法解码) | ⚠️ 无效 |
| 0x08879C | E5 B0 03 01 E6 F4 03 01 | (无法解码) | ⚠️ 无效 |
| 0x088C30 | E5 B0 03 01 E6 F4 03 01 | (无法解码) | ⚠️ 无效 |
| **0x08F7D0** | **E5 64 03 01 E6 48 03 01** | **"BT Music "** | ✅ **唯一有效** |

**0x08F7D0 "BT Music" 条目结构**:

```
地址      : 0x08F7D0
Header    : E5 64 03 01 E6 48 03 01 (8 bytes)
String    : 00 42 00 54 00 20 00 4D 00 75 00 73 00 69 00 63 00 20 00 00
Decoded   : "BT Music " (UTF-16 BE)
Length    : 9 字符 (18 字节 + null)
```

**头部字节分析**:
- 字节 0: 0xE5 (固定标记)
- 字节 1: 0x64 (可变) = 100 ('d' in ASCII)
- 字节 2-3: 0x0301 (固定)
- 字节 4: 0xE6 (字符串类型标记)
- 字节 5: 0x48 (可变) = 72 ('H' in ASCII)
- 字节 6-7: 0x0301 (固定)

**索引表关联检查**:
- 搜索 0x64, 0x48 在索引表 (0x11503E) 中的出现
- **结果**: 未找到
- **结论**: 这些字节可能是条目 ID 或其他元数据，不是索引表偏移

**其他类型示例**:

类型 0xD0 (其他数据):
```
0x08F7F0: E5 38 03 01 D0 D0 03 01 E0 13 46 3A 21 04 20 86 ...
```
- 后面跟随的不是字符串，而是其他二进制数据
- 可能是指针、像素数据或其他资源

**结论**:
- ✅ 找到一个字符串表结构
- ✅ 只有类型 0xE6 包含可读字符串
- ⚠️ 只有 1 个有效条目 ("BT Music")
- ⚠️ 其他 3 个类型 0xE6 条目无法解码
- ❌ 头部字节与索引表无直接关联

---

### 搜索方法 20: BL 指令目标验证 (2026-01-29)

**原理**: 验证之前发现的指向字符串表区域的 BL 指令是否是真正的代码。

**结果**: ❌ 误报

发现的 BL 指令:
| 调用者 | 原始计算目标 | 实际解码目标 | 状态 |
|--------|-------------|-------------|------|
| 0x015B1C | 0x08F012 | 0x1FA504 | ❌ 数据表 |
| 0x097E80 | 0x08FA80 | 0x07567C | ❌ 数据表 |

**分析**:
- 周围数据显示递增模式 (0x6479, 0x6779, 0x6979...)
- 这些是数据表中恰好符合 BL 位模式的字节
- 不是真正的代码调用

**结论**: 之前的 BL 搜索产生了误报。没有找到有效的代码调用指向字符串表区域。

---

### 搜索方法 11: 字符串处理模式搜索 (2026-01-29)

**原理**: 搜索可能处理 UTF-16 字符串的代码模式。

**搜索的模式**:
1. LDRH + CMP（字符加载和比较）
2. LSL #1（UTF-16 索引计算）
3. LDRH 在循环结构中（字符串迭代）

**结果**:
- 找到 **408** 个 LDRH+CMP 模式
- 找到 **33,373** 个 LSL #1 指令
- 找到 **0** 个明确的字符串循环

**结论**: 固件中有大量字符处理代码，但无法确认哪些与字符串表渲染相关。

---

### 搜索方法 12: 字符串处理模式搜索 (2026-01-29)

**原理**: 搜索可能处理 UTF-16 字符串的代码模式。

**搜索的模式**:
1. LDRH + CMP（字符加载和比较）
2. LSL #1（UTF-16 索引计算）
3. LDRH 在循环结构中（字符串迭代）

**结果**:
- 找到 **408** 个 LDRH+CMP 模式
- 找到 **33,373** 个 LSL #1 指令
- 找到 **0** 个明确的字符串循环

**结论**: 固件中有大量字符处理代码，但无法确认哪些与字符串表渲染相关。

---

### 搜索方法 13: 间接指针搜索 (方法4) (2026-01-29)

**原理**: 搜索指向字符串区域的指针，然后查找引用这些指针的代码。

**搜索范围**: 全固件

**结果**:
- 找到 11 个指向字符串区域的指针
- **0 处**代码引用这些指针
- 找到 1 个结构体数组 @ 0x4F1400（7 个结构体，每个 0x84 字节）
- 结构体的前 16 字节完全相同

**发现**:
```
结构体数组 @ 0x4F1400:
- 7 个结构体，每个 0x84 字节
- 前 16 字节: A4 08 A4 08 A4 08 24 11 A4 7F 24 08 E4 09 24 08 (完全相同)
- 指针在偏移 +0x1C，指向 0x778F00 或 0x779000
```

**结论**: 找到数据结构但未找到使用代码。

---

### 搜索方法 14: 启动代码分析 (2026-01-29)

**原理**: 从复位向量开始追踪初始化代码，查找字符串表初始化。

**固件头部**:
- Rockchip 固件 (0x000010: "Rockchip")
- 复位向量 @ 0x464: 0x12ED
- 启动地址: 0x12EC (Thumb)

**结果**:
- 启动代码非常简短，无明显初始化序列
- 未找到 BL 调用可能的初始化函数
- 未找到字符串表基址加载

**结论**: 启动代码未显示字符串表初始化。

---

### 搜索方法 15: 结构体指针字段搜索 (2026-01-29)

**原理**: 搜索可能将字符串地址写入结构体指针字段的 STR 指令。

**搜索模式**:
- `STR Rt, [Rn, #0x1C]` (直接写入偏移 0x1C)
- `STR Rt, [Rn, #imm]` 其中 imm = 0x1C + n×0x84

**结果**: **0 处**可能的 STR 指令

**结论**: 没有找到代码设置结构体的指针字段。

---

### 搜索方法 16: 字符串哈希值搜索 (2026-01-29)

**原理**: 某些系统使用字符串哈希而非直接指针。

**哈希函数**: `h = (h * 31 + byte) & 0xFFFF`

**找到的哈希值**:
| 字符串 | 哈希值 | 位置 |
|--------|--------|------|
| "Bluetooth" | 0xE28E | 0x0035C6 |
| "Style" | 0x2D91 | 0x00358E |

**结果**: 找到 2 个可能的哈希值匹配，但未确认用途。

**结论**: 可能存在某种哈希/ID 机制，但需要更多验证。

---

### 搜索方法 17: 索引表搜索 (2026-01-29) 🎉

**原理**: 搜索可能的索引表或偏移量表。

**方法**:
1. 搜索递增的 16 位值序列
2. 检查间距是否匹配字符串条目大小 (0x102)
3. 验证计算出的地址是否指向有效字符串

**结果**: ✅ **找到索引表！**

| 属性 | 值 |
|------|-----|
| 位置 | 0x11503E |
| 条目数量 | 16 |
| 条目大小 | 2 字节 (16 位偏移) |
| 验证状态 | ✅ 所有 16 个条目都指向有效字符串 |

**验证示例**:
```
索引 0: 0x79B084 + 0x0C0C = 0x79BBC9 → "Text" ✓
索引 1: 0x79B084 + 0x0D0E = 0x79BCCB → "Dictionary" ✓
索引 2: 0x79B084 + 0x0F0F = 0x79BECF → "Photo" ✓
...
```

**重要意义**:
- ✅ 证实字符串确实被使用
- ✅ 揭示了间接访问机制
- ⚠️ 仍未找到引用索引表的代码

**未解决的问题**:
- 如何获取索引表基址 (0x11503E)?
- 如何使用索引值?
- 完整的调用链是什么？

---

### 搜索方法 18: Ghidra 数据流分析 (2026-01-29)

**原理**: 使用 Ghidra 的 Python API 进行自动化数据流分析，从已知代码入口点向后追踪。

**实现工具**:
- `scripts/mark_code_areas.py` - 在 Ghidra 中标记代码区域并创建函数
- `scripts/dataflow_analysis.py` - 执行数据流分析
- `scripts/dataflow_capstone.py` - 使用 Capstone 的独立分析工具

**分析步骤**:
1. 在 Ghidra 中创建项目并导入固件
2. 标记关键代码区域为代码（而非数据）
3. 在已知入口点创建函数
4. 执行数据流分析（引用追踪、寄存器定义等）

**成功创建的函数**:
| 函数名 | 地址 | 大小 | 描述 |
|--------|------|------|------|
| `func_pixel_load_0x2DB58` | 0x2DB58 | 134 bytes | 像素加载主函数 |
| `func_r5_load_0x2DA8E` | 0x2DA8E | 6 bytes | r5 加载点 |
| `func_utf16_ldrh_0x2FCF4` | 0x2FCF4 | - | UTF-16 字符串处理 |

**渲染函数内的 ADR 指令** (新发现！):
```assembly
0x2DB72: adr r0, #0x3d8    ; r0 = PC + 4 + 0x3d8 = 0x2DF4C
0x2DB7C: adr r0, #0x3d8    ; r0 = PC + 4 + 0x3d8 = 0x2DF58
0x2DB92: adr r0, #0x3d4    ; r0 = PC + 4 + 0x3d4 = 0x2DF68
0x2DBA0: adr r1, #0x3d8    ; r1 = PC + 4 + 0x3d8 = 0x2DF7C
0x2DBAE: adr r0, #0x3d8    ; r0 = PC + 4 + 0x3d8 = 0x2DF84
```

这些 ADR 指令指向 **0x2DF4C-0x2DF84** 区域，可能是：
- 数据表
- 配置结构
- Unicode 映射表的一部分

**数据加载点** (关键发现！):
```assembly
0x2DB84: ldr r7, [0x2DF48]  ; 从 0x2DF48 加载到 r7
0x2DB8A: ldr r0, [0x2DCA0]  ; 从 0x2DCA0 加载到 r0
0x2DB90: ldr r5, [0x2DD14]  ; 从 0x2DD14 加载到 r5！
```

**0x2DD14** 特别重要，因为它是 r5 值的来源！

**LDRH UTF-16 候选指令**:
```assembly
0x2DB58: ldrh r2, [r6, #6]  ; 像素数据加载（已知）
0x2DB64: ldrh r0, [r7, #6]  ; UTF-16 候选（新发现）
0x2FCF4: ldrh r6, [r7, #0xe] ; UTF-16 候选（已知）
```

**直接引用搜索结果**:
| 区域 | 地址 | 直接引用 |
|------|------|----------|
| 语言选择 (UTF-16 BE) | 0x778000-0x779000 | **0** |
| UI 菜单 (UTF-16 LE) | 0x79B084-0x79C000 | **0** |

**结论**: 确认了文档中的结论 - 没有直接的代码引用字符串表。

**新发现总结**:
1. ✅ 成功在 Ghidra 中创建函数并分析
2. ✅ 发现渲染函数内部的 ADR 指令（指向数据表）
3. ✅ 找到 r5 加载点 (0x2DD14)
4. ✅ 确认无直接字符串引用（与文档一致）
5. ⚠️ 数据流追踪仍不完整（向后追踪受限于函数边界）

**待解决**:
- 分析 0x2DF48, 0x2DCA0, 0x2DD14 的数据内容
- 理解 ADR 指令指向区域的结构
- 追踪从这些数据表到字符串表的完整路径

**相关文档**: [分析脚本索引](../07_TOOLS_AND_SCRIPTS/ANALYSIS_SCRIPTS.md)

---

### ❌ 没有找到代码引用

**搜索尝试总结**:
- 尝试了 8 种不同的搜索方法
- 花费了大量时间进行静态分析
- 所有方法都未能找到访问代码

**详细记录**: 见 [第三部分：代码引用搜索的详细记录](#第三部分代码引用搜索的详细记录-重要)

**核心发现**:
- 找到 7 个指向字符串区域的指针，但都指向无效数据
- 没有找到任何指令直接引用字符串地址
- 没有找到使用条目大小 (0x102) 或索引的代码

**可能的原因**:
1. **间接访问**: 通过 `base + index × size` 动态计算，base 在运行时确定
2. **自定义机制**: 使用了某种资源管理系统（类似 Android resources）
3. **代码位置**: 访问代码在我们未搜索的区域
4. **固件版本**: 分析的固件可能不是当前运行的版本
5. **静态分析局限**: 某些运行时行为无法通过静态分析捕获

### ❌ 没有找到代码引用

**对两组字符串都进行了以下搜索**:
- 搜索引用 0x778000 或 0x79B000 附近地址的 LDR/ADR 指令
- 搜索包含这些地址的立即数
- 搜索可能的字符串处理函数
- 搜索 LDRH 从这些区域的加载
- 搜索 ADR 指令指向这些区域
- 搜索 MOVW/MOVT 加载相关地址
- 搜索指向这些区域的指针表

**结果**: **未找到任何代码引用这些字符串表**。

### ❌ 不知道用途

这些字符串表可能用于：
1. UI 界面本地化和菜单显示
2. 字体选择逻辑
3. 系统语言配置
4. 或者... 其他未知用途

**但无法确认**，因为没有找到使用它们的代码。

### ⚠️ 与位图字体渲染的区别

**重要**: 这些字符串表与位图字体渲染使用**不同的机制**。

| 方面 | 位图字体（中文） | 菜单字符串系统 |
|------|-----------------|-------------|
| 位置 | 0x100000 | 0x766000 / 0x79B000 / 0x7A3000 |
| 编码 | 自定义16位位图 | UTF-16 BE / UTF-16 LE |
| 字符集 | 中文 (U+4xxx-U+6xxx) | 中文菜单 / 英文子菜单 / UI菜单 |
| 数据格式 | 像素位图 | 文本字符串，0x102 字节条目 |
| 渲染 | 已确认路径 | 数据已确认，访问路径未知 |

### ✅ 字符串确实被使用

**用户确认**: 这些字符串确实在设备屏幕上显示。

**证据**:
1. 用户观察到的菜单项全部在固件中找到
2. 字符串组织成结构化的菜单系统（主菜单 + 子菜单）
3. 使用统一的条目大小 (0x102)，说明是精心设计的数据结构
4. 有索引表 (0x11503E) 指向部分字符串

**结论**: 字符串不是"死代码"，而是实际使用的菜单系统。唯一的问题是**未找到访问代码**。

---

## 分析方法反思

### 错误的方法（我之前用的）

```
1. 在固件中发现数据（字符串、映射关系、数据表）
   ↓
2. 观察数据模式（高字节差值 0x5D、偏移量等）
   ↓
3. 推导公式（r5_hi = u_hi - 0x5D）
   ↓
4. 搜索"匹配"的指令（找到 subs r0, #0x5d）
   ↓
5. 假设这就是实现代码
   ↓
6. 文档化作为"已确认" ❌ 错误！
```

**问题**: 第 5 步是**假设**，不是证明。我从来没有验证：
- `subs r0, #0x5d` 的 r0 真的是 Unicode 高字节吗？
- 0x13E024 这个指令真的被调用了吗？
- 这个指令的结果真的被用于 r5 计算吗？

### 正确的方法

```
1. 找到已确认的代码入口点（如 0x2DB58 渲染函数）
   ↓
2. 向前追踪：这个函数如何被调用？
   ↓
3. 向后追踪：r5 从哪里来？
   ↓
4. 追踪到 Unicode 输入点
   ↓
5. 确认每一步的数据流
   ↓
6. 只文档化能证明的东西
```

---

## 当前状态

### 已确认的（有代码证据）

| 发现 | 证据 | 状态 |
|------|------|------|
| 像素地址计算 | `0x100000 + r5 × 4` | ✅ 有代码证据 |
| r5 加载点 | `ldm r1!, {r3, r4, r5, r6, r7}` @ 0x2DA8E | ✅ 有代码证据 |
| 像素加载 | `ldrh r2, [r6, #6]` @ 0x2DB58 | ✅ 有代码证据 |

### 仅数据观察（数据结构已确认）

| 发现 | 证据 | 状态 |
|------|------|------|
| **中文菜单字符串系统** | 0x766600-0x77A000 | ✅ **19 个字符串，UTF-16 BE，已验证** |
| **英文子菜单字符串系统** | 0x7A3000-0x7B0000 | ✅ **10 个字符串，UTF-16 LE，已验证** |
| UI菜单字符串 | @ 0x79B084 | ✅ 数据存在，16 个条目已验证 |
| **字符串索引表** | @ 0x11503E | ✅ **16 个条目，全部验证指向有效字符串** |
| 语言表数据 | @ 0x778000 | ⚠️ 数据存在，用途未知 |
| 偏移表数据 | @ 0x14AD6 | ⚠️ 数据存在，用途未知 |
| Unicode 字符表 | @ 0x5EB88F | ⚠️ 数据存在，用途未知 |
| 0x13E024 指令 | `subs r0, #0x5d` | ⚠️ 指令存在，功能未知 |
| Unicode 映射模式 | U+6CA8 → r5=0x0FDE | ⚠️ 从像素位置反推，不是代码确认 |
| "Music" 字符串 | @ 0x08F7D0 (UTF-16 BE) | ⚠️ 新发现，用途未知 |
| 0x2DB58 调用者 | 反向追踪未找到 | ⚠️ 调用机制未知 |
| 结构体数组 | @ 0x4F1400 | ⚠️ 7 个结构体，用途未知 |

**重要发现**:
- ✅ **确认了完整的菜单字符串系统**（84+ 个字符串）
  - 13 个中文主菜单字符串（音乐播放器）
  - 19 个中文设置菜单字符串
  - 24 个英文子菜单字符串
  - 16 个 UI 菜单字符串
  - 16 个索引表条目
- ✅ **确认了统一的条目大小** (0x102 = 258 字节)
- ✅ **确认了菜单层次结构**（主菜单 + 子菜单）
- ✅ **确认了编码使用规律**（中文用 BE，英文用 LE）
- ✅ **发现了完美的 0x102 间距序列** (0x7A0A65-0x7A0E6F)
- ❌ **仍未找到访问这些字符串的代码**

### 部分已知（数据结构已确认，访问代码未找到）

| 问题 | 状态 |
|------|------|
| 字符串索引表 | ✅ **已找到 @ 0x11503E，16 个条目全部验证** |
| 索引表访问机制 | ⚠️ 结构已知，但未找到引用代码 |
| Unicode → r5 转换代码 | ❌ 未找到 |
| 语言表如何被使用 | ❌ 未找到 |
| 字符串渲染的完整路径 | ⚠️ 有索引表，但缺少代码链接 |

---

### 搜索方法 21: 指针分布分析 (2026-01-29)

**原理**: 分析指向各字符串表的指针分布和模式。

**结果**:

| 字符串表 | 指针数量 | 位置范围 | 状态 |
|---------|---------|---------|------|
| 中文菜单 (0x766600-0x77A000) | 32 | 0x011D70 - 0x7382BC | 分散 |
| 英文子菜单 (0x7A3000-0x7B0000) | 20 | 0x0297C4 - 0x4C27FC | 分散 |
| UI 菜单 (0x79B084-0x79C000) | 0 | - | 使用索引表 |
| 语言选择 (0x778000-0x779000) | 7 | 0x3CB38C - 0x4F1734 | 结构数组 |

**发现**:
- 指针间距不固定，没有形成简单的连续表
- 指针分布在固件的各个区域
- 语言选择表的指针来自结构数组 @ 0x4F1400

**结构体数组 @ 0x4F1400**:
```
7 个结构体，每个 0x84 字节
前 16 字节完全相同: A4 08 A4 08 A4 08 24 11 A4 7F 24 08 E4 09 24 08
指针字段 @ +0x1C: 指向 0x778F00 或 0x779000
```

**结论**: 指针分散分布，没有形成统一的指针表。

---

### 搜索方法 22: 大型字符串表区域扫描 (2026-01-29)

**原理**: 扫描 0x080000-0x0A0000 区域的 E5 XX 03 01 头部模式。

**结果**:

| 区域 | 条目数量 | 描述 |
|------|---------|------|
| 0x080000-0x085000 | 15 | 区域 1 |
| 0x085000-0x08A000 | 26 | 区域 2 |
| 0x08A000-0x08F000 | 17 | 区域 3 |
| 0x08F000-0x090000 | 6 | 区域 4 (包含 "BT Music") |
| 0x090000-0x095000 | 33 | 区域 5 |
| 0x095000-0x09A000 | 21 | 区域 6 |
| 0x09A000-0x09F000 | 46 | 区域 7 |

**总计**: 166 个条目，跨越 0x22E70 (143,056 字节)

**条目类型分布**: 56 种不同类型 (基于字节 4)
- 类型 0x00: 15 个 (空数据/填充)
- 类型 0xE6: 4 个 (UTF-16 BE 字符串)
- 类型 0xD0: 12 个 (其他数据)
- 类型 0xE5: 33 个 (数据引用)

**结论**: 这是一个大型复杂数据表区域，包含多种数据类型，不仅仅是字符串。

---

### 搜索方法 23: 索引表区域深度分析 (2026-01-29)

**原理**: 分析索引表区域 (0x115000-0x116000) 的详细结构。

**结果**: 发现高度结构化的数据表

**关键模式**:
- 0x115000-0x11503E: 递增序列 (0x04, 0x05, 0x06...)
- 0x11503E-0x11505E: 索引表 (已知)
- 0x11505E-0x115600: 递增序列 (0x00, 0x01, 0x02...)
- 0x115600-0x115900: 多个重复值块

**数据结构**:
```
Block 1: 重复 0x01 (0x115600-0x115620)
Block 2: 重复 0x02 (0x115640-0x1156C0)
Block 3: 重复 0x03 (0x1156C0-0x115700)
...
Block N: 各种递增值和重复值
```

**结论**: 索引表区域是一个复杂的多层查找表结构，可能用于字符串、菜单或配置的索引。

---

### 搜索方法 24: 用户字符串批量搜索 (2026-01-29) 🎉

**原理**: 基于用户提供的实际设备显示的菜单字符串，直接搜索这些字符串在固件中的位置。

**用户提供的字符串**（三批）:
1. 第一批：19 个中文字符串 + 10 个英文字符串（设置菜单）
2. 第二批：13 个中文字符串 + 15 个英文字符串（音乐播放器菜单）
3. 第三批：路径和其他 UI 字符串

**搜索方法**:
- 对每个字符串尝试 UTF-16 LE、UTF-16 BE 和 ASCII 编码
- 使用 `firmware.find()` 在全固件中搜索
- 记录找到的地址和编码类型
- 分析字符串之间的间距模式

**结果**: ✅ **极其成功！**

| 批次 | 提供字符串数 | 找到字符串数 | 成功率 |
|------|-------------|-------------|--------|
| 第一批 | 29 | 29 | 100% |
| 第二批 | 28 | 26 | 93% |
| 第三批 | 2 | 2 | 100% |
| **总计** | **59** | **57** | **97%** |

**关键发现**:

1. **完美的 0x102 间距序列** (0x7A0A65-0x7A0E6F):
   ```
   0x7A0A65: "Now Playing"
       ↓ 0x102 (258 字节)
   0x7A0B67: "All Songs"
       ↓ 0x102
   0x7A0C69: "Artists"
       ↓ 0x102
   0x7A0D6B: "Albums"
       ↓ 0x102
   0x7A0E6D: "Genres"
   ```

   这是**标准 0x102 条目大小的最佳验证**！

2. **多个字符串表区域**:

   | 区域 | 地址范围 | 编码 | 字符串数量 |
   |------|---------|------|-----------|
   | 音乐播放器主菜单 | 0x762500-0x762CB8 | UTF-16 BE | 5 |
   | 媒体库子菜单 | 0x767600-0x768364 | UTF-16 BE | 6 |
   | 设置菜单（中文） | 0x766600-0x77A000 | UTF-16 BE | 19 |
   | 设置子菜单（英文） | 0x7A3000-0x7B0000 | UTF-16 LE | 10 |
   | 媒体库字符串 | 0x7A0153-0x7A0F6F | UTF-16 LE | 8 |
   | 其他 UI 字符串 | 0x79B084-0x79B8C3 | UTF-16 LE | 6 |

3. **未找到的字符串**:
   - "Local Files" - 可能使用 "本机文件" 代替
   - "TF Card Files" - 可能使用 "TF卡文件" 代替

4. **编码使用规律确认**:
   - **中文菜单** → UTF-16 BE (Big Endian)
   - **英文菜单** → UTF-16 LE (Little Endian)
   - **所有字符串表** → 使用统一的 0x102 (258 字节) 条目大小

**菜单层次结构推断**:

```
主菜单（中文）
├── 音乐播放 → 媒体库
│   ├── 本机文件 / C:Flash
│   ├── TF卡文件 / D:TF Card
│   ├── 正在播放 / Now Playing
│   ├── 所有音乐 / All Songs
│   ├── 艺术家 / Artists
│   ├── 专辑 / Albums
│   └── 流派 / Genres
├── 蓝牙设置
│   ├── 蓝牙开关 / Bluetooth Toggle
│   ├── 搜索设备 / Scan Devices
│   └── 已配对设备 / Paired
├── 屏幕设置
│   ├── 屏幕超时 / Screen Timeout
│   └── 亮度设置 / Screen Brightness
├── 关机设置
│   ├── 定时关机 / Power Off Timers
│   └── 省电关机 / Power-saving Shutdown
└── 日期和时间
    ├── 时间显示 / Time Display
    ├── 时间设置 / Clock Setting
    └── 屏保时间 / Screensaver Timeout
```

**结论**:
- ✅ 确认了 84+ 个菜单字符串
- ✅ 确认了统一的 0x102 条目大小
- ✅ 确认了菜单层次结构
- ✅ 确认了编码使用规律
- ❌ 仍未找到访问代码

---

## 剩余问题

| 问题 | 优先级 | 状态 |
|------|--------|------|
| **找到引用字符串表的代码** | 🔴 高 | ❌ 未找到 |
| **找到引用索引表 (0x11503E) 的代码** | 🔴 高 | ❌ 未找到 |
| **追踪完整的字符串访问路径** | 🔴 高 | ⚠️ 有索引表，缺代码链接 |
| **理解菜单导航的实现** | 🟡 中 | ❓ 推断但未验证 |
| 确认语言表的实际用途 | 🟡 中 | ❓ 未知 |
| 理解 UTF-16 BE/LE 切换机制 | 🟡 中 | ❓ 编码切换机制未知 |

---

## 第九部分：多语言字符串系统 🎉 (2026-01-29)

### 发现概述

**🆕 重大发现：固件支持多语言！**

通过用户提供的韩文和丹麦文字符串，发现了固件支持 **7 种语言**的完整菜单系统。

### 支持的语言

| 语言 | 代码示例 | 位置 | 编码 | 数量 |
|------|---------|------|------|------|
| 简体中文 | 音乐播放 | 0x762500+ | UTF-16 BE | 13+ |
| 繁体中文 | 繁體中文 | 0x778000+ | UTF-16 BE | ✅ 已验证 |
| 英语 | English | 0x778000+ | UTF-16 LE | ✅ 已验证 |
| 日语 | 日本語 | 0x778000+ | UTF-16 BE | ✅ 已验证 |
| 法语 | Français | 0x778000+ | UTF-16 LE | ✅ 已验证 |
| 韩语 | 시스템 설정 | 0x7E0000+ | UTF-16 BE | 16 |
| 丹麦语 | Spiller nu | 0x8F0000+ | UTF-16 LE | 28 |

### 语言选择菜单 (0x778000)

**位置**: 0x778000-0x779000
**编码**: UTF-16 BE / UTF-16 LE 混合

| 地址 | 语言 | 编码 |
|------|------|------|
| 0x778462 | 繁體中文 | UTF-16 BE |
| 0x778565 | English | UTF-16 LE |
| 0x778666 | 日本語 | UTF-16 BE |
| 0x77886B | Français | UTF-16 LE |

### 韩文菜单系统 (0x7E0000)

**位置**: 0x7E0000-0x7EA000
**编码**: UTF-16 BE
**条目大小**: 0x102 (258 字节)

| 地址 | 字符串 | 含义 |
|------|--------|------|
| 0x7D42C8 | 시스템 설정 | 系统设置 |
| 0x7E31A2 | EQ 선택 | EQ 选择 |
| 0x7E6A12 | 화면설정 | 屏幕设置 |
| 0x7E7930 | 파워 오프 설정 | 关机设置 |
| 0x7E7A32 | 수면모드 | 睡眠模式 |
| 0x7E8140 | 배터리 부족으로 | 电池电量低 |
| 0x7E864A | 날짜 및 시간 | 日期和时间 |
| 0x7E874C | 시간 표시 | 时间显示 |
| 0x7E8950 | 화면 보호 시간 | 屏保时间 |
| 0x7E9262 | 인터페이스 스 | 界面风格 |
| 0x7E9466 | 미드나잇 다크 | 午夜黑 |
| 0x7E966A | 하늘색 | 天空蓝 |
| 0x7E976C | 빈티지 골드 | 复古金 |
| 0x7E986E | 언어 | 语言 |

**间距验证**：
- 多个间距为 0x102 (258 字节)
- 符合标准的条目大小

### 丹麦文菜单系统 (0x8F0000)

**位置**: 0x8F0000-0x905000
**编码**: UTF-16 LE
**条目大小**: 0x102 (258 字节)

#### 媒体库字符串 (0x8F4000)

| 地址 | 字符串 | 含义 | 间距 |
|------|--------|------|------|
| 0x8F4C95 | Spiller nu | 正在播放 | - |
| 0x8F4D97 | Alle musik | 所有音乐 | 0x102 |
| 0x8F4E99 | Kunstnere | 艺术家 | 0x102 |
| 0x8F509D | Skoler | 流派？ | 0x204 |
| 0x8F54A5 | Mine favoritter | 我的收藏 | - |

#### 设置菜单 (0x902000)

| 地址 | 字符串 | 含义 |
|------|--------|------|
| 0x90213B | Almindelige inds | 常规设置 |
| 0x902A4D | Lysstyrke | 亮度 |
| 0x903059 | Aflukningsindstill | 屏幕设置 |
| 0x90315B | PowerOff Tid | 关机时间 |
| 0x903869 | Automatisk sluk | 自动关机 |
| 0x903D73 | Dato og klokkes | 日期和时间 |
| 0x90498B | Grænseflade stil | 界面风格 |
| 0x904A8D | Elegant hvid | 优雅白 |
| 0x904B8F | Midnatsmørkt | 午夜黑 |
| 0x904C91 | Kirsebær pollen | 樱花粉 |
| 0x904D93 | Himlen blå | 天空蓝 |
| 0x904F97 | sprog | 语言 |

#### 其他字符串

| 地址 | 字符串 | 含义 |
|------|--------|------|
| 0x80C7C5 | Musikset | 音乐设置 |
| 0x87001D | Cover display | 封面显示 |
| 0x89FB07 | Mediebibliotek | 媒体库 |
| 0x8AFE09 | Vintage guld | 复古金 |
| 0x8EF9F1 | Indstillinger | 设置 |
| 0x8FDFB9 | Indstillinger for | 设置用于 |
| 0x800645 | Gain adjustment | 增益调整 |

### 条目大小验证

**韩文字符串**:
```
0x7E864A (날짜 및 시간) -> 0x7E874C (시간 표시): 间距 = 0x102 ✓
0x7E966A (하늘색) -> 0x7E976C (빈티지 골드): 间距 = 0x102 ✓
0x7E976C (빈티지 골드) -> 0x7E986E (언어): 间距 = 0x102 ✓
```

**丹麦文字符串**:
```
0x8F4C95 (Spiller nu) -> 0x8F4D97 (Alle musik): 间距 = 0x102 ✓
0x8F4D97 (Alle musik) -> 0x8F4E99 (Kunstnere): 间距 = 0x102 ✓
0x903059 (Aflukningsindstill) -> 0x90315B (PowerOff Tid): 间距 = 0x102 ✓
0x904A8D (Elegant hvid) -> 0x904B8F (Midnatsmørkt): 间距 = 0x102 ✓
0x904B8F (Midnatsmørkt) -> 0x904C91 (Kirsebær pollen): 间距 = 0x102 ✓
0x904C91 (Kirsebær pollen) -> 0x904D93 (Himlen blå): 间距 = 0x102 ✓
```

### 搜索结果统计

**搜索的字符串**: 71 个
**找到的字符串**: 48 个 (68%)
**未找到的字符串**: 23 个

**未找到的可能原因**:
1. 字符串被截断（如 "Bluetooth 설정" 可能是 "Bluetooth" + "설정"）
2. 有空格或特殊字符差异
3. 某些字符串可能是动态生成的
4. 编码方式不同

### 多语言系统结构

```
字符串表组织：
┌─────────────────────────────────────────────────────────────┐
│  语言选择 (0x778000)                                         │
│  ├─ 繁體中文 (UTF-16 BE)                                    │
│  ├─ English (UTF-16 LE)                                     │
│  ├─ 日本語 (UTF-16 BE)                                      │
│  └─ Français (UTF-16 LE)                                    │
├─────────────────────────────────────────────────────────────┤
│  简体中文 (0x762500+)                                        │
│  └─ 主菜单、设置菜单...                                      │
├─────────────────────────────────────────────────────────────┤
│  英文 (0x79B000+)                                            │
│  └─ 主菜单、设置菜单...                                      │
├─────────────────────────────────────────────────────────────┤
│  🆕 韩文 (0x7E0000+)                                         │
│  └─ 시스템 설정、화면설정...                                  │
├─────────────────────────────────────────────────────────────┤
│  🆕 丹麦文 (0x8F0000+)                                       │
│  └─ Spiller nu、Alle musik...                                │
└─────────────────────────────────────────────────────────────┘

所有语言表使用相同的结构：
- 条目大小: 0x102 (258 字节)
- 前导标记: FF FF
- 填充: 00 00
```

### 结论

1. **固件支持多语言** - 至少 7 种语言
2. **统一的字符串结构** - 所有语言使用 0x102 条目大小
3. **编码方式一致** - CJK 语言用 UTF-16 BE，欧洲语言用 UTF-16 LE
4. **完整的本地化** - 每种语言都有完整的菜单翻译

---

## 第八部分：数组组织与访问机制 🎉 (2026-01-29)

### 关键问题：数组是如何被找到的？

**问题**：这些字符串数组"散落"在固件中，程序如何知道它们在哪里？

### 答案：边界标记 + 硬编码地址

#### 1. 边界标记

所有字符串数组前面都有 **`FF FF FF FF`** 标记：

```
内存布局：
┌─────────────────────────────────────────────────────────┐
│  FF FF FF FF  │  FF FF  │  UTF-16 字符串  │  00 填充     │
│  (边界标记)    │ (前导)  │  (条目内容)     │             │
└─────────────────────────────────────────────────────────┘
    ↑ 数组开始
```

**验证数据**：

| 数组 | 地址 | 前4字节 | 前8字节 |
|------|------|---------|---------|
| 完美间距序列 | 0x7A0A62 | FF FF FF FF | FF FF FF FF FF FF FF FF |
| UI 菜单 | 0x79B0B0 | FF FF FF FF | FF FF FF FF FF FF FF FF |
| 中文主菜单 | 0x7625A8 | FF FF FF FF | FF FF FF FF FF FF FF FF |
| 中文设置菜单 | 0x777038 | FF FF FF FF | FF FF FF FF FF FF FF FF |

**边界标记的作用**：
- 内存对齐（可能是 16 字节对齐）
- 数组分界符
- 帮助验证数组位置

#### 2. 没有表头元数据

**搜索结果**：
- ❌ 没有"计数 + 基址"的表头结构
- ❌ 没有指向这些数组的指针表
- ❌ 没有统一的"资源管理器"

#### 3. 访问机制推测

基于以上发现，最可能的访问方式：

```
方式 1: 硬编码地址（最可能）
────────────────────────────
代码中直接包含数组地址：
    LDR R0, =0x7A0A62    @ 加载数组基址
    LDR R1, [R0, #2]     @ 加载第一个字符串

方式 2: 描述符表（未找到）
────────────────────────────
某个地方有描述符：
    struct {
        uint32_t base_addr;
        uint16_t count;
        uint16_t entry_size;
    } string_tables[];

方式 3: 索引表（部分找到）
────────────────────────────
已找到索引表 @ 0x11503E：
    - 指向 UI 菜单的部分字符串
    - 但索引表本身的引用未找到
```

#### 4. 为什么找不到访问代码？

**可能的原因**：

1. **动态计算地址**
   ```c
   // 运行时计算，而非硬编码
   base = some_base + offset;
   ```

2. **多级间接**
   ```
   指针表 → 索引表 → 字符串数组
   (已找到)   (已找到)   (已找到)
      ↑          ↑
      未找到   未找到引用
   ```

3. **特殊指令序列**
   - 使用了不常见的寻址模式
   - 通过寄存器间接访问

4. **代码在我们未搜索的区域**
   - 可能在压缩/加密的代码段
   - 可能在固件的其他部分

### 结论

**数组组织方式**：
- ✅ 固定大小数组（0x102 字节条目）
- ✅ 有边界标记（FF FF FF FF）
- ❌ 没有表头元数据
- ✅ 数组"散落"在固件中

**访问方式**：
- ⚠️ 可能是硬编码地址
- ⚠️ 可能通过描述符表（未找到）
- ⚠️ 可能通过索引表（部分找到）

**为什么找不到访问代码**：
- ❌ 静态分析的局限性
- ❌ 可能有动态计算或特殊机制
- ❌ 可能在未搜索的代码区域

---

## 建议的后续方向

### ✅ 成功的方法（可以继续使用）

1. **数据驱动的字符串发现** ✅
   - 通过搜索字节模式找到字符串
   - 验证字符串的编码和结构
   - 确定数据布局（条目大小、间距等）

2. **UTF-16 字节内容搜索** ✅
   - 成功找到 "Music" 字符串在 0x08F7DF
   - 识别了数据被误认为代码的情况

### ❌ 失败的方法（不要重复）

1. **LDR/ADR 指令搜索** ❌
   - 搜索 PC-relative 加载
   - 搜索 ADR 地址计算
   - 结果：未找到任何引用

2. **MOVW/MOVT 搜索** ❌
   - 搜索地址加载指令
   - 结果：未找到匹配

3. **指针表扫描** ❌
   - 扫描全固件查找指针
   - 结果：找到 7 个指针但都指向无效数据

4. **代码反汇编** ❌
   - 尝试反汇编指针所在区域
   - 结果：无法反汇编为有效指令

5. **反向追踪 BL 调用** ❌
   - 从已知渲染代码 (0x2DB58) 搜索 BL 调用者
   - 扫描范围：0x1000 - 0x200000
   - 结果：未找到任何 BL 指令指向渲染区域
   - 说明：渲染代码可能通过函数指针、跳转表或内联方式调用

### 🔬 建议的新方法

1. **分析 Part 3 (Resource) 索引表** 🟡 优先级提升
   - Part 3 是 Big-Endian 索引表（938,405 条目）
   - 可能包含字符串 ID 到地址的映射
   - 需要分析索引值与字符串地址 (0x778000, 0x79B000) 的关系
   - 可能是字符串查找的关键

2. **动态分析**（需要设备）
   - 在真实设备上设置断点
   - 观察哪些代码访问字符串区域
   - 追踪运行时的数据流

3. **符号执行**（需要工具）
   - 使用 angr 或类似工具
   - 从已知的渲染代码点向后追踪
   - 探索所有可能的执行路径

4. **分析 0x2DB58 的调用机制** 🟡 新发现
   - 0x2DB58 不是独立函数（没有函数序言）
   - 可能是内联代码或通过跳转表调用
   - 需要找到包含这段代码的更大函数块

5. **分析发现的字符串位置** 🟡 新发现
   - 0x08F7DF 包含 "Music" 字符串（UTF-16 LE）
   - 这是数据，不是代码（尽管被反汇编器误解释）
   - 需要找到引用这个位置的代码

6. **接受静态分析的局限性**
   - 承认某些问题无法通过静态分析解决
   - 将字符串表标记为"数据存在，访问方式未知"
   - 继续专注于可以确认的部分（位图字体渲染）

### 📚 方法论教训

这次搜索强调了 [METHODOLOGY_LESSONS.md](../01_OVERVIEW/METHODOLOGY_LESSONS.md) 中的核心原则：

> ❌ **错误做法**：
> - 发现数据 → 观察模式 → 推导公式 → 搜索"匹配" → 假设即证明
>
> ✅ **正确做法**：
> - 只文档化能从代码证明的东西
> - 诚实地区分"数据存在"、"代码证据"、"功能确认"

---

## 参见

- [内存布局图](../02_ARCHITECTURE/MEMORY_MAP.md)
- [Unicode→r5映射分析](./UNICODE_TO_R5_MAPPING.md)
- [未解决问题](../01_OVERVIEW/REMAINING_WORK.md)
- [方法论经验教训](../01_OVERVIEW/METHODOLOGY_LESSONS.md)

---

## 第十部分：语言查找表查找 🔬 (2026-01-29)

### 分析目标

**目标**: 找到语言 ID (0-11) 到语言表基址的查找机制，以理解系统如何根据语言选择获取对应语言的字符串表。

### 已知语言基址

| 语言 ID | 基址 | 高字节 | 中字节 | 语言名称 |
|--------|------|--------|--------|----------|
| 0 | 0x762500 | 0x76 | 0x25 | 简体中文 |
| 1 | 0x778462 | 0x77 | 0x84 | 繁体中文 |
| 2 | 0x79B000 | 0x79 | 0xB0 | 英语 |
| 3 | 0x7B7000 | 0x7B | 0x70 | 日语 |
| 4 | 0x7E0000 | 0x7E | 0x00 | 韩语 |
| 5 | 0x7F0000 | 0x7F | 0x00 | 法语 |
| 6 | 0x800000 | 0x80 | 0x00 | 德语 |
| 7 | 0x820000 | 0x82 | 0x00 | 意大利语 |
| 8 | 0x840000 | 0x84 | 0x00 | 西班牙语 |
| 9 | 0x850000 | 0x85 | 0x00 | 葡萄牙语 |
| 10 | 0x8F0000 | 0x8F | 0x00 | 丹麦语 |
| 11 | 0x870000 | 0x87 | 0x00 | 俄语 |

### 关键观察

**语言 4-11 的中字节都是 0x00**：
- 这意味着它们的基址格式非常简单：`基址 = (高字节 << 16) | 0x0000`
- 例如：语言 4 (韩语) = 0x7E0000，语言 6 (德语) = 0x800000

**语言 0-3 有非零中字节**：
- 语言 0: 0x25
- 语言 1: 0x84
- 语言 2: 0xB0
- 语言 3: 0x70

### 发现的数据结构

#### 1. 0x013B28: 连续值表

**格式**: `[0x30, value]` (2字节条目)

**特点**:
- value 从 0x66 连续递增
- 语言高字节在索引 16-31
- 索引计算: `索引 = 高字节 - 0x66`

**高字节索引映射**:
| 高字节 | 语言 | 索引 |
|--------|------|------|
| 0x76 | 简体中文 | 16 |
| 0x77 | 繁体中文 | 17 |
| 0x79 | 英语 | 19 |
| 0x7B | 日语 | 21 |
| 0x7E | 韩语 | 24 |
| 0x7F | 法语 | 25 |
| 0x80 | 德语 | 26 |
| 0x82 | 意大利语 | 28 |
| 0x84 | 西班牙语 | 30 |
| 0x85 | 葡萄牙语 | 31 |

#### 2. 0x01AAD2: [0xB0, 高字节] 表

**格式**: `[0xB0, 高字节]` (2字节条目)

**包含的语言**: 9/12 种

| 位置 | 高字节 | 语言 | 索引匹配? |
|------|--------|------|-----------|
| [0] | 0x76 | 语言 0 (简体中文) | ✓ |
| [1] | 0x77 | 语言 1 (繁体中文) | ✓ |
| [2] | 0x78 | (非语言) | ✗ |
| [3] | 0x79 | 语言 2 (英语) | ✗ (索引3≠2) |
| [5] | 0x7B | 语言 3 (日语) | ✗ (索引5≠3) |
| [6] | 0x7E | 语言 4 (韩语) | ✓ |
| [7] | 0x7F | 语言 5 (法语) | ✓ |
| [9] | 0x82 | 语言 7 (意大利语) | ✗ (索引9≠7) |
| [11] | 0x85 | 语言 9 (葡萄牙语) | ✗ (索引11≠9) |
| [13] | 0x87 | 语言 11 (俄语) | ✗ (索引13≠11) |

**缺失的语言**: 语言 6 (德语 0x80), 8 (西班牙语 0x84), 10 (丹麦语 0x8F)

**结论**: 这个表**不是**按语言 ID 索引的查找表，可能是其他用途的数据结构。

#### 3. 0x0136D6: 未知格式数据

**数据**: `7E 82 7F 4C 80 00 81 DA 82 66 85 FB...`

**解析尝试**:
- 格式1: `[val1, val2]` 其中 val2 是高字节
- 格式2: `[高字节, 中字节]` 或其他组合

**结果**: 无法确定确切格式，包含部分语言高字节，但不构成完整的查找表。

### 搜索方法

尝试了多种搜索方法：

| 方法 | 描述 | 结果 |
|------|------|------|
| 搜索 [ID, 高字节] 对 (2字节) | 按语言ID顺序 | ❌ 未找到 |
| 搜索 [高字节, ID] 对 (2字节) | 反向顺序 | ❌ 未找到 |
| 搜索连续的高字节序列 | 1字节条目 | ❌ 未找到完整序列 |
| 搜索4字节条目 [ID, 0, 中, 高] | 包含中字节 | ❌ 未找到 |
| 搜索0xB0前缀格式 | 字符编码表? | ⚠️ 找到9/12语言 |

### 当前状态

**✅ 已确认**:
- 12种语言的基址
- 语言 4-11 的中字节都是 0x00
- 找到包含语言高字节的数据结构，但不是直接映射

**❌ 未找到**:
- 按语言 ID (0-11) 直接索引的查找表
- 语言 ID 到高字节的映射算法
- 语言 ID 到基址的完整转换代码

### 推测的查找机制

基于当前发现，可能的查找方式：

1. **直接计算**: `高字节 = f(语言ID)` 或 `基址 = g(语言ID)`
2. **多级查找**: 语言ID → 中间值 → 高字节
3. **分表处理**: 语言 0-3 和 4-11 使用不同的查找方式
4. **硬编码**: 在代码中直接使用 CASE 语句

### 建议下一步

1. ✅ 使用 pyhidra 进行深入的代码分析
2. 搜索语言切换/选择函数
3. 追踪代码中如何使用语言 ID
4. 分析 LDR/MOV 指令序列，特别是加载 0x76-0x8F 范围值的指令

---

## 第十一部分：直接二进制分析 (2026-01-29)

### 分析背景

由于 Ghidra pyhidra 在当前环境 (NixOS) 中遇到文件系统权限问题，本次使用**直接二进制搜索**方法来查找语言 ID 到基址的映射机制。

### 新发现的数据结构

#### 1. 0x013B48: 连续高字节值表

**格式**: `[0x30, high_byte]` (2字节条目)

**内容**: 包含从 0x76 开始的**连续高字节值序列**

| 位置 | 内容 | 说明 |
|------|------|------|
| [0] | [0x30, 0x76] | 高字节 0x76 |
| [1] | [0x30, 0x77] | 高字节 0x77 |
| [2] | [0x30, 0x78] | 高字节 0x78 (未使用) |
| [3] | [0x30, 0x79] | 高字节 0x79 (英语) |
| ... | ... | ... |
| [25] | [0x30, 0x8F] | 高字节 0x8F (丹麦语) |

**特点**:
- 这是**连续值表**，不是按语言ID索引的查找表
- 索引 = 高字节 - 0x76
- 包含所有可能的高字节值 (0x76-0x8F)，包括未使用的值

#### 2. 0x0014B4: 重复的连续值表

**格式**: `[0x30, high_byte]` (2字节条目)

**内容**: 与 0x013B48 **完全相同**

**结论**: 固件中存在该表的多个副本，可能是为了不同的代码模块使用。

### 关键发现：表索引与语言ID的关系

**重要观察**:
```
表位置 = 高字节 - 0x76

例如:
- 0x76 - 0x76 = 0 → 表位置 [0]
- 0x77 - 0x76 = 1 → 表位置 [1]
- 0x79 - 0x76 = 3 → 表位置 [3]
- 0x8F - 0x76 = 25 → 表位置 [25]
```

**这意味着**:
1. 该表**不是**语言ID → 高字节的直接映射
2. 该表可能是**高字节 → 某种属性**的映射
3. 需要通过**高字节值**作为索引来访问该表

### 推测的查找机制

基于当前发现，系统可能使用以下方式查找语言基址：

```
方法1: 直接计算 (对于语言4-11)
  基址 = (高字节 << 16) | 0x0000

方法2: 多级查找
  语言ID → (某个查找) → 高字节 → 基址

方法3: 硬编码映射
  代码中可能包含 switch/case 语句
```

### 仍未找到

❌ **语言ID (0-11) 到高字节 (0x76/0x77/0x79...) 的直接映射表**

期望的表格式应该是：
```
[0, 0x76]  // 语言 0 → 0x76
[1, 0x77]  // 语言 1 → 0x77
[2, 0x79]  // 语言 2 → 0x79
[3, 0x7B]  // 语言 3 → 0x7B
...
```

但实际搜索中**未找到**这种格式的表。

### 分析工具限制

**Ghidra pyhidra 问题**:
```
PermissionError: [Errno 13] Permission denied:
  '/tmp/tmpXXXXXX/plugin/PyScriptProviderNew.java' ->
  '/tmp/tmpXXXXXX/plugin/PyScriptProvider.java'
```

这是 NixOS 环境下的文件系统特性导致的，pyhidra 无法正常安装插件。

### 建议下一步

1. 尝试使用 **Ghidra GUI** 手动分析
2. 在 **0x10000-0x50000** 范围内搜索加载高字节值的 LDR/MOV 指令
3. 分析 **语言选择菜单** (0x778000 区域) 的代码
4. 尝试使用 **rizin** 等其他工具进行代码分析

---

## 第十二部分：代码级发现 - 语言查找指令 (2026-01-29)

### 关键代码发现

在 **0x0138F5** 发现了访问语言高字节表的关键指令：

```
0x0138F5: LDR R0, [PC, +0x250] -> [0x013B49] = 0x76
```

**详细分析**:
- **指令**: `LDR R0, [PC, +0x250]`
- **目标地址**: 0x0138F5 + 4 + 0x250 = 0x013B49
- **加载的值**: 0x76 (简体中文的高字节)

### 表结构验证

**0x013B48 表的完整结构**:

| 偏移 | 地址 | 内容 | 说明 |
|-----|------|------|------|
| +0x00 | 0x013B48 | [0x30, 0x76] | 条目 [0]: 高字节 0x76 |
| +0x02 | 0x013B4A | [0x30, 0x77] | 条目 [1]: 高字节 0x77 |
| +0x04 | 0x013B4C | [0x30, 0x78] | 条目 [2]: 高字节 0x78 (未使用) |
| +0x06 | 0x013B4E | [0x30, 0x79] | 条目 [3]: 高字节 0x79 |
| ... | ... | ... | ... |
| +0x50 | 0x013B98 | [0x30, 0x8F] | 条目 [40]: 高字节 0x8F (丹麦语) |

**关键观察**:
- 每个条目占 2 字节：`[0x30, high_byte]`
- 0x013B49 是第一个条目的**第二个字节** (高字节值本身)
- 指令加载的是 `firmware[0x013B49] = 0x76`

### 访问模式分析

**方式1: 直接加载高字节值**
```c
// 加载语言0的高字节 (0x76)
addr = 0x013B48 + 0 * 2 + 1;  // = 0x013B49
high_byte = firmware[addr];     // = 0x76

// 加载语言1的高字节 (0x77)
addr = 0x013B48 + 1 * 2 + 1;  // = 0x013B4B
high_byte = firmware[addr];     // = 0x77
```

**方式2: 通过高字节值作为索引**
```c
// 如果已知高字节值，查找它在表中的位置
index = high_byte - 0x76;
addr = 0x013B48 + index * 2;
```

### 推测的查找算法

基于当前发现，语言查找可能使用以下算法：

```c
uint8_t get_language_high_byte(uint8_t lang_id) {
    // 可能有某种映射表或计算
    // 仍未找到 lang_id -> high_byte 的直接映射

    // 可能的实现方式：
    // 1. switch/case 语句
    // 2. 另一个查找表
    // 3. 算法计算
}

uint32_t get_language_base(uint8_t lang_id) {
    uint8_t high_byte = get_language_high_byte(lang_id);

    // 对于语言 4-11 (mid_byte = 0x00)
    if (lang_id >= 4) {
        return (high_byte << 16) | 0x0000;
    }

    // 对于语言 0-3 (需要额外的 mid_byte 和 low_byte)
    // 需要另一个查找表或硬编码
    return (high_byte << 16) | (mid_byte << 8) | low_byte;
}
```

### 搜索到的相关指令

在代码中发现了多个加载高字节值的 LDR 指令：

| 地址 | 指令 | 目标 | 加载值 |
|------|------|------|--------|
| 0x0138F5 | LDR R0, [PC, +0x250] | 0x013B49 | 0x76 |
| 0x013911 | LDR R1, [PC, +0x270] | 0x013B85 | 0xA1 |
| 0x013AED | LDR R0, [PC, +0x2C0] | 0x013BB1 | 0x00 |
| 0x013AEF | LDR R1, [PC, +0x2C0] | 0x013BB3 | 0x00 |

### 下一步行动

1. ✅ **找到 lang_id -> high_byte 的映射机制** - 这是关键缺失部分
2. 分析 0x0138F5 附近的函数，理解完整的查找流程
3. 搜索可能包含语言 ID 到高字节映射的其他数据结构
4. 尝试使用 Ghidra GUI 手动反汇编相关代码段

---

**重要提示**: 本文档记录的是数据发现，不是功能确认。这些字符串数据的实际用途需要在代码中找到引用才能确认。
